Disassembly Listing for RTOSDemo_PIC24
Generated From:
C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Demo/PIC24_MPLAB/RTOSDemo_PIC24.X/dist/default/debug/RTOSDemo_PIC24.X.debug.elf
2018-12-2 12:53:02

---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Source/tasks.c  -----------------------------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                /* Standard includes. */
29:                #include <stdlib.h>
30:                #include <string.h>
31:                
32:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
33:                all the API functions to use the MPU wrappers.  That should only be done when
34:                task.h is included from an application file. */
35:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
36:                
37:                /* FreeRTOS includes. */
38:                #include "FreeRTOS.h"
39:                #include "task.h"
40:                #include "timers.h"
41:                #include "stack_macros.h"
42:                
43:                /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
44:                because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
45:                for the header files above, but not in this file, in order to generate the
46:                correct privileged Vs unprivileged linkage and placement. */
47:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
48:                
49:                /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
50:                functions but without including stdio.h here. */
51:                #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
52:                	/* At the bottom of this file are two optional functions that can be used
53:                	to generate human readable text from the raw data generated by the
54:                	uxTaskGetSystemState() function.  Note the formatting functions are provided
55:                	for convenience only, and are NOT considered part of the kernel. */
56:                	#include <stdio.h>
57:                #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
58:                
59:                #if( configUSE_PREEMPTION == 0 )
60:                	/* If the cooperative scheduler is being used then a yield should not be
61:                	performed just because a higher priority task has been woken. */
62:                	#define taskYIELD_IF_USING_PREEMPTION()
63:                #else
64:                	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
65:                #endif
66:                
67:                /* Values that can be assigned to the ucNotifyState member of the TCB. */
68:                #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
69:                #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
70:                #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
71:                
72:                /*
73:                 * The value used to fill the stack of a task when the task is created.  This
74:                 * is used purely for checking the high water mark for tasks.
75:                 */
76:                #define tskSTACK_FILL_BYTE	( 0xa5U )
77:                
78:                /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
79:                dynamically allocated RAM, in which case when any task is deleted it is known
80:                that both the task's stack and TCB need to be freed.  Sometimes the
81:                FreeRTOSConfig.h settings only allow a task to be created using statically
82:                allocated RAM, in which case when any task is deleted it is known that neither
83:                the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
84:                settings allow a task to be created using either statically or dynamically
85:                allocated RAM, in which case a member of the TCB is used to record whether the
86:                stack and/or TCB were allocated statically or dynamically, so when a task is
87:                deleted the RAM that was allocated dynamically is freed again and no attempt is
88:                made to free the RAM that was allocated statically.
89:                tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
90:                task to be created using either statically or dynamically allocated RAM.  Note
91:                that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
92:                a statically allocated stack and a dynamically allocated TCB.
93:                !!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
94:                changed then the definition of StaticTask_t must also be updated. */
95:                #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
96:                #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
97:                #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
98:                #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
99:                
100:               /* If any of the following are set then task stacks are filled with a known
101:               value so the high water mark can be determined.  If none of the following are
102:               set then don't fill the stack so there is no unnecessary dependency on memset. */
103:               #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
104:               	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
105:               #else
106:               	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
107:               #endif
108:               
109:               /*
110:                * Macros used by vListTask to indicate which state a task is in.
111:                */
112:               #define tskRUNNING_CHAR		( 'X' )
113:               #define tskBLOCKED_CHAR		( 'B' )
114:               #define tskREADY_CHAR		( 'R' )
115:               #define tskDELETED_CHAR		( 'D' )
116:               #define tskSUSPENDED_CHAR	( 'S' )
117:               
118:               /*
119:                * Some kernel aware debuggers require the data the debugger needs access to be
120:                * global, rather than file scope.
121:                */
122:               #ifdef portREMOVE_STATIC_QUALIFIER
123:               	#define static
124:               #endif
125:               
126:               /* The name allocated to the Idle task.  This can be overridden by defining
127:               configIDLE_TASK_NAME in FreeRTOSConfig.h. */
128:               #ifndef configIDLE_TASK_NAME
129:               	#define configIDLE_TASK_NAME "IDLE"
130:               #endif
131:               
132:               #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
133:               
134:               	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
135:               	performed in a generic way that is not optimised to any particular
136:               	microcontroller architecture. */
137:               
138:               	/* uxTopReadyPriority holds the priority of the highest priority ready
139:               	state task. */
140:               	#define taskRECORD_READY_PRIORITY( uxPriority )														\
141:               	{																									\
142:               		if( ( uxPriority ) > uxTopReadyPriority )														\
143:               		{																								\
144:               			uxTopReadyPriority = ( uxPriority );														\
145:               		}																								\
146:               	} /* taskRECORD_READY_PRIORITY */
147:               
148:               	/*-----------------------------------------------------------*/
149:               
150:               	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
151:               	{																									\
152:               	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
153:               																										\
154:               		/* Find the highest priority queue that contains ready tasks. */								\
155:               		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
156:               		{																								\
157:               			configASSERT( uxTopPriority );																\
158:               			--uxTopPriority;																			\
159:               		}																								\
160:               																										\
161:               		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
162:               		the	same priority get an equal share of the processor time. */									\
163:               		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
164:               		uxTopReadyPriority = uxTopPriority;																\
165:               	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
166:               
167:               	/*-----------------------------------------------------------*/
168:               
169:               	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
170:               	they are only required when a port optimised method of task selection is
171:               	being used. */
172:               	#define taskRESET_READY_PRIORITY( uxPriority )
173:               	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
174:               
175:               #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
176:               
177:               	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
178:               	performed in a way that is tailored to the particular microcontroller
179:               	architecture being used. */
180:               
181:               	/* A port optimised version is provided.  Call the port defined macros. */
182:               	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
183:               
184:               	/*-----------------------------------------------------------*/
185:               
186:               	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
187:               	{																								\
188:               	UBaseType_t uxTopPriority;																		\
189:               																									\
190:               		/* Find the highest priority list that contains ready tasks. */								\
191:               		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
192:               		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
193:               		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
194:               	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
195:               
196:               	/*-----------------------------------------------------------*/
197:               
198:               	/* A port optimised version is provided, call it only if the TCB being reset
199:               	is being referenced from a ready list.  If it is referenced from a delayed
200:               	or suspended list then it won't be in a ready list. */
201:               	#define taskRESET_READY_PRIORITY( uxPriority )														\
202:               	{																									\
203:               		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
204:               		{																								\
205:               			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
206:               		}																								\
207:               	}
208:               
209:               #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
210:               
211:               /*-----------------------------------------------------------*/
212:               
213:               /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
214:               count overflows. */
215:               #define taskSWITCH_DELAYED_LISTS()																	\
216:               {																									\
217:               	List_t *pxTemp;																					\
218:               																									\
219:               	/* The delayed tasks list should be empty when the lists are switched. */						\
220:               	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
221:               																									\
222:               	pxTemp = pxDelayedTaskList;																		\
223:               	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
224:               	pxOverflowDelayedTaskList = pxTemp;																\
225:               	xNumOfOverflows++;																				\
226:               	prvResetNextTaskUnblockTime();																	\
227:               }
228:               
229:               /*-----------------------------------------------------------*/
230:               
231:               /*
232:                * Place the task represented by pxTCB into the appropriate ready list for
233:                * the task.  It is inserted at the end of the list.
234:                */
235:               #define prvAddTaskToReadyList( pxTCB )																\
236:               	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
237:               	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
238:               	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
239:               	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
240:               /*-----------------------------------------------------------*/
241:               
242:               /*
243:                * Several functions take an TaskHandle_t parameter that can optionally be NULL,
244:                * where NULL is used to indicate that the handle of the currently executing
245:                * task should be used in place of the parameter.  This macro simply checks to
246:                * see if the parameter is NULL and returns a pointer to the appropriate TCB.
247:                */
248:               #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
249:               
250:               /* The item value of the event list item is normally used to hold the priority
251:               of the task to which it belongs (coded to allow it to be held in reverse
252:               priority order).  However, it is occasionally borrowed for other purposes.  It
253:               is important its value is not updated due to a task priority change while it is
254:               being used for another purpose.  The following bit definition is used to inform
255:               the scheduler that the value should not be changed - in which case it is the
256:               responsibility of whichever module is using the value to ensure it gets set back
257:               to its original value when it is released. */
258:               #if( configUSE_16_BIT_TICKS == 1 )
259:               	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
260:               #else
261:               	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
262:               #endif
263:               
264:               /*
265:                * Task control block.  A task control block (TCB) is allocated for each task,
266:                * and stores task state information, including a pointer to the task's context
267:                * (the task's run time environment, including register values)
268:                */
269:               typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */
270:               {
271:               	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
272:               
273:               	#if ( portUSING_MPU_WRAPPERS == 1 )
274:               		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
275:               	#endif
276:               
277:               	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
278:               	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
279:               	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
280:               	StackType_t			*pxStack;			/*< Points to the start of the stack. */
281:               	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
282:               
283:               	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
284:               		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
285:               	#endif
286:               
287:               	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
288:               		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
289:               	#endif
290:               
291:               	#if ( configUSE_TRACE_FACILITY == 1 )
292:               		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
293:               		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
294:               	#endif
295:               
296:               	#if ( configUSE_MUTEXES == 1 )
297:               		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
298:               		UBaseType_t		uxMutexesHeld;
299:               	#endif
300:               
301:               	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
302:               		TaskHookFunction_t pxTaskTag;
303:               	#endif
304:               
305:               	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
306:               		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
307:               	#endif
308:               
309:               	#if( configGENERATE_RUN_TIME_STATS == 1 )
310:               		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
311:               	#endif
312:               
313:               	#if ( configUSE_NEWLIB_REENTRANT == 1 )
314:               		/* Allocate a Newlib reent structure that is specific to this task.
315:               		Note Newlib support has been included by popular demand, but is not
316:               		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
317:               		responsible for resulting newlib operation.  User must be familiar with
318:               		newlib and must provide system-wide implementations of the necessary
319:               		stubs. Be warned that (at the time of writing) the current newlib design
320:               		implements a system-wide malloc() that must be provided with locks. */
321:               		struct	_reent xNewLib_reent;
322:               	#endif
323:               
324:               	#if( configUSE_TASK_NOTIFICATIONS == 1 )
325:               		volatile uint32_t ulNotifiedValue;
326:               		volatile uint8_t ucNotifyState;
327:               	#endif
328:               
329:               	/* See the comments above the definition of
330:               	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
331:               	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
332:               		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
333:               	#endif
334:               
335:               	#if( INCLUDE_xTaskAbortDelay == 1 )
336:               		uint8_t ucDelayAborted;
337:               	#endif
338:               
339:               	#if( configUSE_POSIX_ERRNO == 1 )
340:               		int iTaskErrno;
341:               	#endif
342:               
343:               } tskTCB;
344:               
345:               /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
346:               below to enable the use of older kernel aware debuggers. */
347:               typedef tskTCB TCB_t;
348:               
349:               /*lint -save -e956 A manual analysis and inspection has been used to determine
350:               which static variables must be declared volatile. */
351:               PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
352:               
353:               /* Lists for ready and blocked tasks. --------------------
354:               xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
355:               doing so breaks some kernel aware debuggers and debuggers that rely on removing
356:               the static qualifier. */
357:               PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
358:               PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
359:               PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
360:               PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
361:               PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
362:               PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
363:               
364:               #if( INCLUDE_vTaskDelete == 1 )
365:               
366:               	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
367:               	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
368:               
369:               #endif
370:               
371:               #if ( INCLUDE_vTaskSuspend == 1 )
372:               
373:               	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
374:               
375:               #endif
376:               
377:               /* Global POSIX errno. Its value is changed upon context switching to match
378:               the errno of the currently running task. */
379:               #if ( configUSE_POSIX_ERRNO == 1 )
380:               	int FreeRTOS_errno = 0;
381:               #endif
382:               
383:               /* Other file private variables. --------------------------------*/
384:               PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
385:               PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT;
386:               PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
387:               PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
388:               PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
389:               PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
390:               PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
391:               PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
392:               PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
393:               PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
394:               
395:               /* Context switches are held pending while the scheduler is suspended.  Also,
396:               interrupts must not manipulate the xStateListItem of a TCB, or any of the
397:               lists the xStateListItem can be referenced from, if the scheduler is suspended.
398:               If an interrupt needs to unblock a task while the scheduler is suspended then it
399:               moves the task's event list item into the xPendingReadyList, ready for the
400:               kernel to move the task from the pending ready list into the real ready list
401:               when the scheduler is unsuspended.  The pending ready list itself can only be
402:               accessed from a critical section. */
403:               PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
404:               
405:               #if ( configGENERATE_RUN_TIME_STATS == 1 )
406:               
407:               	/* Do not move these variables to function scope as doing so prevents the
408:               	code working with debuggers that need to remove the static qualifier. */
409:               	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
410:               	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
411:               
412:               #endif
413:               
414:               /*lint -restore */
415:               
416:               /*-----------------------------------------------------------*/
417:               
418:               /* Callback function prototypes. --------------------------*/
419:               #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
420:               
421:               	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
422:               
423:               #endif
424:               
425:               #if( configUSE_TICK_HOOK > 0 )
426:               
427:               	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application callback. */
428:               
429:               #endif
430:               
431:               #if( configSUPPORT_STATIC_ALLOCATION == 1 )
432:               
433:               	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize ); /*lint !e526 Symbol not defined as it is an application callback. */
434:               
435:               #endif
436:               
437:               /* File private functions. --------------------------------*/
438:               
439:               /**
440:                * Utility task that simply returns pdTRUE if the task referenced by xTask is
441:                * currently in the Suspended state, or pdFALSE if the task referenced by xTask
442:                * is in any other state.
443:                */
444:               #if ( INCLUDE_vTaskSuspend == 1 )
445:               
446:               	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
447:               
448:               #endif /* INCLUDE_vTaskSuspend */
449:               
450:               /*
451:                * Utility to ready all the lists used by the scheduler.  This is called
452:                * automatically upon the creation of the first task.
453:                */
454:               static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
455:               
456:               /*
457:                * The idle task, which as all tasks is implemented as a never ending loop.
458:                * The idle task is automatically created and added to the ready lists upon
459:                * creation of the first user task.
460:                *
461:                * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
462:                * language extensions.  The equivalent prototype for this function is:
463:                *
464:                * void prvIdleTask( void *pvParameters );
465:                *
466:                */
467:               static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
468:               
469:               /*
470:                * Utility to free all memory allocated by the scheduler to hold a TCB,
471:                * including the stack pointed to by the TCB.
472:                *
473:                * This does not free memory allocated by the task itself (i.e. memory
474:                * allocated by calls to pvPortMalloc from within the tasks application code).
475:                */
476:               #if ( INCLUDE_vTaskDelete == 1 )
477:               
478:               	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
479:               
480:               #endif
481:               
482:               /*
483:                * Used only by the idle task.  This checks to see if anything has been placed
484:                * in the list of tasks waiting to be deleted.  If so the task is cleaned up
485:                * and its TCB deleted.
486:                */
487:               static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
488:               
489:               /*
490:                * The currently executing task is entering the Blocked state.  Add the task to
491:                * either the current or the overflow delayed task list.
492:                */
493:               static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
494:               
495:               /*
496:                * Fills an TaskStatus_t structure with information on each task that is
497:                * referenced from the pxList list (which may be a ready list, a delayed list,
498:                * a suspended list, etc.).
499:                *
500:                * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
501:                * NORMAL APPLICATION CODE.
502:                */
503:               #if ( configUSE_TRACE_FACILITY == 1 )
504:               
505:               	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
506:               
507:               #endif
508:               
509:               /*
510:                * Searches pxList for a task with name pcNameToQuery - returning a handle to
511:                * the task if it is found, or NULL if the task is not found.
512:                */
513:               #if ( INCLUDE_xTaskGetHandle == 1 )
514:               
515:               	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
516:               
517:               #endif
518:               
519:               /*
520:                * When a task is created, the stack of the task is filled with a known value.
521:                * This function determines the 'high water mark' of the task stack by
522:                * determining how much of the stack remains at the original preset value.
523:                */
524:               #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
525:               
526:               	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
527:               
528:               #endif
529:               
530:               /*
531:                * Return the amount of time, in ticks, that will pass before the kernel will
532:                * next move a task from the Blocked state to the Running state.
533:                *
534:                * This conditional compilation should use inequality to 0, not equality to 1.
535:                * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
536:                * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
537:                * set to a value other than 1.
538:                */
539:               #if ( configUSE_TICKLESS_IDLE != 0 )
540:               
541:               	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
542:               
543:               #endif
544:               
545:               /*
546:                * Set xNextTaskUnblockTime to the time at which the next Blocked state task
547:                * will exit the Blocked state.
548:                */
549:               static void prvResetNextTaskUnblockTime( void );
550:               
551:               #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
552:               
553:               	/*
554:               	 * Helper function used to pad task names with spaces when printing out
555:               	 * human readable tables of task information.
556:               	 */
557:               	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
558:               
559:               #endif
560:               
561:               /*
562:                * Called after a Task_t structure has been allocated either statically or
563:                * dynamically to fill in the structure's members.
564:                */
565:               static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
566:               									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
567:               									const uint32_t ulStackDepth,
568:               									void * const pvParameters,
569:               									UBaseType_t uxPriority,
570:               									TaskHandle_t * const pxCreatedTask,
571:               									TCB_t *pxNewTCB,
572:               									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
573:               
574:               /*
575:                * Called after a new task has been created and initialised to place the task
576:                * under the control of the scheduler.
577:                */
578:               static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
579:               
580:               /*
581:                * freertos_tasks_c_additions_init() should only be called if the user definable
582:                * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
583:                * called by the function.
584:                */
585:               #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
586:               
587:               	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
588:               
589:               #endif
590:               
591:               /*-----------------------------------------------------------*/
592:               
593:               #if( configSUPPORT_STATIC_ALLOCATION == 1 )
594:               
595:               	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
596:               									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
597:               									const uint32_t ulStackDepth,
598:               									void * const pvParameters,
599:               									UBaseType_t uxPriority,
600:               									StackType_t * const puxStackBuffer,
601:               									StaticTask_t * const pxTaskBuffer )
602:               	{
603:               	TCB_t *pxNewTCB;
604:               	TaskHandle_t xReturn;
605:               
606:               		configASSERT( puxStackBuffer != NULL );
607:               		configASSERT( pxTaskBuffer != NULL );
608:               
609:               		#if( configASSERT_DEFINED == 1 )
610:               		{
611:               			/* Sanity check that the size of the structure used to declare a
612:               			variable of type StaticTask_t equals the size of the real task
613:               			structure. */
614:               			volatile size_t xSize = sizeof( StaticTask_t );
615:               			configASSERT( xSize == sizeof( TCB_t ) );
616:               			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
617:               		}
618:               		#endif /* configASSERT_DEFINED */
619:               
620:               
621:               		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
622:               		{
623:               			/* The memory used for the task's TCB and stack are passed into this
624:               			function - use them. */
625:               			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
626:               			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
627:               
628:               			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
629:               			{
630:               				/* Tasks can be created statically or dynamically, so note this
631:               				task was created statically in case the task is later deleted. */
632:               				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
633:               			}
634:               			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
635:               
636:               			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
637:               			prvAddNewTaskToReadyList( pxNewTCB );
638:               		}
639:               		else
640:               		{
641:               			xReturn = NULL;
642:               		}
643:               
644:               		return xReturn;
645:               	}
646:               
647:               #endif /* SUPPORT_STATIC_ALLOCATION */
648:               /*-----------------------------------------------------------*/
649:               
650:               #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
651:               
652:               	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
653:               	{
654:               	TCB_t *pxNewTCB;
655:               	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
656:               
657:               		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
658:               		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
659:               
660:               		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
661:               		{
662:               			/* Allocate space for the TCB.  Where the memory comes from depends
663:               			on the implementation of the port malloc function and whether or
664:               			not static allocation is being used. */
665:               			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
666:               
667:               			/* Store the stack location in the TCB. */
668:               			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
669:               
670:               			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
671:               			{
672:               				/* Tasks can be created statically or dynamically, so note this
673:               				task was created statically in case the task is later deleted. */
674:               				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
675:               			}
676:               			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
677:               
678:               			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
679:               									pxTaskDefinition->pcName,
680:               									( uint32_t ) pxTaskDefinition->usStackDepth,
681:               									pxTaskDefinition->pvParameters,
682:               									pxTaskDefinition->uxPriority,
683:               									pxCreatedTask, pxNewTCB,
684:               									pxTaskDefinition->xRegions );
685:               
686:               			prvAddNewTaskToReadyList( pxNewTCB );
687:               			xReturn = pdPASS;
688:               		}
689:               
690:               		return xReturn;
691:               	}
692:               
693:               #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
694:               /*-----------------------------------------------------------*/
695:               
696:               #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
697:               
698:               	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
699:               	{
700:               	TCB_t *pxNewTCB;
701:               	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
702:               
703:               		configASSERT( pxTaskDefinition->puxStackBuffer );
704:               
705:               		if( pxTaskDefinition->puxStackBuffer != NULL )
706:               		{
707:               			/* Allocate space for the TCB.  Where the memory comes from depends
708:               			on the implementation of the port malloc function and whether or
709:               			not static allocation is being used. */
710:               			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
711:               
712:               			if( pxNewTCB != NULL )
713:               			{
714:               				/* Store the stack location in the TCB. */
715:               				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
716:               
717:               				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
718:               				{
719:               					/* Tasks can be created statically or dynamically, so note
720:               					this task had a statically allocated stack in case it is
721:               					later deleted.  The TCB was allocated dynamically. */
722:               					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
723:               				}
724:               				#endif
725:               
726:               				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
727:               										pxTaskDefinition->pcName,
728:               										( uint32_t ) pxTaskDefinition->usStackDepth,
729:               										pxTaskDefinition->pvParameters,
730:               										pxTaskDefinition->uxPriority,
731:               										pxCreatedTask, pxNewTCB,
732:               										pxTaskDefinition->xRegions );
733:               
734:               				prvAddNewTaskToReadyList( pxNewTCB );
735:               				xReturn = pdPASS;
736:               			}
737:               		}
738:               
739:               		return xReturn;
740:               	}
741:               
742:               #endif /* portUSING_MPU_WRAPPERS */
743:               /*-----------------------------------------------------------*/
744:               
745:               #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
746:               
747:               	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
748:               							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
749:               							const configSTACK_DEPTH_TYPE usStackDepth,
750:               							void * const pvParameters,
751:               							UBaseType_t uxPriority,
752:               							TaskHandle_t * const pxCreatedTask )
753:               	{
000CB6  BE9F88     MOV.D W8, [W15++]
000CB8  BE9F8A     MOV.D W10, [W15++]
000CBA  BE9F8C     MOV.D W12, [W15++]
000CBC  781F8E     MOV W14, [W15++]
000CBE  780700     MOV W0, W14
000CC0  780681     MOV W1, W13
000CC2  780482     MOV W2, W9
000CC4  780603     MOV W3, W12
000CC6  780584     MOV W4, W11
000CC8  780505     MOV W5, W10
754:               	TCB_t *pxNewTCB;
755:               	BaseType_t xReturn;
756:               
757:               		/* If the stack grows down then allocate the stack then the TCB so the stack
758:               		does not grow into the TCB.  Likewise if the stack grows up then allocate
759:               		the TCB then the stack. */
760:               		#if( portSTACK_GROWTH > 0 )
761:               		{
762:               			/* Allocate space for the TCB.  Where the memory comes from depends on
763:               			the implementation of the port malloc function and whether or not static
764:               			allocation is being used. */
765:               			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
000CCA  200260     MOV #0x26, W0
000CCC  0228C0     CALL pvPortMalloc
000CCE  000000     NOP
000CD0  780400     MOV W0, W8
766:               
767:               			if( pxNewTCB != NULL )
000CD4  E00008     CP0 W8
000CD6  32000A     BRA Z, .L77
768:               			{
769:               				/* Allocate space for the stack used by the task being created.
770:               				The base of the stack memory stored in the TCB so the task can
771:               				be deleted later if required. */
772:               				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000CD8  448009     ADD W9, W9, W0
000CDA  0228C0     CALL pvPortMalloc
000CDC  000000     NOP
000CDE  980C40     MOV W0, [W8+24]
773:               
774:               				if( pxNewTCB->pxStack == NULL )
000CE0  E00000     CP0 W0
000CE2  3A0009     BRA NZ, .L78
775:               				{
776:               					/* Could not allocate the stack.  Delete the allocated TCB. */
777:               					vPortFree( pxNewTCB );
000CE4  780008     MOV W8, W0
000CE6  0228FA     CALL vPortFree
000CE8  000000     NOP
778:               					pxNewTCB = NULL;
779:               				}
780:               			}
781:               		}
782:               		#else /* portSTACK_GROWTH */
783:               		{
784:               		StackType_t *pxStack;
785:               
786:               			/* Allocate space for the stack used by the task being created. */
787:               			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
788:               
789:               			if( pxStack != NULL )
790:               			{
791:               				/* Allocate space for the TCB. */
792:               				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
793:               
794:               				if( pxNewTCB != NULL )
795:               				{
796:               					/* Store the stack location in the TCB. */
797:               					pxNewTCB->pxStack = pxStack;
798:               				}
799:               				else
800:               				{
801:               					/* The stack cannot be used as the TCB was not created.  Free
802:               					it again. */
803:               					vPortFree( pxStack );
804:               				}
805:               			}
806:               			else
807:               			{
808:               				pxNewTCB = NULL;
809:               			}
810:               		}
811:               		#endif /* portSTACK_GROWTH */
812:               
813:               		if( pxNewTCB != NULL )
814:               		{
815:               			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
816:               			{
817:               				/* Tasks can be created statically or dynamically, so note this
818:               				task was created dynamically in case it is later deleted. */
819:               				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
820:               			}
821:               			#endif /* configSUPPORT_STATIC_ALLOCATION */
822:               
823:               			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
000CF6  B84961     MUL.UU W9, #1, W2
000CF8  EB1F80     CLR [W15++]
000CFA  780388     MOV W8, W7
000CFC  78030A     MOV W10, W6
000CFE  78028B     MOV W11, W5
000D00  78020C     MOV W12, W4
000D02  78008D     MOV W13, W1
000D04  78000E     MOV W14, W0
000D06  07FDCC     RCALL prvInitialiseNewTask
824:               			prvAddNewTaskToReadyList( pxNewTCB );
000D08  780008     MOV W8, W0
000D0A  07FFA7     RCALL prvAddNewTaskToReadyList
000D0C  E9878F     DEC2 W15, W15
825:               			xReturn = pdPASS;
000D0E  200010     MOV #0x1, W0
000D10  37FFED     BRA .L77
826:               		}
827:               		else
828:               		{
829:               			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000CD2  EB8000     SETM W0
000CEA  EB8000     SETM W0
830:               		}
831:               
832:               		return xReturn;
833:               	}
000CEC  78074F     MOV [--W15], W14
000CEE  BE064F     MOV.D [--W15], W12
000CF0  BE054F     MOV.D [--W15], W10
000CF2  BE044F     MOV.D [--W15], W8
000CF4  060000     RETURN
000CF6  B84961     MUL.UU W9, #1, W2
000CF8  EB1F80     CLR [W15++]
000CFA  780388     MOV W8, W7
000CFC  78030A     MOV W10, W6
000CFE  78028B     MOV W11, W5
000D00  78020C     MOV W12, W4
000D02  78008D     MOV W13, W1
000D04  78000E     MOV W14, W0
000D06  07FDCC     RCALL prvInitialiseNewTask
000D08  780008     MOV W8, W0
000D0A  07FFA7     RCALL prvAddNewTaskToReadyList
000D0C  E9878F     DEC2 W15, W15
000D0E  200010     MOV #0x1, W0
000D10  37FFED     BRA .L77
834:               
835:               #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
836:               /*-----------------------------------------------------------*/
837:               
838:               static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
0008D4  44007A     ADD W8, #0x1A, W0
0008D6  4500E3     ADD W10, #0x3, W1
839:               									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
840:               									const uint32_t ulStackDepth,
841:               									void * const pvParameters,
842:               									UBaseType_t uxPriority,
843:               									TaskHandle_t * const pxCreatedTask,
844:               									TCB_t *pxNewTCB,
845:               									const MemoryRegion_t * const xRegions )
846:               {
0008A0  4787E4     ADD W15, #0x4, W15
0008A2  BE9F88     MOV.D W8, [W15++]
0008A4  BE9F8A     MOV.D W10, [W15++]
0008A6  BE9F8C     MOV.D W12, [W15++]
0008A8  781F8E     MOV W14, [W15++]
0008AA  9FBF80     MOV W0, [W15-16]
0008AC  780501     MOV W1, W10
0008AE  780704     MOV W4, W14
0008B0  780685     MOV W5, W13
0008B2  780606     MOV W6, W12
0008B4  780407     MOV W7, W8
847:               StackType_t *pxTopOfStack;
848:               UBaseType_t x;
849:               
850:               	#if( portUSING_MPU_WRAPPERS == 1 )
851:               		/* Should the task be created in privileged mode? */
852:               		BaseType_t xRunPrivileged;
853:               		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
854:               		{
855:               			xRunPrivileged = pdTRUE;
856:               		}
857:               		else
858:               		{
859:               			xRunPrivileged = pdFALSE;
860:               		}
861:               		uxPriority &= ~portPRIVILEGE_BIT;
862:               	#endif /* portUSING_MPU_WRAPPERS == 1 */
863:               
864:               	configASSERT( pcName );
865:               
866:               	/* Avoid dependency on memset() if it is not required. */
867:               	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
868:               	{
869:               		/* Fill the stack with a known value to assist debugging. */
870:               		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
0008B6  780482     MOV W2, W9
0008B8  448109     ADD W9, W9, W2
0008BA  900848     MOV [W8+24], W0
0008BC  200A51     MOV #0xA5, W1
0008BE  0207DA     CALL _memset
0008C0  000000     NOP
871:               	}
872:               	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
873:               
874:               	/* Calculate the top of stack address.  This depends on whether the stack
875:               	grows from high memory to low (as per the 80x86) or vice versa.
876:               	portSTACK_GROWTH is used to make the result positive or negative as required
877:               	by the port. */
878:               	#if( portSTACK_GROWTH < 0 )
879:               	{
880:               		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
881:               		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
882:               
883:               		/* Check the alignment of the calculated top of stack is correct. */
884:               		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
885:               
886:               		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
887:               		{
888:               			/* Also record the stack's high address, which may assist
889:               			debugging. */
890:               			pxNewTCB->pxEndOfStack = pxTopOfStack;
891:               		}
892:               		#endif /* configRECORD_STACK_HIGH_ADDRESS */
893:               	}
894:               	#else /* portSTACK_GROWTH */
895:               	{
896:               		pxTopOfStack = pxNewTCB->pxStack;
0008C2  900DC8     MOV [W8+24], W11
897:               
898:               		/* Check the alignment of the stack buffer is correct. */
899:               		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
900:               
901:               		/* The other extreme of the stack space is required if stack checking is
902:               		performed. */
903:               		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
0008C4  D00489     SL W9, W9
0008C6  E98489     DEC2 W9, W9
0008C8  458489     ADD W11, W9, W9
0008CA  980C79     MOV W9, [W8+30]
904:               	}
905:               	#endif /* portSTACK_GROWTH */
906:               
907:               	/* Store the task name in the TCB. */
908:               	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
0008DE  550F81     SUB W10, W1, [W15]
0008E0  3AFFFB     BRA NZ, .L3
909:               	{
910:               		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
0008CC  78401A     MOV.B [W10], W0
0008CE  985C20     MOV.B W0, [W8+26]
0008D8  78685A     MOV.B [++W10], [++W0]
911:               
912:               		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
913:               		configMAX_TASK_NAME_LEN characters just in case the memory after the
914:               		string is not accessible (extremely unlikely). */
915:               		if( pcName[ x ] == ( char ) 0x00 )
0008D0  E0041A     CP0.B [W10]
0008D2  320007     BRA Z, .L2
0008DA  E0041A     CP0.B [W10]
0008DC  320002     BRA Z, .L2
916:               		{
917:               			break;
918:               		}
919:               		else
920:               		{
921:               			mtCOVERAGE_TEST_MARKER();
922:               		}
923:               	}
924:               
925:               	/* Ensure the name string is terminated in the case that the string length
926:               	was greater or equal to configMAX_TASK_NAME_LEN. */
927:               	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
0008E2  EB4000     CLR.B W0
0008E4  985C50     MOV.B W0, [W8+29]
0008E6  78048D     MOV W13, W9
0008E8  548FE3     SUB W9, #0x3, [W15]
0008EA  360001     BRA LEU, .L4
0008EC  200039     MOV #0x3, W9
928:               
929:               	/* This is used as an array index so must ensure it's not too large.  First
930:               	remove the privilege bit if one is present. */
931:               	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
932:               	{
933:               		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
934:               	}
935:               	else
936:               	{
937:               		mtCOVERAGE_TEST_MARKER();
938:               	}
939:               
940:               	pxNewTCB->uxPriority = uxPriority;
0008EE  980C39     MOV W9, [W8+22]
941:               	#if ( configUSE_MUTEXES == 1 )
942:               	{
943:               		pxNewTCB->uxBasePriority = uxPriority;
944:               		pxNewTCB->uxMutexesHeld = 0;
945:               	}
946:               	#endif /* configUSE_MUTEXES */
947:               
948:               	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
0008F0  E88008     INC2 W8, W0
0008F2  022748     CALL vListInitialiseItem
0008F4  000000     NOP
949:               	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
0008F6  44006C     ADD W8, #0xC, W0
0008F8  022748     CALL vListInitialiseItem
0008FA  000000     NOP
950:               
951:               	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
952:               	back to	the containing TCB from a generic item in a list. */
953:               	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
0008FC  980448     MOV W8, [W8+8]
954:               
955:               	/* Event lists are always in priority order. */
956:               	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0008FE  1484E4     SUBR W9, #0x4, W9
000900  980469     MOV W9, [W8+12]
957:               	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
000902  980C18     MOV W8, [W8+18]
958:               
959:               	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
960:               	{
961:               		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
962:               	}
963:               	#endif /* portCRITICAL_NESTING_IN_TCB */
964:               
965:               	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
966:               	{
967:               		pxNewTCB->pxTaskTag = NULL;
968:               	}
969:               	#endif /* configUSE_APPLICATION_TASK_TAG */
970:               
971:               	#if ( configGENERATE_RUN_TIME_STATS == 1 )
972:               	{
973:               		pxNewTCB->ulRunTimeCounter = 0UL;
974:               	}
975:               	#endif /* configGENERATE_RUN_TIME_STATS */
976:               
977:               	#if ( portUSING_MPU_WRAPPERS == 1 )
978:               	{
979:               		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
980:               	}
981:               	#else
982:               	{
983:               		/* Avoid compiler warning about unreferenced parameter. */
984:               		( void ) xRegions;
985:               	}
986:               	#endif
987:               
988:               	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
989:               	{
990:               		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
991:               		{
992:               			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
993:               		}
994:               	}
995:               	#endif
996:               
997:               	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
998:               	{
999:               		pxNewTCB->ulNotifiedValue = 0;
000904  B80060     MUL.UU W0, #0, W0
000906  981400     MOV W0, [W8+32]
000908  981411     MOV W1, [W8+34]
1000:              		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00090A  EB4000     CLR.B W0
00090C  986440     MOV.B W0, [W8+36]
1001:              	}
1002:              	#endif
1003:              
1004:              	#if ( configUSE_NEWLIB_REENTRANT == 1 )
1005:              	{
1006:              		/* Initialise this task's Newlib reent structure. */
1007:              		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
1008:              	}
1009:              	#endif
1010:              
1011:              	#if( INCLUDE_xTaskAbortDelay == 1 )
1012:              	{
1013:              		pxNewTCB->ucDelayAborted = pdFALSE;
1014:              	}
1015:              	#endif
1016:              
1017:              	/* Initialize the TCB stack to look as if the task was already running,
1018:              	but had been interrupted by the scheduler.  The return address is set
1019:              	to the start of the task function. Once the stack has been initialised
1020:              	the top of stack variable is updated. */
1021:              	#if( portUSING_MPU_WRAPPERS == 1 )
1022:              	{
1023:              		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
1024:              	}
1025:              	#else /* portUSING_MPU_WRAPPERS */
1026:              	{
1027:              		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
00090E  78010E     MOV W14, W2
000910  97B88F     MOV [W15-16], W1
000912  78000B     MOV W11, W0
000914  02256C     CALL pxPortInitialiseStack
000916  000000     NOP
000918  780C00     MOV W0, [W8]
1028:              	}
1029:              	#endif /* portUSING_MPU_WRAPPERS */
1030:              
1031:              	if( pxCreatedTask != NULL )
00091A  E0000C     CP0 W12
00091C  320001     BRA Z, .L1
1032:              	{
1033:              		/* Pass the handle out in an anonymous way.  The handle can be used to
1034:              		change the created task's priority, delete the created task, etc.*/
1035:              		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
00091E  780E08     MOV W8, [W12]
1036:              	}
1037:              	else
1038:              	{
1039:              		mtCOVERAGE_TEST_MARKER();
1040:              	}
1041:              }
000920  78074F     MOV [--W15], W14
000922  BE064F     MOV.D [--W15], W12
000924  BE054F     MOV.D [--W15], W10
000926  BE044F     MOV.D [--W15], W8
000928  B1004F     SUB #0x4, W15
00092A  060000     RETURN
1042:              /*-----------------------------------------------------------*/
1043:              
1044:              static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1045:              {
000C5A  781F88     MOV W8, [W15++]
000C5C  780400     MOV W0, W8
1046:              	/* Ensure interrupts don't access the task lists while the lists are being
1047:              	updated. */
1048:              	taskENTER_CRITICAL();
000C5E  0225F4     CALL vPortEnterCritical
000C60  000000     NOP
1049:              	{
1050:              		uxCurrentNumberOfTasks++;
000C62  EC2854     INC uxCurrentNumberOfTasks
1051:              		if( pxCurrentTCB == NULL )
000C64  E20850     CP0 pxCurrentTCB
000C66  3A0006     BRA NZ, .L72
1052:              		{
1053:              			/* There are no other tasks, or all the other tasks are in
1054:              			the suspended state - make this the current task. */
1055:              			pxCurrentTCB = pxNewTCB;
000C68  884288     MOV W8, pxCurrentTCB
1056:              
1057:              			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
000C6A  8042A0     MOV uxCurrentNumberOfTasks, W0
000C6C  500FE1     SUB W0, #0x1, [W15]
1058:              			{
1059:              				/* This is the first task to be created so do the preliminary
1060:              				initialisation required.  We will not recover if this call
1061:              				fails, but we will report the failure. */
1062:              				prvInitialiseTaskLists();
000C6E  3A000A     BRA NZ, .L73
000C70  07FFD5     RCALL prvInitialiseTaskLists
000C72  370008     BRA .L73
1063:              			}
1064:              			else
1065:              			{
1066:              				mtCOVERAGE_TEST_MARKER();
1067:              			}
1068:              		}
1069:              		else
1070:              		{
1071:              			/* If the scheduler is not already running, make this task the
1072:              			current task if it is the highest priority task to be created
1073:              			so far. */
1074:              			if( xSchedulerRunning == pdFALSE )
000C74  E2085A     CP0 xSchedulerRunning
000C76  3A0006     BRA NZ, .L73
1075:              			{
1076:              				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
000C78  804280     MOV pxCurrentTCB, W0
000C7A  9008B0     MOV [W0+22], W1
000C7C  900838     MOV [W8+22], W0
000C7E  508F80     SUB W1, W0, [W15]
000C80  3E0001     BRA GTU, .L73
1077:              				{
1078:              					pxCurrentTCB = pxNewTCB;
000C82  884288     MOV W8, pxCurrentTCB
1079:              				}
1080:              				else
1081:              				{
1082:              					mtCOVERAGE_TEST_MARKER();
1083:              				}
1084:              			}
1085:              			else
1086:              			{
1087:              				mtCOVERAGE_TEST_MARKER();
1088:              			}
1089:              		}
1090:              
1091:              		uxTaskNumber++;
000C84  EC2862     INC uxTaskNumber
1092:              
1093:              		#if ( configUSE_TRACE_FACILITY == 1 )
1094:              		{
1095:              			/* Add a counter into the TCB for tracing only. */
1096:              			pxNewTCB->uxTCBNumber = uxTaskNumber;
1097:              		}
1098:              		#endif /* configUSE_TRACE_FACILITY */
1099:              		traceTASK_CREATE( pxNewTCB );
1100:              
1101:              		prvAddTaskToReadyList( pxNewTCB );
000C86  900838     MOV [W8+22], W0
000C88  E30858     CP uxTopReadyPriority
000C8A  310001     BRA C, .L74
000C8C  8842C0     MOV W0, uxTopReadyPriority
000C8E  E88088     INC2 W8, W1
000C90  B9016A     MUL.SU W0, #10, W2
000C92  21CAC0     MOV #0x1CAC, W0
000C94  400002     ADD W0, W2, W0
000C96  02274E     CALL vListInsertEnd
000C98  000000     NOP
1102:              
1103:              		portSETUP_TCB( pxNewTCB );
1104:              	}
1105:              	taskEXIT_CRITICAL();
000C9A  022604     CALL vPortExitCritical
000C9C  000000     NOP
1106:              
1107:              	if( xSchedulerRunning != pdFALSE )
000C9E  E2085A     CP0 xSchedulerRunning
000CA0  320008     BRA Z, .L71
1108:              	{
1109:              		/* If the created task is of a higher priority than the current task
1110:              		then it should run now. */
1111:              		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
000CA2  804280     MOV pxCurrentTCB, W0
000CA4  9008B0     MOV [W0+22], W1
000CA6  900838     MOV [W8+22], W0
000CA8  508F80     SUB W1, W0, [W15]
000CAA  310003     BRA C, .L71
1112:              		{
1113:              			taskYIELD_IF_USING_PREEMPTION();
000CAC  02286C     CALL .Letext0, .LFE2, _vPortYield
000CAE  000000     NOP
000CB0  000000     NOP
1114:              		}
1115:              		else
1116:              		{
1117:              			mtCOVERAGE_TEST_MARKER();
1118:              		}
1119:              	}
1120:              	else
1121:              	{
1122:              		mtCOVERAGE_TEST_MARKER();
1123:              	}
1124:              }
000CB2  78044F     MOV [--W15], W8
000CB4  060000     RETURN
1125:              /*-----------------------------------------------------------*/
1126:              
1127:              #if ( INCLUDE_vTaskDelete == 1 )
1128:              
1129:              	void vTaskDelete( TaskHandle_t xTaskToDelete )
1130:              	{
000F3C  BE9F88     MOV.D W8, [W15++]
000F3E  780400     MOV W0, W8
1131:              	TCB_t *pxTCB;
1132:              
1133:              		taskENTER_CRITICAL();
000F40  0225F4     CALL vPortEnterCritical
000F42  000000     NOP
1134:              		{
1135:              			/* If null is passed in here then it is the calling task that is
1136:              			being deleted. */
1137:              			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000F44  E00008     CP0 W8
000F46  3A0001     BRA NZ, .L143
000F48  804288     MOV pxCurrentTCB, W8
1138:              
1139:              			/* Remove task from the ready list. */
1140:              			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000F4A  E88488     INC2 W8, W9
000F4C  780009     MOV W9, W0
000F4E  022788     CALL uxListRemove
000F50  000000     NOP
1141:              			{
1142:              				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1143:              			}
1144:              			else
1145:              			{
1146:              				mtCOVERAGE_TEST_MARKER();
1147:              			}
1148:              
1149:              			/* Is the task waiting on an event also? */
1150:              			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000F52  900828     MOV [W8+20], W0
000F54  E00000     CP0 W0
000F56  320003     BRA Z, .L144
1151:              			{
1152:              				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000F58  44006C     ADD W8, #0xC, W0
000F5A  022788     CALL uxListRemove
000F5C  000000     NOP
1153:              			}
1154:              			else
1155:              			{
1156:              				mtCOVERAGE_TEST_MARKER();
1157:              			}
1158:              
1159:              			/* Increment the uxTaskNumber also so kernel aware debuggers can
1160:              			detect that the task lists need re-generating.  This is done before
1161:              			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1162:              			not return. */
1163:              			uxTaskNumber++;
000F5E  EC2862     INC uxTaskNumber
1164:              
1165:              			if( pxTCB == pxCurrentTCB )
000F60  804280     MOV pxCurrentTCB, W0
000F62  500F88     SUB W0, W8, [W15]
000F64  3A0006     BRA NZ, .L145
1166:              			{
1167:              				/* A task is deleting itself.  This cannot complete within the
1168:              				task itself, as a context switch to another task is required.
1169:              				Place the task in the termination list.  The idle task will
1170:              				check the termination list and free up any memory allocated by
1171:              				the scheduler for the TCB and stack of the deleted task. */
1172:              				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
000F66  780089     MOV W9, W1
000F68  21CF20     MOV #0x1CF2, W0
000F6A  02274E     CALL vListInsertEnd
000F6C  000000     NOP
1173:              
1174:              				/* Increment the ucTasksDeleted variable so the idle task knows
1175:              				there is a task that has been deleted and that it should therefore
1176:              				check the xTasksWaitingTermination list. */
1177:              				++uxDeletedTasksWaitingCleanUp;
000F6E  EC2852     INC uxDeletedTasksWaitingCleanUp
000F70  370004     BRA .L146
1178:              
1179:              				/* The pre-delete hook is primarily for the Windows simulator,
1180:              				in which Windows specific clean up operations are performed,
1181:              				after which it is not possible to yield away from this task -
1182:              				hence xYieldPending is used to latch that a context switch is
1183:              				required. */
1184:              				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1185:              			}
1186:              			else
1187:              			{
1188:              				--uxCurrentNumberOfTasks;
000F72  ED2854     DEC uxCurrentNumberOfTasks
1189:              				prvDeleteTCB( pxTCB );
000F74  780008     MOV W8, W0
1190:              
1191:              				/* Reset the next expected unblock time in case it referred to
1192:              				the task that has just been deleted. */
1193:              				prvResetNextTaskUnblockTime();
000F76  07FEE3     RCALL prvDeleteTCB
000F78  07FF0C     RCALL prvResetNextTaskUnblockTime
1194:              			}
1195:              
1196:              			traceTASK_DELETE( pxTCB );
1197:              		}
1198:              		taskEXIT_CRITICAL();
000F7A  022604     CALL vPortExitCritical
000F7C  000000     NOP
1199:              
1200:              		/* Force a reschedule if it is the currently running task that has just
1201:              		been deleted. */
1202:              		if( xSchedulerRunning != pdFALSE )
000F7E  E2085A     CP0 xSchedulerRunning
000F80  320006     BRA Z, .L142
1203:              		{
1204:              			if( pxTCB == pxCurrentTCB )
000F82  804280     MOV pxCurrentTCB, W0
000F84  500F88     SUB W0, W8, [W15]
000F86  3A0003     BRA NZ, .L142
1205:              			{
1206:              				configASSERT( uxSchedulerSuspended == 0 );
1207:              				portYIELD_WITHIN_API();
000F88  02286C     CALL .Letext0, .LFE2, _vPortYield
000F8A  000000     NOP
000F8C  000000     NOP
1208:              			}
1209:              			else
1210:              			{
1211:              				mtCOVERAGE_TEST_MARKER();
1212:              			}
1213:              		}
1214:              	}
000F8E  BE044F     MOV.D [--W15], W8
000F90  060000     RETURN
1215:              
1216:              #endif /* INCLUDE_vTaskDelete */
1217:              /*-----------------------------------------------------------*/
1218:              
1219:              #if ( INCLUDE_vTaskDelayUntil == 1 )
1220:              
1221:              	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1222:              	{
001326  BE9F88     MOV.D W8, [W15++]
1223:              	TickType_t xTimeToWake;
1224:              	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1225:              
1226:              		configASSERT( pxPreviousWakeTime );
1227:              		configASSERT( ( xTimeIncrement > 0U ) );
1228:              		configASSERT( uxSchedulerSuspended == 0 );
1229:              
1230:              		vTaskSuspendAll();
001328  BE0400     MOV.D W0, W8
00132A  07FBAD     RCALL vTaskSuspendAll
1231:              		{
1232:              			/* Minor optimisation.  The tick count cannot change in this
1233:              			block. */
1234:              			const TickType_t xConstTickCount = xTickCount;
00132C  8042B0     MOV xTickCount, W0
1235:              
1236:              			/* Generate the tick time at which the task wants to wake. */
1237:              			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
00132E  780098     MOV [W8], W1
001330  448481     ADD W9, W1, W9
1238:              
1239:              			if( xConstTickCount < *pxPreviousWakeTime )
001332  500F81     SUB W0, W1, [W15]
001334  310006     BRA C, .L213
1240:              			{
1241:              				/* The tick count has overflowed since this function was
1242:              				lasted called.  In this case the only time we should ever
1243:              				actually delay is if the wake time has also	overflowed,
1244:              				and the wake time is greater than the tick time.  When this
1245:              				is the case it is as if neither time had overflowed. */
1246:              				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
001336  508F89     SUB W1, W9, [W15]
001338  360015     BRA LEU, .L214
1247:              				{
1248:              					xShouldDelay = pdTRUE;
1249:              				}
1250:              				else
1251:              				{
1252:              					mtCOVERAGE_TEST_MARKER();
1253:              				}
1254:              			}
1255:              			else
1256:              			{
1257:              				/* The tick time has not overflowed.  In this case we will
1258:              				delay if either the wake time has overflowed, and/or the
1259:              				tick time is less than the wake time. */
1260:              				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
001342  508F89     SUB W1, W9, [W15]
001344  3E000D     BRA GTU, .L217
001346  500F89     SUB W0, W9, [W15]
001348  39000B     BRA NC, .L217
00134A  37000C     BRA .L214
1261:              				{
1262:              					xShouldDelay = pdTRUE;
1263:              				}
1264:              				else
1265:              				{
1266:              					mtCOVERAGE_TEST_MARKER();
1267:              				}
1268:              			}
1269:              
1270:              			/* Update the wake time ready for the next call. */
1271:              			*pxPreviousWakeTime = xTimeToWake;
00133A  780C09     MOV W9, [W8]
001360  780C09     MOV W9, [W8]
001362  37FFF4     BRA .L215
001364  780C09     MOV W9, [W8]
001366  37FFF5     BRA .L216, .LBE12
1272:              
1273:              			if( xShouldDelay != pdFALSE )
00133C  500F89     SUB W0, W9, [W15]
00133E  310009     BRA C, .L216, .LBE12
001340  370005     BRA .L215
1274:              			{
1275:              				traceTASK_DELAY_UNTIL( xTimeToWake );
1276:              
1277:              				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1278:              				the time to wake, so subtract the current tick count. */
1279:              				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
00134C  548000     SUB W9, W0, W0
00134E  EB0080     CLR W1
1280:              			}
1281:              			else
1282:              			{
1283:              				mtCOVERAGE_TEST_MARKER();
1284:              			}
1285:              		}
1286:              		xAlreadyYielded = xTaskResumeAll();
001350  07FF13     RCALL prvAddCurrentTaskToDelayedList
001352  07FD7C     RCALL xTaskResumeAll
1287:              
1288:              		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1289:              		have put ourselves to sleep. */
1290:              		if( xAlreadyYielded == pdFALSE )
001354  E00000     CP0 W0
001356  3A0008     BRA NZ, .L212
1291:              		{
1292:              			portYIELD_WITHIN_API();
001358  02286C     CALL .Letext0, .LFE2, _vPortYield
00135A  000000     NOP
00135C  000000     NOP
00135E  370004     BRA .L212
1293:              		}
1294:              		else
1295:              		{
1296:              			mtCOVERAGE_TEST_MARKER();
1297:              		}
1298:              	}
001368  BE044F     MOV.D [--W15], W8
00136A  060000     RETURN
1299:              
1300:              #endif /* INCLUDE_vTaskDelayUntil */
1301:              /*-----------------------------------------------------------*/
1302:              
1303:              #if ( INCLUDE_vTaskDelay == 1 )
1304:              
1305:              	void vTaskDelay( const TickType_t xTicksToDelay )
1306:              	{
001306  781F88     MOV W8, [W15++]
001308  780400     MOV W0, W8
1307:              	BaseType_t xAlreadyYielded = pdFALSE;
1308:              
1309:              		/* A delay time of zero just forces a reschedule. */
1310:              		if( xTicksToDelay > ( TickType_t ) 0U )
00130A  E00008     CP0 W8
1311:              		{
1312:              			configASSERT( uxSchedulerSuspended == 0 );
1313:              			vTaskSuspendAll();
00130C  320007     BRA Z, .L210
00130E  07FBBB     RCALL vTaskSuspendAll
1314:              			{
1315:              				traceTASK_DELAY();
1316:              
1317:              				/* A task that is removed from the event list while the
1318:              				scheduler is suspended will not get placed in the ready
1319:              				list or removed from the blocked list until the scheduler
1320:              				is resumed.
1321:              
1322:              				This task cannot be in an event list as it is the currently
1323:              				executing task. */
1324:              				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
001310  EB0080     CLR W1
001312  780008     MOV W8, W0
1325:              			}
1326:              			xAlreadyYielded = xTaskResumeAll();
001314  07FF31     RCALL prvAddCurrentTaskToDelayedList
001316  07FD9A     RCALL xTaskResumeAll
1327:              		}
1328:              		else
1329:              		{
1330:              			mtCOVERAGE_TEST_MARKER();
1331:              		}
1332:              
1333:              		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1334:              		have put ourselves to sleep. */
1335:              		if( xAlreadyYielded == pdFALSE )
001318  E00000     CP0 W0
00131A  3A0003     BRA NZ, .L209
1336:              		{
1337:              			portYIELD_WITHIN_API();
00131C  02286C     CALL .Letext0, .LFE2, _vPortYield
00131E  000000     NOP
001320  000000     NOP
1338:              		}
1339:              		else
1340:              		{
1341:              			mtCOVERAGE_TEST_MARKER();
1342:              		}
1343:              	}
001322  78044F     MOV [--W15], W8
001324  060000     RETURN
1344:              
1345:              #endif /* INCLUDE_vTaskDelay */
1346:              /*-----------------------------------------------------------*/
1347:              
1348:              #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1349:              
1350:              	eTaskState eTaskGetState( TaskHandle_t xTask )
1351:              	{
1352:              	eTaskState eReturn;
1353:              	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
1354:              	const TCB_t * const pxTCB = xTask;
1355:              
1356:              		configASSERT( pxTCB );
1357:              
1358:              		if( pxTCB == pxCurrentTCB )
1359:              		{
1360:              			/* The task calling this function is querying its own state. */
1361:              			eReturn = eRunning;
1362:              		}
1363:              		else
1364:              		{
1365:              			taskENTER_CRITICAL();
1366:              			{
1367:              				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1368:              				pxDelayedList = pxDelayedTaskList;
1369:              				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
1370:              			}
1371:              			taskEXIT_CRITICAL();
1372:              
1373:              			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
1374:              			{
1375:              				/* The task being queried is referenced from one of the Blocked
1376:              				lists. */
1377:              				eReturn = eBlocked;
1378:              			}
1379:              
1380:              			#if ( INCLUDE_vTaskSuspend == 1 )
1381:              				else if( pxStateList == &xSuspendedTaskList )
1382:              				{
1383:              					/* The task being queried is referenced from the suspended
1384:              					list.  Is it genuinely suspended or is it blocked
1385:              					indefinitely? */
1386:              					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1387:              					{
1388:              						#if( configUSE_TASK_NOTIFICATIONS == 1 )
1389:              						{
1390:              							/* The task does not appear on the event list item of
1391:              							and of the RTOS objects, but could still be in the
1392:              							blocked state if it is waiting on its notification
1393:              							rather than waiting on an object. */
1394:              							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1395:              							{
1396:              								eReturn = eBlocked;
1397:              							}
1398:              							else
1399:              							{
1400:              								eReturn = eSuspended;
1401:              							}
1402:              						}
1403:              						#else
1404:              						{
1405:              							eReturn = eSuspended;
1406:              						}
1407:              						#endif
1408:              					}
1409:              					else
1410:              					{
1411:              						eReturn = eBlocked;
1412:              					}
1413:              				}
1414:              			#endif
1415:              
1416:              			#if ( INCLUDE_vTaskDelete == 1 )
1417:              				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1418:              				{
1419:              					/* The task being queried is referenced from the deleted
1420:              					tasks list, or it is not referenced from any lists at
1421:              					all. */
1422:              					eReturn = eDeleted;
1423:              				}
1424:              			#endif
1425:              
1426:              			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1427:              			{
1428:              				/* If the task is not in any other state, it must be in the
1429:              				Ready (including pending ready) state. */
1430:              				eReturn = eReady;
1431:              			}
1432:              		}
1433:              
1434:              		return eReturn;
1435:              	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1436:              
1437:              #endif /* INCLUDE_eTaskGetState */
1438:              /*-----------------------------------------------------------*/
1439:              
1440:              #if ( INCLUDE_uxTaskPriorityGet == 1 )
1441:              
1442:              	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1443:              	{
1444:              	TCB_t const *pxTCB;
1445:              	UBaseType_t uxReturn;
1446:              
1447:              		taskENTER_CRITICAL();
1448:              		{
1449:              			/* If null is passed in here then it is the priority of the task
1450:              			that called uxTaskPriorityGet() that is being queried. */
1451:              			pxTCB = prvGetTCBFromHandle( xTask );
1452:              			uxReturn = pxTCB->uxPriority;
1453:              		}
1454:              		taskEXIT_CRITICAL();
1455:              
1456:              		return uxReturn;
1457:              	}
1458:              
1459:              #endif /* INCLUDE_uxTaskPriorityGet */
1460:              /*-----------------------------------------------------------*/
1461:              
1462:              #if ( INCLUDE_uxTaskPriorityGet == 1 )
1463:              
1464:              	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1465:              	{
1466:              	TCB_t const *pxTCB;
1467:              	UBaseType_t uxReturn, uxSavedInterruptState;
1468:              
1469:              		/* RTOS ports that support interrupt nesting have the concept of a
1470:              		maximum	system call (or maximum API call) interrupt priority.
1471:              		Interrupts that are	above the maximum system call priority are keep
1472:              		permanently enabled, even when the RTOS kernel is in a critical section,
1473:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1474:              		is defined in FreeRTOSConfig.h then
1475:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1476:              		failure if a FreeRTOS API function is called from an interrupt that has
1477:              		been assigned a priority above the configured maximum system call
1478:              		priority.  Only FreeRTOS functions that end in FromISR can be called
1479:              		from interrupts	that have been assigned a priority at or (logically)
1480:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
1481:              		separate interrupt safe API to ensure interrupt entry is as fast and as
1482:              		simple as possible.  More information (albeit Cortex-M specific) is
1483:              		provided on the following link:
1484:              		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1485:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1486:              
1487:              		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1488:              		{
1489:              			/* If null is passed in here then it is the priority of the calling
1490:              			task that is being queried. */
1491:              			pxTCB = prvGetTCBFromHandle( xTask );
1492:              			uxReturn = pxTCB->uxPriority;
1493:              		}
1494:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1495:              
1496:              		return uxReturn;
1497:              	}
1498:              
1499:              #endif /* INCLUDE_uxTaskPriorityGet */
1500:              /*-----------------------------------------------------------*/
1501:              
1502:              #if ( INCLUDE_vTaskPrioritySet == 1 )
1503:              
1504:              	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1505:              	{
00092C  BE9F88     MOV.D W8, [W15++]
00092E  781F8A     MOV W10, [W15++]
000930  BE0400     MOV.D W0, W8
1506:              	TCB_t *pxTCB;
1507:              	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1508:              	BaseType_t xYieldRequired = pdFALSE;
000932  548FE3     SUB W9, #0x3, [W15]
000934  360001     BRA LEU, .L8
000936  200039     MOV #0x3, W9
00094A  EB0500     CLR W10
1509:              
1510:              		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1511:              
1512:              		/* Ensure the new priority is valid. */
1513:              		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1514:              		{
1515:              			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1516:              		}
1517:              		else
1518:              		{
1519:              			mtCOVERAGE_TEST_MARKER();
1520:              		}
1521:              
1522:              		taskENTER_CRITICAL();
000938  0225F4     CALL vPortEnterCritical
00093A  000000     NOP
1523:              		{
1524:              			/* If null is passed in here then it is the priority of the calling
1525:              			task that is being changed. */
1526:              			pxTCB = prvGetTCBFromHandle( xTask );
00093C  E00008     CP0 W8
00093E  3A0001     BRA NZ, .L9
000940  804288     MOV pxCurrentTCB, W8
1527:              
1528:              			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1529:              
1530:              			#if ( configUSE_MUTEXES == 1 )
1531:              			{
1532:              				uxCurrentBasePriority = pxTCB->uxBasePriority;
1533:              			}
1534:              			#else
1535:              			{
1536:              				uxCurrentBasePriority = pxTCB->uxPriority;
000942  900838     MOV [W8+22], W0
1537:              			}
1538:              			#endif
1539:              
1540:              			if( uxCurrentBasePriority != uxNewPriority )
000944  500F89     SUB W0, W9, [W15]
000946  320031     BRA Z, .L10
1541:              			{
1542:              				/* The priority change may have readied a task of higher
1543:              				priority than the calling task. */
1544:              				if( uxNewPriority > uxCurrentBasePriority )
000948  31000B     BRA C, .L11
1545:              				{
1546:              					if( pxTCB != pxCurrentTCB )
00094C  804281     MOV pxCurrentTCB, W1
00094E  508F88     SUB W1, W8, [W15]
000950  32000D     BRA Z, .L12
1547:              					{
1548:              						/* The priority of a task other than the currently
1549:              						running task is being raised.  Is the priority being
1550:              						raised above that of the running task? */
1551:              						if( uxNewPriority >= pxCurrentTCB->uxPriority )
000952  804281     MOV pxCurrentTCB, W1
1552:              						{
1553:              							xYieldRequired = pdTRUE;
000954  20001A     MOV #0x1, W10
000956  9008B1     MOV [W1+22], W1
000958  508F89     SUB W1, W9, [W15]
00095A  360008     BRA LEU, .L12
00095C  EB0500     CLR W10
00095E  370006     BRA .L12
000960  804281     MOV pxCurrentTCB, W1
000962  688508     XOR W1, W8, W10
000964  A7F00A     BTSC W10, #15
000966  EA050A     NEG W10, W10
000968  E9050A     DEC W10, W10
00096A  DE554F     LSR W10, #15, W10
1554:              						}
1555:              						else
1556:              						{
1557:              							mtCOVERAGE_TEST_MARKER();
1558:              						}
1559:              					}
1560:              					else
1561:              					{
1562:              						/* The priority of the running task is being raised,
1563:              						but the running task must already be the highest
1564:              						priority task able to run so no yield is required. */
1565:              					}
1566:              				}
1567:              				else if( pxTCB == pxCurrentTCB )
1568:              				{
1569:              					/* Setting the priority of the running task down means
1570:              					there may now be another task of higher priority that
1571:              					is ready to execute. */
1572:              					xYieldRequired = pdTRUE;
1573:              				}
1574:              				else
1575:              				{
1576:              					/* Setting the priority of any other task down does not
1577:              					require a yield as the running task must be above the
1578:              					new priority of the task being modified. */
1579:              				}
1580:              
1581:              				/* Remember the ready list the task might be referenced from
1582:              				before its uxPriority member is changed so the
1583:              				taskRESET_READY_PRIORITY() macro can function correctly. */
1584:              				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1585:              
1586:              				#if ( configUSE_MUTEXES == 1 )
1587:              				{
1588:              					/* Only change the priority being used if the task is not
1589:              					currently using an inherited priority. */
1590:              					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1591:              					{
1592:              						pxTCB->uxPriority = uxNewPriority;
1593:              					}
1594:              					else
1595:              					{
1596:              						mtCOVERAGE_TEST_MARKER();
1597:              					}
1598:              
1599:              					/* The base priority gets set whatever. */
1600:              					pxTCB->uxBasePriority = uxNewPriority;
1601:              				}
1602:              				#else
1603:              				{
1604:              					pxTCB->uxPriority = uxNewPriority;
00096C  980C39     MOV W9, [W8+22]
1605:              				}
1606:              				#endif
1607:              
1608:              				/* Only reset the event list item value if the value is not
1609:              				being used for anything else. */
1610:              				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
00096E  9000E8     MOV [W8+12], W1
000970  E00001     CP0 W1
000972  350002     BRA LT, .L14
1611:              				{
1612:              					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000974  1484E4     SUBR W9, #0x4, W9
000976  980469     MOV W9, [W8+12]
1613:              				}
1614:              				else
1615:              				{
1616:              					mtCOVERAGE_TEST_MARKER();
1617:              				}
1618:              
1619:              				/* If the task is in the blocked or suspended list we need do
1620:              				nothing more than change its priority variable. However, if
1621:              				the task is in a ready list it needs to be removed and placed
1622:              				in the list appropriate to its new priority. */
1623:              				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000978  B9006A     MUL.SU W0, #10, W0
00097A  21CAC2     MOV #0x1CAC, W2
00097C  410000     ADD W2, W0, W0
00097E  9000D8     MOV [W8+10], W1
000980  508F80     SUB W1, W0, [W15]
000982  3A000E     BRA NZ, .L15
1624:              				{
1625:              					/* The task is currently in its ready list - remove before
1626:              					adding it to it's new ready list.  As we are in a critical
1627:              					section we can do this even if the scheduler is suspended. */
1628:              					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000984  E88488     INC2 W8, W9
000986  780009     MOV W9, W0
000988  022788     CALL uxListRemove
00098A  000000     NOP
1629:              					{
1630:              						/* It is known that the task is in its ready list so
1631:              						there is no need to check again and the port level
1632:              						reset macro can be called directly. */
1633:              						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1634:              					}
1635:              					else
1636:              					{
1637:              						mtCOVERAGE_TEST_MARKER();
1638:              					}
1639:              					prvAddTaskToReadyList( pxTCB );
00098C  900838     MOV [W8+22], W0
00098E  E30858     CP uxTopReadyPriority
000990  310001     BRA C, .L16
000992  8842C0     MOV W0, uxTopReadyPriority
000994  B9006A     MUL.SU W0, #10, W0
000996  21CAC2     MOV #0x1CAC, W2
000998  410000     ADD W2, W0, W0
00099A  780089     MOV W9, W1
00099C  02274E     CALL vListInsertEnd
00099E  000000     NOP
1640:              				}
1641:              				else
1642:              				{
1643:              					mtCOVERAGE_TEST_MARKER();
1644:              				}
1645:              
1646:              				if( xYieldRequired != pdFALSE )
0009A0  E0000A     CP0 W10
0009A2  320003     BRA Z, .L10
1647:              				{
1648:              					taskYIELD_IF_USING_PREEMPTION();
0009A4  02286C     CALL .Letext0, .LFE2, _vPortYield
0009A6  000000     NOP
0009A8  000000     NOP
1649:              				}
1650:              				else
1651:              				{
1652:              					mtCOVERAGE_TEST_MARKER();
1653:              				}
1654:              
1655:              				/* Remove compiler warning about unused variables when the port
1656:              				optimised task selection is not being used. */
1657:              				( void ) uxPriorityUsedOnEntry;
1658:              			}
1659:              		}
1660:              		taskEXIT_CRITICAL();
0009AA  022604     CALL vPortExitCritical
0009AC  000000     NOP
1661:              	}
0009AE  78054F     MOV [--W15], W10
0009B0  BE044F     MOV.D [--W15], W8
0009B2  060000     RETURN
1662:              
1663:              #endif /* INCLUDE_vTaskPrioritySet */
1664:              /*-----------------------------------------------------------*/
1665:              
1666:              #if ( INCLUDE_vTaskSuspend == 1 )
1667:              
1668:              	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1669:              	{
000ED4  BE9F88     MOV.D W8, [W15++]
000ED6  780400     MOV W0, W8
1670:              	TCB_t *pxTCB;
1671:              
1672:              		taskENTER_CRITICAL();
000ED8  0225F4     CALL vPortEnterCritical
000EDA  000000     NOP
1673:              		{
1674:              			/* If null is passed in here then it is the running task that is
1675:              			being suspended. */
1676:              			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000EDC  E00008     CP0 W8
000EDE  3A0001     BRA NZ, .L134
000EE0  804288     MOV pxCurrentTCB, W8
1677:              
1678:              			traceTASK_SUSPEND( pxTCB );
1679:              
1680:              			/* Remove task from the ready/delayed list and place in the
1681:              			suspended list. */
1682:              			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000EE2  E88488     INC2 W8, W9
000EE4  780009     MOV W9, W0
000EE6  022788     CALL uxListRemove
000EE8  000000     NOP
1683:              			{
1684:              				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1685:              			}
1686:              			else
1687:              			{
1688:              				mtCOVERAGE_TEST_MARKER();
1689:              			}
1690:              
1691:              			/* Is the task waiting on an event also? */
1692:              			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000EEA  900828     MOV [W8+20], W0
000EEC  E00000     CP0 W0
000EEE  320003     BRA Z, .L135
1693:              			{
1694:              				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000EF0  44006C     ADD W8, #0xC, W0
000EF2  022788     CALL uxListRemove
000EF4  000000     NOP
1695:              			}
1696:              			else
1697:              			{
1698:              				mtCOVERAGE_TEST_MARKER();
1699:              			}
1700:              
1701:              			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
000EF6  780089     MOV W9, W1
000EF8  21CFC0     MOV #0x1CFC, W0
000EFA  02274E     CALL vListInsertEnd
000EFC  000000     NOP
1702:              
1703:              			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1704:              			{
1705:              				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
000EFE  906048     MOV.B [W8+36], W0
000F00  504FE1     SUB.B W0, #0x1, [W15]
000F02  3A0002     BRA NZ, .L136
1706:              				{
1707:              					/* The task was blocked to wait for a notification, but is
1708:              					now suspended, so no notification was received. */
1709:              					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000F04  EB4000     CLR.B W0
000F06  986440     MOV.B W0, [W8+36]
1710:              				}
1711:              			}
1712:              			#endif
1713:              		}
1714:              		taskEXIT_CRITICAL();
000F08  022604     CALL vPortExitCritical
000F0A  000000     NOP
1715:              
1716:              		if( xSchedulerRunning != pdFALSE )
000F0C  E2085A     CP0 xSchedulerRunning
000F0E  320005     BRA Z, .L137
1717:              		{
1718:              			/* Reset the next expected unblock time in case it referred to the
1719:              			task that is now in the Suspended state. */
1720:              			taskENTER_CRITICAL();
000F10  0225F4     CALL vPortEnterCritical
1721:              			{
1722:              				prvResetNextTaskUnblockTime();
000F12  000000     NOP
000F14  07FF3E     RCALL prvResetNextTaskUnblockTime
1723:              			}
1724:              			taskEXIT_CRITICAL();
000F16  022604     CALL vPortExitCritical
000F18  000000     NOP
1725:              		}
1726:              		else
1727:              		{
1728:              			mtCOVERAGE_TEST_MARKER();
1729:              		}
1730:              
1731:              		if( pxTCB == pxCurrentTCB )
000F1A  804280     MOV pxCurrentTCB, W0
000F1C  500F88     SUB W0, W8, [W15]
000F1E  3A000C     BRA NZ, .L133
1732:              		{
1733:              			if( xSchedulerRunning != pdFALSE )
000F20  E2085A     CP0 xSchedulerRunning
000F22  320004     BRA Z, .L139
1734:              			{
1735:              				/* The current task has just been suspended. */
1736:              				configASSERT( uxSchedulerSuspended == 0 );
1737:              				portYIELD_WITHIN_API();
000F24  02286C     CALL .Letext0, .LFE2, _vPortYield
000F26  000000     NOP
000F28  000000     NOP
000F2A  370006     BRA .L133
1738:              			}
1739:              			else
1740:              			{
1741:              				/* The scheduler is not running, but the task that was pointed
1742:              				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1743:              				must be adjusted to point to a different task. */
1744:              				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
000F2C  80E7E0     MOV xSuspendedTaskList, W0
000F2E  E30854     CP uxCurrentNumberOfTasks
000F30  3A0002     BRA NZ, .L140
1745:              				{
1746:              					/* No other tasks are ready, so set pxCurrentTCB back to
1747:              					NULL so when the next task is created pxCurrentTCB will
1748:              					be set to point to it no matter what its relative priority
1749:              					is. */
1750:              					pxCurrentTCB = NULL;
000F32  EF2850     CLR pxCurrentTCB
1751:              				}
1752:              				else
1753:              				{
1754:              					vTaskSwitchContext();
000F34  370001     BRA .L133
000F36  07FDBB     RCALL vTaskSwitchContext
1755:              				}
1756:              			}
1757:              		}
1758:              		else
1759:              		{
1760:              			mtCOVERAGE_TEST_MARKER();
1761:              		}
1762:              	}
000F38  BE044F     MOV.D [--W15], W8
000F3A  060000     RETURN
1763:              
1764:              #endif /* INCLUDE_vTaskSuspend */
1765:              /*-----------------------------------------------------------*/
1766:              
1767:              #if ( INCLUDE_vTaskSuspend == 1 )
1768:              
1769:              	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1770:              	{
0009B4  780080     MOV W0, W1
1771:              	BaseType_t xReturn = pdFALSE;
0009B8  EB0000     CLR W0
0009C8  A7F001     BTSC W1, #15
0009CA  EA0081     NEG W1, W1
0009CC  E90001     DEC W1, W0
0009CE  DE004F     LSR W0, #15, W0
1772:              	const TCB_t * const pxTCB = xTask;
1773:              
1774:              		/* Accesses xPendingReadyList so must be called from a critical
1775:              		section. */
1776:              
1777:              		/* It does not make sense to check if the calling task is suspended. */
1778:              		configASSERT( xTask );
1779:              
1780:              		/* Is the task being resumed actually in the suspended list? */
1781:              		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
0009B6  9001D1     MOV [W1+10], W3
0009BA  21CFC2     MOV #0x1CFC, W2
0009BC  518F82     SUB W3, W2, [W15]
0009BE  3A0008     BRA NZ, .L20
1782:              		{
1783:              			/* Has the task already been resumed from within an ISR? */
1784:              			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
0009C0  9008A1     MOV [W1+20], W1
0009C2  21CE82     MOV #0x1CE8, W2
0009C4  508F82     SUB W1, W2, [W15]
0009C6  320004     BRA Z, .L20
1785:              			{
1786:              				/* Is it in the suspended list because it is in the	Suspended
1787:              				state, or because is is blocked with no timeout? */
1788:              				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
1789:              				{
1790:              					xReturn = pdTRUE;
1791:              				}
1792:              				else
1793:              				{
1794:              					mtCOVERAGE_TEST_MARKER();
1795:              				}
1796:              			}
1797:              			else
1798:              			{
1799:              				mtCOVERAGE_TEST_MARKER();
1800:              			}
1801:              		}
1802:              		else
1803:              		{
1804:              			mtCOVERAGE_TEST_MARKER();
1805:              		}
1806:              
1807:              		return xReturn;
1808:              	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
0009D0  060000     RETURN
1809:              
1810:              #endif /* INCLUDE_vTaskSuspend */
1811:              /*-----------------------------------------------------------*/
1812:              
1813:              #if ( INCLUDE_vTaskSuspend == 1 )
1814:              
1815:              	void vTaskResume( TaskHandle_t xTaskToResume )
1816:              	{
0009D2  BE9F88     MOV.D W8, [W15++]
0009D4  780400     MOV W0, W8
1817:              	TCB_t * const pxTCB = xTaskToResume;
1818:              
1819:              		/* It does not make sense to resume the calling task. */
1820:              		configASSERT( xTaskToResume );
1821:              
1822:              		/* The parameter cannot be NULL as it is impossible to resume the
1823:              		currently executing task. */
1824:              		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
0009D6  804280     MOV pxCurrentTCB, W0
0009D8  500F88     SUB W0, W8, [W15]
0009DA  320020     BRA Z, .L23
0009DC  E00008     CP0 W8
0009DE  32001E     BRA Z, .L23
1825:              		{
1826:              			taskENTER_CRITICAL();
0009E0  0225F4     CALL vPortEnterCritical
0009E2  000000     NOP
1827:              			{
1828:              				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
0009E4  780008     MOV W8, W0
0009E6  07FFE6     RCALL prvTaskIsTaskSuspended
0009E8  E00000     CP0 W0
0009EA  320016     BRA Z, .L25
1829:              				{
1830:              					traceTASK_RESUME( pxTCB );
1831:              
1832:              					/* The ready list can be accessed even if the scheduler is
1833:              					suspended because this is inside a critical section. */
1834:              					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
0009EC  E88488     INC2 W8, W9
0009EE  780009     MOV W9, W0
0009F0  022788     CALL uxListRemove
0009F2  000000     NOP
1835:              					prvAddTaskToReadyList( pxTCB );
0009F4  900838     MOV [W8+22], W0
0009F6  E30858     CP uxTopReadyPriority
0009F8  310001     BRA C, .L26
0009FA  8842C0     MOV W0, uxTopReadyPriority
0009FC  B9006A     MUL.SU W0, #10, W0
0009FE  21CAC2     MOV #0x1CAC, W2
000A00  410000     ADD W2, W0, W0
000A02  780089     MOV W9, W1
000A04  02274E     CALL vListInsertEnd
000A06  000000     NOP
1836:              
1837:              					/* A higher priority task may have just been resumed. */
1838:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000A08  804280     MOV pxCurrentTCB, W0
000A0A  9008B8     MOV [W8+22], W1
000A0C  900830     MOV [W0+22], W0
000A0E  508F80     SUB W1, W0, [W15]
000A10  390003     BRA NC, .L25
1839:              					{
1840:              						/* This yield may not cause the task just resumed to run,
1841:              						but will leave the lists in the correct state for the
1842:              						next yield. */
1843:              						taskYIELD_IF_USING_PREEMPTION();
000A12  02286C     CALL .Letext0, .LFE2, _vPortYield
000A14  000000     NOP
000A16  000000     NOP
1844:              					}
1845:              					else
1846:              					{
1847:              						mtCOVERAGE_TEST_MARKER();
1848:              					}
1849:              				}
1850:              				else
1851:              				{
1852:              					mtCOVERAGE_TEST_MARKER();
1853:              				}
1854:              			}
1855:              			taskEXIT_CRITICAL();
000A18  022604     CALL vPortExitCritical
000A1A  000000     NOP
1856:              		}
1857:              		else
1858:              		{
1859:              			mtCOVERAGE_TEST_MARKER();
1860:              		}
1861:              	}
000A1C  BE044F     MOV.D [--W15], W8
000A1E  060000     RETURN
1862:              
1863:              #endif /* INCLUDE_vTaskSuspend */
1864:              
1865:              /*-----------------------------------------------------------*/
1866:              
1867:              #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1868:              
1869:              	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1870:              	{
000A20  BE9F88     MOV.D W8, [W15++]
000A22  781F8A     MOV W10, [W15++]
000A24  780400     MOV W0, W8
1871:              	BaseType_t xYieldRequired = pdFALSE;
000A2A  EB0480     CLR W9
000A36  200019     MOV #0x1, W9
000A38  9008B8     MOV [W8+22], W1
000A3A  900830     MOV [W0+22], W0
000A3C  508F80     SUB W1, W0, [W15]
000A3E  310001     BRA C, .L30
000A40  EB0480     CLR W9
000A68  EB0480     CLR W9
1872:              	TCB_t * const pxTCB = xTaskToResume;
1873:              	UBaseType_t uxSavedInterruptStatus;
1874:              
1875:              		configASSERT( xTaskToResume );
1876:              
1877:              		/* RTOS ports that support interrupt nesting have the concept of a
1878:              		maximum	system call (or maximum API call) interrupt priority.
1879:              		Interrupts that are	above the maximum system call priority are keep
1880:              		permanently enabled, even when the RTOS kernel is in a critical section,
1881:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1882:              		is defined in FreeRTOSConfig.h then
1883:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1884:              		failure if a FreeRTOS API function is called from an interrupt that has
1885:              		been assigned a priority above the configured maximum system call
1886:              		priority.  Only FreeRTOS functions that end in FromISR can be called
1887:              		from interrupts	that have been assigned a priority at or (logically)
1888:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
1889:              		separate interrupt safe API to ensure interrupt entry is as fast and as
1890:              		simple as possible.  More information (albeit Cortex-M specific) is
1891:              		provided on the following link:
1892:              		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1893:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1894:              
1895:              		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1896:              		{
1897:              			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000A26  780008     MOV W8, W0
000A28  07FFC5     RCALL prvTaskIsTaskSuspended
000A2C  E00000     CP0 W0
000A2E  32001D     BRA Z, .L28
1898:              			{
1899:              				traceTASK_RESUME_FROM_ISR( pxTCB );
1900:              
1901:              				/* Check the ready lists can be accessed. */
1902:              				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000A30  E20868     CP0 uxSchedulerSuspended
000A32  3A0016     BRA NZ, .L29
1903:              				{
1904:              					/* Ready lists can be accessed so move the task from the
1905:              					suspended list to the ready list directly. */
1906:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000A34  804280     MOV pxCurrentTCB, W0
1907:              					{
1908:              						xYieldRequired = pdTRUE;
1909:              					}
1910:              					else
1911:              					{
1912:              						mtCOVERAGE_TEST_MARKER();
1913:              					}
1914:              
1915:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000A42  E88508     INC2 W8, W10
000A44  78000A     MOV W10, W0
000A46  022788     CALL uxListRemove
000A48  000000     NOP
1916:              					prvAddTaskToReadyList( pxTCB );
000A4A  900838     MOV [W8+22], W0
000A4C  E30858     CP uxTopReadyPriority
000A4E  310001     BRA C, .L31
000A50  8842C0     MOV W0, uxTopReadyPriority
000A52  B9006A     MUL.SU W0, #10, W0
000A54  21CAC2     MOV #0x1CAC, W2
000A56  410000     ADD W2, W0, W0
000A58  78008A     MOV W10, W1
000A5A  02274E     CALL vListInsertEnd
000A5C  000000     NOP
000A5E  370005     BRA .L28
1917:              				}
1918:              				else
1919:              				{
1920:              					/* The delayed or ready lists cannot be accessed so the task
1921:              					is held in the pending ready list until the scheduler is
1922:              					unsuspended. */
1923:              					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000A60  4400EC     ADD W8, #0xC, W1
000A62  21CE80     MOV #0x1CE8, W0
000A64  02274E     CALL vListInsertEnd
000A66  000000     NOP
1924:              				}
1925:              			}
1926:              			else
1927:              			{
1928:              				mtCOVERAGE_TEST_MARKER();
1929:              			}
1930:              		}
1931:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1932:              
1933:              		return xYieldRequired;
1934:              	}
000A6A  780009     MOV W9, W0
000A6C  78054F     MOV [--W15], W10
000A6E  BE044F     MOV.D [--W15], W8
000A70  060000     RETURN
1935:              
1936:              #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1937:              /*-----------------------------------------------------------*/
1938:              
1939:              void vTaskStartScheduler( void )
1940:              {
1941:              BaseType_t xReturn;
1942:              
1943:              	/* Add the idle task at the lowest priority. */
1944:              	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1945:              	{
1946:              		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1947:              		StackType_t *pxIdleTaskStackBuffer = NULL;
1948:              		uint32_t ulIdleTaskStackSize;
1949:              
1950:              		/* The Idle task is created using user provided RAM - obtain the
1951:              		address of the RAM then create the idle task. */
1952:              		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
1953:              		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1954:              												configIDLE_TASK_NAME,
1955:              												ulIdleTaskStackSize,
1956:              												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1957:              												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
1958:              												pxIdleTaskStackBuffer,
1959:              												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1960:              
1961:              		if( xIdleTaskHandle != NULL )
1962:              		{
1963:              			xReturn = pdPASS;
1964:              		}
1965:              		else
1966:              		{
1967:              			xReturn = pdFAIL;
1968:              		}
1969:              	}
1970:              	#else
1971:              	{
1972:              		/* The Idle task is being created using dynamically allocated RAM. */
1973:              		xReturn = xTaskCreate(	prvIdleTask,
000D12  208665     MOV #0x866, W5
000D14  EB0200     CLR W4
000D16  EB0180     CLR W3
000D18  200732     MOV #0x73, W2
000D1A  288541     MOV #0x8854, W1
000D1C  20D7A0     MOV #0xD7A, W0
000D1E  07FFCB     RCALL xTaskCreate
1974:              								configIDLE_TASK_NAME,
1975:              								configMINIMAL_STACK_SIZE,
1976:              								( void * ) NULL,
1977:              								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
1978:              								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1979:              	}
1980:              	#endif /* configSUPPORT_STATIC_ALLOCATION */
1981:              
1982:              	#if ( configUSE_TIMERS == 1 )
1983:              	{
1984:              		if( xReturn == pdPASS )
1985:              		{
1986:              			xReturn = xTimerCreateTimerTask();
1987:              		}
1988:              		else
1989:              		{
1990:              			mtCOVERAGE_TEST_MARKER();
1991:              		}
1992:              	}
1993:              	#endif /* configUSE_TIMERS */
1994:              
1995:              	if( xReturn == pdPASS )
000D20  500FE1     SUB W0, #0x1, [W15]
000D22  3A000C     BRA NZ, .L80
1996:              	{
1997:              		/* freertos_tasks_c_additions_init() should only be called if the user
1998:              		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
1999:              		the only macro called by the function. */
2000:              		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2001:              		{
2002:              			freertos_tasks_c_additions_init();
2003:              		}
2004:              		#endif
2005:              
2006:              		/* Interrupts are turned off here, to ensure a tick does not occur
2007:              		before or during the call to xPortStartScheduler().  The stacks of
2008:              		the created tasks contain a status word with interrupts switched on
2009:              		so interrupts will automatically get re-enabled when the first task
2010:              		starts to run. */
2011:              		portDISABLE_INTERRUPTS();
000D24  2FF1F0     MOV #0xFF1F, W0
000D26  B60042     AND SR, WREG
000D28  A05000     BSET W0, #5
000D2A  880210     MOV W0, SR
000D2C  000000     NOP
000D2E  000000     NOP
2012:              
2013:              		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2014:              		{
2015:              			/* Switch Newlib's _impure_ptr variable to point to the _reent
2016:              			structure specific to the task that will run first. */
2017:              			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2018:              		}
2019:              		#endif /* configUSE_NEWLIB_REENTRANT */
2020:              
2021:              		xNextTaskUnblockTime = portMAX_DELAY;
000D30  EFA864     SETM xNextTaskUnblockTime
2022:              		xSchedulerRunning = pdTRUE;
000D32  200010     MOV #0x1, W0
000D34  8842D0     MOV W0, xSchedulerRunning
2023:              		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
000D36  EF2856     CLR xTickCount
2024:              
2025:              		/* If configGENERATE_RUN_TIME_STATS is defined then the following
2026:              		macro must be defined to configure the timer/counter used to generate
2027:              		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2028:              		is set to 0 and the following line fails to build then ensure you do not
2029:              		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2030:              		FreeRTOSConfig.h file. */
2031:              		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2032:              
2033:              		traceTASK_SWITCHED_IN();
2034:              
2035:              		/* Setting up the timer tick is hardware specific and thus in the
2036:              		portable interface. */
2037:              		if( xPortStartScheduler() != pdFALSE )
000D38  0225C6     CALL xPortStartScheduler
000D3A  000000     NOP
2038:              		{
2039:              			/* Should not reach here as if the scheduler is running the
2040:              			function will not return. */
2041:              		}
2042:              		else
2043:              		{
2044:              			/* Should only reach here if a task calls xTaskEndScheduler(). */
2045:              		}
2046:              	}
2047:              	else
2048:              	{
2049:              		/* This line will only be reached if the kernel could not be started,
2050:              		because there was not enough FreeRTOS heap to create the idle task
2051:              		or the timer task. */
2052:              		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2053:              	}
2054:              
2055:              	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2056:              	meaning xIdleTaskHandle is not used anywhere else. */
2057:              	( void ) xIdleTaskHandle;
2058:              }
000D3C  060000     RETURN
2059:              /*-----------------------------------------------------------*/
2060:              
2061:              void vTaskEndScheduler( void )
2062:              {
2063:              	/* Stop the scheduler interrupts and call the portable scheduler end
2064:              	routine so the original ISRs can be restored if necessary.  The port
2065:              	layer must ensure interrupts enable	bit is left in the correct state. */
2066:              	portDISABLE_INTERRUPTS();
000A72  2FF1F0     MOV #0xFF1F, W0
000A74  B60042     AND SR, WREG
000A76  A05000     BSET W0, #5
000A78  880210     MOV W0, SR
000A7A  000000     NOP
000A7C  000000     NOP
2067:              	xSchedulerRunning = pdFALSE;
000A7E  EF285A     CLR xSchedulerRunning
2068:              	vPortEndScheduler();
000A80  0225A8     CALL vPortEndScheduler
000A82  000000     NOP
2069:              }
000A84  060000     RETURN
2070:              /*----------------------------------------------------------*/
2071:              
2072:              void vTaskSuspendAll( void )
2073:              {
2074:              	/* A critical section is not required as the variable is of type
2075:              	BaseType_t.  Please read Richard Barry's reply in the following link to a
2076:              	post in the FreeRTOS support forum before reporting this as a bug! -
2077:              	http://goo.gl/wu4acr */
2078:              	++uxSchedulerSuspended;
000A86  EC2868     INC uxSchedulerSuspended
2079:              }
000A88  060000     RETURN
2080:              /*----------------------------------------------------------*/
2081:              
2082:              #if ( configUSE_TICKLESS_IDLE != 0 )
2083:              
2084:              	static TickType_t prvGetExpectedIdleTime( void )
2085:              	{
2086:              	TickType_t xReturn;
2087:              	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2088:              
2089:              		/* uxHigherPriorityReadyTasks takes care of the case where
2090:              		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2091:              		task that are in the Ready state, even though the idle task is
2092:              		running. */
2093:              		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2094:              		{
2095:              			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2096:              			{
2097:              				uxHigherPriorityReadyTasks = pdTRUE;
2098:              			}
2099:              		}
2100:              		#else
2101:              		{
2102:              			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2103:              
2104:              			/* When port optimised task selection is used the uxTopReadyPriority
2105:              			variable is used as a bit map.  If bits other than the least
2106:              			significant bit are set then there are tasks that have a priority
2107:              			above the idle priority that are in the Ready state.  This takes
2108:              			care of the case where the co-operative scheduler is in use. */
2109:              			if( uxTopReadyPriority > uxLeastSignificantBit )
2110:              			{
2111:              				uxHigherPriorityReadyTasks = pdTRUE;
2112:              			}
2113:              		}
2114:              		#endif
2115:              
2116:              		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2117:              		{
2118:              			xReturn = 0;
2119:              		}
2120:              		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2121:              		{
2122:              			/* There are other idle priority tasks in the ready state.  If
2123:              			time slicing is used then the very next tick interrupt must be
2124:              			processed. */
2125:              			xReturn = 0;
2126:              		}
2127:              		else if( uxHigherPriorityReadyTasks != pdFALSE )
2128:              		{
2129:              			/* There are tasks in the Ready state that have a priority above the
2130:              			idle priority.  This path can only be reached if
2131:              			configUSE_PREEMPTION is 0. */
2132:              			xReturn = 0;
2133:              		}
2134:              		else
2135:              		{
2136:              			xReturn = xNextTaskUnblockTime - xTickCount;
2137:              		}
2138:              
2139:              		return xReturn;
2140:              	}
2141:              
2142:              #endif /* configUSE_TICKLESS_IDLE */
2143:              /*----------------------------------------------------------*/
2144:              
2145:              BaseType_t xTaskResumeAll( void )
2146:              {
000E4C  BE9F88     MOV.D W8, [W15++]
000E4E  BE9F8A     MOV.D W10, [W15++]
2147:              TCB_t *pxTCB = NULL;
2148:              BaseType_t xAlreadyYielded = pdFALSE;
000E56  EB0400     CLR W8
000EBA  EB0400     CLR W8
2149:              
2150:              	/* If uxSchedulerSuspended is zero then this function does not match a
2151:              	previous call to vTaskSuspendAll(). */
2152:              	configASSERT( uxSchedulerSuspended );
2153:              
2154:              	/* It is possible that an ISR caused a task to be removed from an event
2155:              	list while the scheduler was suspended.  If this was the case then the
2156:              	removed task will have been added to the xPendingReadyList.  Once the
2157:              	scheduler has been resumed it is safe to move all the pending ready
2158:              	tasks from this list into their appropriate ready list. */
2159:              	taskENTER_CRITICAL();
000E50  0225F4     CALL vPortEnterCritical
000E52  000000     NOP
2160:              	{
2161:              		--uxSchedulerSuspended;
000E54  ED2868     DEC uxSchedulerSuspended
2162:              
2163:              		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000E58  E20868     CP0 uxSchedulerSuspended
000E5A  3A0036     BRA NZ, .L115
2164:              		{
2165:              			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
000E5C  E20854     CP0 uxCurrentNumberOfTasks
000E5E  3A001B     BRA NZ, .L128
000E60  370033     BRA .L115
2166:              			{
2167:              				/* Move any readied tasks from the pending list into the
2168:              				appropriate ready list. */
2169:              				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
000E96  21CE8A     MOV #0x1CE8, W10
000E9A  E0001A     CP0 [W10]
000E9C  3AFFE2     BRA NZ, .L119
2170:              				{
2171:              					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000E62  80E770     MOV 0x1CEE, W0
000E64  900430     MOV [W0+6], W8
2172:              					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000E66  44006C     ADD W8, #0xC, W0
000E68  022788     CALL uxListRemove
000E6A  000000     NOP
2173:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000E6C  E88488     INC2 W8, W9
000E6E  780009     MOV W9, W0
000E70  022788     CALL uxListRemove
000E72  000000     NOP
2174:              					prvAddTaskToReadyList( pxTCB );
000E74  900838     MOV [W8+22], W0
000E76  E30858     CP uxTopReadyPriority
000E78  310001     BRA C, .L117
000E7A  8842C0     MOV W0, uxTopReadyPriority
000E7C  B9006A     MUL.SU W0, #10, W0
000E7E  458000     ADD W11, W0, W0
000E80  780089     MOV W9, W1
000E82  02274E     CALL vListInsertEnd
000E84  000000     NOP
000E98  21CACB     MOV #0x1CAC, W11
2175:              
2176:              					/* If the moved task has a priority higher than the current
2177:              					task then a yield must be performed. */
2178:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000E86  804280     MOV pxCurrentTCB, W0
000E88  9008B8     MOV [W8+22], W1
000E8A  900830     MOV [W0+22], W0
000E8C  508F80     SUB W1, W0, [W15]
000E8E  390005     BRA NC, .L132
2179:              					{
2180:              						xYieldPending = pdTRUE;
000E90  200010     MOV #0x1, W0
000E92  8842F0     MOV W0, xYieldPending
000E94  370002     BRA .L132
2181:              					}
2182:              					else
2183:              					{
2184:              						mtCOVERAGE_TEST_MARKER();
2185:              					}
2186:              				}
2187:              
2188:              				if( pxTCB != NULL )
000E9E  E00008     CP0 W8
2189:              				{
2190:              					/* A task was unblocked while the scheduler was suspended,
2191:              					which may have prevented the next unblock time from being
2192:              					re-calculated, in which case re-calculate it now.  Mainly
2193:              					important for low power tickless implementations, where
2194:              					this can prevent an unnecessary exit from low power
2195:              					state. */
2196:              					prvResetNextTaskUnblockTime();
000EA0  320001     BRA Z, .L120, .LBB11
000EA2  07FF77     RCALL prvResetNextTaskUnblockTime
2197:              				}
2198:              
2199:              				/* If any ticks occurred while the scheduler was suspended then
2200:              				they should be processed now.  This ensures the tick count does
2201:              				not	slip, and that any delayed tasks are resumed at the correct
2202:              				time. */
2203:              				{
2204:              					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
000EA4  8042E8     MOV uxPendedTicks, W8
2205:              
2206:              					if( uxPendedCounts > ( UBaseType_t ) 0U )
000EA6  E00008     CP0 W8
000EA8  320008     BRA Z, .L121, .LBE11
2207:              					{
2208:              						do
2209:              						{
2210:              							if( xTaskIncrementTick() != pdFALSE )
000EAA  200019     MOV #0x1, W9
000EAC  07FF7D     RCALL xTaskIncrementTick
000EAE  E00000     CP0 W0
000EB0  320001     BRA Z, .L122
2211:              							{
2212:              								xYieldPending = pdTRUE;
000EB2  8842F9     MOV W9, xYieldPending
2213:              							}
2214:              							else
2215:              							{
2216:              								mtCOVERAGE_TEST_MARKER();
2217:              							}
2218:              							--uxPendedCounts;
000EB4  E90408     DEC W8, W8
2219:              						} while( uxPendedCounts > ( UBaseType_t ) 0U );
000EB6  3AFFFA     BRA NZ, .L129
2220:              
2221:              						uxPendedTicks = 0;
000EB8  EF285C     CLR uxPendedTicks
2222:              					}
2223:              					else
2224:              					{
2225:              						mtCOVERAGE_TEST_MARKER();
2226:              					}
2227:              				}
2228:              
2229:              				if( xYieldPending != pdFALSE )
000EBC  E2085E     CP0 xYieldPending
000EBE  320004     BRA Z, .L115
2230:              				{
2231:              					#if( configUSE_PREEMPTION != 0 )
2232:              					{
2233:              						xAlreadyYielded = pdTRUE;
000EC6  200018     MOV #0x1, W8
2234:              					}
2235:              					#endif
2236:              					taskYIELD_IF_USING_PREEMPTION();
000EC0  02286C     CALL .Letext0, .LFE2, _vPortYield
000EC2  000000     NOP
000EC4  000000     NOP
2237:              				}
2238:              				else
2239:              				{
2240:              					mtCOVERAGE_TEST_MARKER();
2241:              				}
2242:              			}
2243:              		}
2244:              		else
2245:              		{
2246:              			mtCOVERAGE_TEST_MARKER();
2247:              		}
2248:              	}
2249:              	taskEXIT_CRITICAL();
000EC8  022604     CALL vPortExitCritical
000ECA  000000     NOP
2250:              
2251:              	return xAlreadyYielded;
2252:              }
000ECC  780008     MOV W8, W0
000ECE  BE054F     MOV.D [--W15], W10
000ED0  BE044F     MOV.D [--W15], W8
000ED2  060000     RETURN
2253:              /*-----------------------------------------------------------*/
2254:              
2255:              TickType_t xTaskGetTickCount( void )
2256:              {
000A8A  781F88     MOV W8, [W15++]
2257:              TickType_t xTicks;
2258:              
2259:              	/* Critical section required if running on a 16 bit processor. */
2260:              	portTICK_TYPE_ENTER_CRITICAL();
000A8C  0225F4     CALL vPortEnterCritical
000A8E  000000     NOP
2261:              	{
2262:              		xTicks = xTickCount;
000A90  8042B8     MOV xTickCount, W8
2263:              	}
2264:              	portTICK_TYPE_EXIT_CRITICAL();
000A92  022604     CALL vPortExitCritical
000A94  000000     NOP
2265:              
2266:              	return xTicks;
2267:              }
000A96  780008     MOV W8, W0
000A98  78044F     MOV [--W15], W8
000A9A  060000     RETURN
2268:              /*-----------------------------------------------------------*/
2269:              
2270:              TickType_t xTaskGetTickCountFromISR( void )
2271:              {
2272:              TickType_t xReturn;
2273:              UBaseType_t uxSavedInterruptStatus;
2274:              
2275:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
2276:              	system call (or maximum API call) interrupt priority.  Interrupts that are
2277:              	above the maximum system call priority are kept permanently enabled, even
2278:              	when the RTOS kernel is in a critical section, but cannot make any calls to
2279:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2280:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2281:              	failure if a FreeRTOS API function is called from an interrupt that has been
2282:              	assigned a priority above the configured maximum system call priority.
2283:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
2284:              	that have been assigned a priority at or (logically) below the maximum
2285:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2286:              	safe API to ensure interrupt entry is as fast and as simple as possible.
2287:              	More information (albeit Cortex-M specific) is provided on the following
2288:              	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
2289:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2290:              
2291:              	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2292:              	{
2293:              		xReturn = xTickCount;
000A9C  8042B0     MOV xTickCount, W0
2294:              	}
2295:              	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2296:              
2297:              	return xReturn;
2298:              }
000A9E  060000     RETURN
2299:              /*-----------------------------------------------------------*/
2300:              
2301:              UBaseType_t uxTaskGetNumberOfTasks( void )
2302:              {
2303:              	/* A critical section is not required because the variables are of type
2304:              	BaseType_t. */
2305:              	return uxCurrentNumberOfTasks;
000AA0  8042A0     MOV uxCurrentNumberOfTasks, W0
2306:              }
000AA2  060000     RETURN
2307:              /*-----------------------------------------------------------*/
2308:              
2309:              char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2310:              {
2311:              TCB_t *pxTCB;
2312:              
2313:              	/* If null is passed in here then the name of the calling task is being
2314:              	queried. */
2315:              	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
000AA4  E00000     CP0 W0
000AA6  3A0001     BRA NZ, .L39
000AA8  804280     MOV pxCurrentTCB, W0
2316:              	configASSERT( pxTCB );
2317:              	return &( pxTCB->pcTaskName[ 0 ] );
000AAA  40007A     ADD W0, #0x1A, W0
2318:              }
000AAC  060000     RETURN
2319:              /*-----------------------------------------------------------*/
2320:              
2321:              #if ( INCLUDE_xTaskGetHandle == 1 )
2322:              
2323:              	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2324:              	{
2325:              	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2326:              	UBaseType_t x;
2327:              	char cNextChar;
2328:              	BaseType_t xBreakLoop;
2329:              
2330:              		/* This function is called with the scheduler suspended. */
2331:              
2332:              		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2333:              		{
2334:              			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
2335:              
2336:              			do
2337:              			{
2338:              				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
2339:              
2340:              				/* Check each character in the name looking for a match or
2341:              				mismatch. */
2342:              				xBreakLoop = pdFALSE;
2343:              				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2344:              				{
2345:              					cNextChar = pxNextTCB->pcTaskName[ x ];
2346:              
2347:              					if( cNextChar != pcNameToQuery[ x ] )
2348:              					{
2349:              						/* Characters didn't match. */
2350:              						xBreakLoop = pdTRUE;
2351:              					}
2352:              					else if( cNextChar == ( char ) 0x00 )
2353:              					{
2354:              						/* Both strings terminated, a match must have been
2355:              						found. */
2356:              						pxReturn = pxNextTCB;
2357:              						xBreakLoop = pdTRUE;
2358:              					}
2359:              					else
2360:              					{
2361:              						mtCOVERAGE_TEST_MARKER();
2362:              					}
2363:              
2364:              					if( xBreakLoop != pdFALSE )
2365:              					{
2366:              						break;
2367:              					}
2368:              				}
2369:              
2370:              				if( pxReturn != NULL )
2371:              				{
2372:              					/* The handle has been found. */
2373:              					break;
2374:              				}
2375:              
2376:              			} while( pxNextTCB != pxFirstTCB );
2377:              		}
2378:              		else
2379:              		{
2380:              			mtCOVERAGE_TEST_MARKER();
2381:              		}
2382:              
2383:              		return pxReturn;
2384:              	}
2385:              
2386:              #endif /* INCLUDE_xTaskGetHandle */
2387:              /*-----------------------------------------------------------*/
2388:              
2389:              #if ( INCLUDE_xTaskGetHandle == 1 )
2390:              
2391:              	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2392:              	{
2393:              	UBaseType_t uxQueue = configMAX_PRIORITIES;
2394:              	TCB_t* pxTCB;
2395:              
2396:              		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2397:              		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2398:              
2399:              		vTaskSuspendAll();
2400:              		{
2401:              			/* Search the ready lists. */
2402:              			do
2403:              			{
2404:              				uxQueue--;
2405:              				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
2406:              
2407:              				if( pxTCB != NULL )
2408:              				{
2409:              					/* Found the handle. */
2410:              					break;
2411:              				}
2412:              
2413:              			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2414:              
2415:              			/* Search the delayed lists. */
2416:              			if( pxTCB == NULL )
2417:              			{
2418:              				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2419:              			}
2420:              
2421:              			if( pxTCB == NULL )
2422:              			{
2423:              				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
2424:              			}
2425:              
2426:              			#if ( INCLUDE_vTaskSuspend == 1 )
2427:              			{
2428:              				if( pxTCB == NULL )
2429:              				{
2430:              					/* Search the suspended list. */
2431:              					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2432:              				}
2433:              			}
2434:              			#endif
2435:              
2436:              			#if( INCLUDE_vTaskDelete == 1 )
2437:              			{
2438:              				if( pxTCB == NULL )
2439:              				{
2440:              					/* Search the deleted list. */
2441:              					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2442:              				}
2443:              			}
2444:              			#endif
2445:              		}
2446:              		( void ) xTaskResumeAll();
2447:              
2448:              		return pxTCB;
2449:              	}
2450:              
2451:              #endif /* INCLUDE_xTaskGetHandle */
2452:              /*-----------------------------------------------------------*/
2453:              
2454:              #if ( configUSE_TRACE_FACILITY == 1 )
2455:              
2456:              	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
2457:              	{
2458:              	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2459:              
2460:              		vTaskSuspendAll();
2461:              		{
2462:              			/* Is there a space in the array for each task in the system? */
2463:              			if( uxArraySize >= uxCurrentNumberOfTasks )
2464:              			{
2465:              				/* Fill in an TaskStatus_t structure with information on each
2466:              				task in the Ready state. */
2467:              				do
2468:              				{
2469:              					uxQueue--;
2470:              					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
2471:              
2472:              				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2473:              
2474:              				/* Fill in an TaskStatus_t structure with information on each
2475:              				task in the Blocked state. */
2476:              				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
2477:              				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
2478:              
2479:              				#if( INCLUDE_vTaskDelete == 1 )
2480:              				{
2481:              					/* Fill in an TaskStatus_t structure with information on
2482:              					each task that has been deleted but not yet cleaned up. */
2483:              					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
2484:              				}
2485:              				#endif
2486:              
2487:              				#if ( INCLUDE_vTaskSuspend == 1 )
2488:              				{
2489:              					/* Fill in an TaskStatus_t structure with information on
2490:              					each task in the Suspended state. */
2491:              					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
2492:              				}
2493:              				#endif
2494:              
2495:              				#if ( configGENERATE_RUN_TIME_STATS == 1)
2496:              				{
2497:              					if( pulTotalRunTime != NULL )
2498:              					{
2499:              						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2500:              							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2501:              						#else
2502:              							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2503:              						#endif
2504:              					}
2505:              				}
2506:              				#else
2507:              				{
2508:              					if( pulTotalRunTime != NULL )
2509:              					{
2510:              						*pulTotalRunTime = 0;
2511:              					}
2512:              				}
2513:              				#endif
2514:              			}
2515:              			else
2516:              			{
2517:              				mtCOVERAGE_TEST_MARKER();
2518:              			}
2519:              		}
2520:              		( void ) xTaskResumeAll();
2521:              
2522:              		return uxTask;
2523:              	}
2524:              
2525:              #endif /* configUSE_TRACE_FACILITY */
2526:              /*----------------------------------------------------------*/
2527:              
2528:              #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2529:              
2530:              	TaskHandle_t xTaskGetIdleTaskHandle( void )
2531:              	{
2532:              		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2533:              		started, then xIdleTaskHandle will be NULL. */
2534:              		configASSERT( ( xIdleTaskHandle != NULL ) );
2535:              		return xIdleTaskHandle;
2536:              	}
2537:              
2538:              #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2539:              /*----------------------------------------------------------*/
2540:              
2541:              /* This conditional compilation should use inequality to 0, not equality to 1.
2542:              This is to ensure vTaskStepTick() is available when user defined low power mode
2543:              implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2544:              1. */
2545:              #if ( configUSE_TICKLESS_IDLE != 0 )
2546:              
2547:              	void vTaskStepTick( const TickType_t xTicksToJump )
2548:              	{
2549:              		/* Correct the tick count value after a period during which the tick
2550:              		was suppressed.  Note this does *not* call the tick hook function for
2551:              		each stepped tick. */
2552:              		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2553:              		xTickCount += xTicksToJump;
2554:              		traceINCREASE_TICK_COUNT( xTicksToJump );
2555:              	}
2556:              
2557:              #endif /* configUSE_TICKLESS_IDLE */
2558:              /*----------------------------------------------------------*/
2559:              
2560:              #if ( INCLUDE_xTaskAbortDelay == 1 )
2561:              
2562:              	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2563:              	{
2564:              	TCB_t *pxTCB = xTask;
2565:              	BaseType_t xReturn;
2566:              
2567:              		configASSERT( pxTCB );
2568:              
2569:              		vTaskSuspendAll();
2570:              		{
2571:              			/* A task can only be prematurely removed from the Blocked state if
2572:              			it is actually in the Blocked state. */
2573:              			if( eTaskGetState( xTask ) == eBlocked )
2574:              			{
2575:              				xReturn = pdPASS;
2576:              
2577:              				/* Remove the reference to the task from the blocked list.  An
2578:              				interrupt won't touch the xStateListItem because the
2579:              				scheduler is suspended. */
2580:              				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2581:              
2582:              				/* Is the task waiting on an event also?  If so remove it from
2583:              				the event list too.  Interrupts can touch the event list item,
2584:              				even though the scheduler is suspended, so a critical section
2585:              				is used. */
2586:              				taskENTER_CRITICAL();
2587:              				{
2588:              					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2589:              					{
2590:              						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2591:              						pxTCB->ucDelayAborted = pdTRUE;
2592:              					}
2593:              					else
2594:              					{
2595:              						mtCOVERAGE_TEST_MARKER();
2596:              					}
2597:              				}
2598:              				taskEXIT_CRITICAL();
2599:              
2600:              				/* Place the unblocked task into the appropriate ready list. */
2601:              				prvAddTaskToReadyList( pxTCB );
2602:              
2603:              				/* A task being unblocked cannot cause an immediate context
2604:              				switch if preemption is turned off. */
2605:              				#if (  configUSE_PREEMPTION == 1 )
2606:              				{
2607:              					/* Preemption is on, but a context switch should only be
2608:              					performed if the unblocked task has a priority that is
2609:              					equal to or higher than the currently executing task. */
2610:              					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2611:              					{
2612:              						/* Pend the yield to be performed when the scheduler
2613:              						is unsuspended. */
2614:              						xYieldPending = pdTRUE;
2615:              					}
2616:              					else
2617:              					{
2618:              						mtCOVERAGE_TEST_MARKER();
2619:              					}
2620:              				}
2621:              				#endif /* configUSE_PREEMPTION */
2622:              			}
2623:              			else
2624:              			{
2625:              				xReturn = pdFAIL;
2626:              			}
2627:              		}
2628:              		( void ) xTaskResumeAll();
2629:              
2630:              		return xReturn;
2631:              	}
2632:              
2633:              #endif /* INCLUDE_xTaskAbortDelay */
2634:              /*----------------------------------------------------------*/
2635:              
2636:              BaseType_t xTaskIncrementTick( void )
2637:              {
000DA8  BE9F88     MOV.D W8, [W15++]
000DAA  BE9F8A     MOV.D W10, [W15++]
000DAC  BE9F8C     MOV.D W12, [W15++]
2638:              TCB_t * pxTCB;
2639:              TickType_t xItemValue;
2640:              BaseType_t xSwitchRequired = pdFALSE;
000E36  EB0500     CLR W10
000E38  370001     BRA .L105
2641:              
2642:              	/* Called by the portable layer each time a tick interrupt occurs.
2643:              	Increments the tick then checks to see if the new tick value will cause any
2644:              	tasks to be unblocked. */
2645:              	traceTASK_INCREMENT_TICK( xTickCount );
2646:              	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000DAE  E20868     CP0 uxSchedulerSuspended
000DB0  3A0041     BRA NZ, .L95, .LBE8
2647:              	{
2648:              		/* Minor optimisation.  The tick count cannot change in this
2649:              		block. */
2650:              		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
000DB2  8042BB     MOV xTickCount, W11
000DB4  E8058B     INC W11, W11
2651:              
2652:              		/* Increment the RTOS tick, switching the delayed and overflowed
2653:              		delayed lists if it wraps to 0. */
2654:              		xTickCount = xConstTickCount;
000DB6  8842BB     MOV W11, xTickCount
2655:              
2656:              		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
000DB8  3A0006     BRA NZ, .L96, .LBE9
2657:              		{
2658:              			taskSWITCH_DELAYED_LISTS();
000DBA  804350     MOV pxDelayedTaskList, W0
000DBC  F8086C     PUSH pxOverflowDelayedTaskList
000DBE  F9086A     POP pxDelayedTaskList
000DC0  884360     MOV W0, pxOverflowDelayedTaskList
000DC2  EC2860     INC xNumOfOverflows
000DC4  07FFE6     RCALL prvResetNextTaskUnblockTime
2659:              		}
2660:              		else
2661:              		{
2662:              			mtCOVERAGE_TEST_MARKER();
2663:              		}
2664:              
2665:              		/* See if this tick has made a timeout expire.  Tasks are stored in
2666:              		the	queue in the order of their wake time - meaning once one task
2667:              		has been found whose block time has not expired there is no need to
2668:              		look any further down the list. */
2669:              		if( xConstTickCount >= xNextTaskUnblockTime )
000DC6  EB0500     CLR W10
000DC8  804320     MOV xNextTaskUnblockTime, W0
000DCA  500F8B     SUB W0, W11, [W15]
000DCC  360003     BRA LEU, .L112
000DCE  37002A     BRA .L98
2670:              		{
2671:              			for( ;; )
2672:              			{
2673:              				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000DD8  804350     MOV pxDelayedTaskList, W0
000DDA  E00010     CP0 [W0]
000DDC  3A0002     BRA NZ, .L99
2674:              				{
2675:              					/* The delayed list is empty.  Set xNextTaskUnblockTime
2676:              					to the maximum possible value so it is extremely
2677:              					unlikely that the
2678:              					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2679:              					next time through. */
2680:              					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000DDE  EFA864     SETM xNextTaskUnblockTime
2681:              					break;
000DE0  370021     BRA .L98
2682:              				}
2683:              				else
2684:              				{
2685:              					/* The delayed list is not empty, get the value of the
2686:              					item at the head of the delayed list.  This is the time
2687:              					at which the task at the head of the delayed list must
2688:              					be removed from the Blocked state. */
2689:              					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000DE2  804350     MOV pxDelayedTaskList, W0
000DE4  900030     MOV [W0+6], W0
000DE6  900430     MOV [W0+6], W8
2690:              					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
000DE8  900018     MOV [W8+2], W0
2691:              
2692:              					if( xConstTickCount < xItemValue )
000DEA  558F80     SUB W11, W0, [W15]
000DEC  310002     BRA C, .L100
2693:              					{
2694:              						/* It is not time to unblock this item yet, but the
2695:              						item value is the time at which the task at the head
2696:              						of the blocked list must be removed from the Blocked
2697:              						state -	so record the item value in
2698:              						xNextTaskUnblockTime. */
2699:              						xNextTaskUnblockTime = xItemValue;
000DEE  884320     MOV W0, xNextTaskUnblockTime
2700:              						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
000DF0  370019     BRA .L98
2701:              					}
2702:              					else
2703:              					{
2704:              						mtCOVERAGE_TEST_MARKER();
2705:              					}
2706:              
2707:              					/* It is time to remove the item from the Blocked state. */
2708:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000DF2  E88488     INC2 W8, W9
000DF4  780009     MOV W9, W0
000DF6  022788     CALL uxListRemove
000DF8  000000     NOP
2709:              
2710:              					/* Is the task waiting on an event also?  If so remove
2711:              					it from the event list. */
2712:              					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000DFA  900828     MOV [W8+20], W0
000DFC  E00000     CP0 W0
000DFE  320003     BRA Z, .L101
2713:              					{
2714:              						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000E00  44006C     ADD W8, #0xC, W0
000E02  022788     CALL uxListRemove
000E04  000000     NOP
2715:              					}
2716:              					else
2717:              					{
2718:              						mtCOVERAGE_TEST_MARKER();
2719:              					}
2720:              
2721:              					/* Place the unblocked task into the appropriate ready
2722:              					list. */
2723:              					prvAddTaskToReadyList( pxTCB );
000DD4  21CACC     MOV #0x1CAC, W12
000E06  900838     MOV [W8+22], W0
000E08  E30858     CP uxTopReadyPriority
000E0A  310001     BRA C, .L102
000E0C  8842C0     MOV W0, uxTopReadyPriority
000E0E  B9006A     MUL.SU W0, #10, W0
000E10  460000     ADD W12, W0, W0
000E12  780089     MOV W9, W1
000E14  02274E     CALL vListInsertEnd
000E16  000000     NOP
2724:              
2725:              					/* A task being unblocked cannot cause an immediate
2726:              					context switch if preemption is turned off. */
2727:              					#if (  configUSE_PREEMPTION == 1 )
2728:              					{
2729:              						/* Preemption is on, but a context switch should
2730:              						only be performed if the unblocked task has a
2731:              						priority that is equal to or higher than the
2732:              						currently executing task. */
2733:              						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000E18  804280     MOV pxCurrentTCB, W0
000E1A  9008B8     MOV [W8+22], W1
000E1C  900830     MOV [W0+22], W0
000E1E  508F80     SUB W1, W0, [W15]
000E20  31FFD7     BRA C, .L108
000E22  37FFDA     BRA .L113
2734:              						{
2735:              							xSwitchRequired = pdTRUE;
000DD0  78050D     MOV W13, W10
000DD2  370002     BRA .L113
000DD6  20001D     MOV #0x1, W13
2736:              						}
2737:              						else
2738:              						{
2739:              							mtCOVERAGE_TEST_MARKER();
2740:              						}
2741:              					}
2742:              					#endif /* configUSE_PREEMPTION */
2743:              				}
2744:              			}
2745:              		}
2746:              
2747:              		/* Tasks of equal priority to the currently running task will share
2748:              		processing time (time slice) if preemption is on, and the application
2749:              		writer has not explicitly turned time slicing off. */
2750:              		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2751:              		{
2752:              			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
000E24  804280     MOV pxCurrentTCB, W0
000E26  900830     MOV [W0+22], W0
000E28  B9006A     MUL.SU W0, #10, W0
000E2A  21CAC2     MOV #0x1CAC, W2
000E2C  780062     MOV [W2+W0], W0
000E2E  500FE1     SUB W0, #0x1, [W15]
000E30  3E0004     BRA GTU, .L109
000E32  370004     BRA .L105
2753:              			{
2754:              				xSwitchRequired = pdTRUE;
000E3A  20001A     MOV #0x1, W10
2755:              			}
2756:              			else
2757:              			{
2758:              				mtCOVERAGE_TEST_MARKER();
2759:              			}
2760:              		}
2761:              		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2762:              
2763:              		#if ( configUSE_TICK_HOOK == 1 )
2764:              		{
2765:              			/* Guard against the tick hook being called when the pended tick
2766:              			count is being unwound (when the scheduler is being unlocked). */
2767:              			if( uxPendedTicks == ( UBaseType_t ) 0U )
2768:              			{
2769:              				vApplicationTickHook();
2770:              			}
2771:              			else
2772:              			{
2773:              				mtCOVERAGE_TEST_MARKER();
2774:              			}
2775:              		}
2776:              		#endif /* configUSE_TICK_HOOK */
2777:              	}
2778:              	else
2779:              	{
2780:              		++uxPendedTicks;
000E34  EC285C     INC uxPendedTicks
2781:              
2782:              		/* The tick hook gets called at regular intervals, even if the
2783:              		scheduler is locked. */
2784:              		#if ( configUSE_TICK_HOOK == 1 )
2785:              		{
2786:              			vApplicationTickHook();
2787:              		}
2788:              		#endif
2789:              	}
2790:              
2791:              	#if ( configUSE_PREEMPTION == 1 )
2792:              	{
2793:              		if( xYieldPending != pdFALSE )
000E3C  E2085E     CP0 xYieldPending
000E3E  320001     BRA Z, .L106
2794:              		{
2795:              			xSwitchRequired = pdTRUE;
000E40  20001A     MOV #0x1, W10
2796:              		}
2797:              		else
2798:              		{
2799:              			mtCOVERAGE_TEST_MARKER();
2800:              		}
2801:              	}
2802:              	#endif /* configUSE_PREEMPTION */
2803:              
2804:              	return xSwitchRequired;
2805:              }
000E42  78000A     MOV W10, W0
000E44  BE064F     MOV.D [--W15], W12
000E46  BE054F     MOV.D [--W15], W10
000E48  BE044F     MOV.D [--W15], W8
000E4A  060000     RETURN
2806:              /*-----------------------------------------------------------*/
2807:              
2808:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2809:              
2810:              	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2811:              	{
2812:              	TCB_t *xTCB;
2813:              
2814:              		/* If xTask is NULL then it is the task hook of the calling task that is
2815:              		getting set. */
2816:              		if( xTask == NULL )
2817:              		{
2818:              			xTCB = ( TCB_t * ) pxCurrentTCB;
2819:              		}
2820:              		else
2821:              		{
2822:              			xTCB = xTask;
2823:              		}
2824:              
2825:              		/* Save the hook function in the TCB.  A critical section is required as
2826:              		the value can be accessed from an interrupt. */
2827:              		taskENTER_CRITICAL();
2828:              		{
2829:              			xTCB->pxTaskTag = pxHookFunction;
2830:              		}
2831:              		taskEXIT_CRITICAL();
2832:              	}
2833:              
2834:              #endif /* configUSE_APPLICATION_TASK_TAG */
2835:              /*-----------------------------------------------------------*/
2836:              
2837:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2838:              
2839:              	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2840:              	{
2841:              	TCB_t *xTCB;
2842:              	TaskHookFunction_t xReturn;
2843:              
2844:              		/* If xTask is NULL then we are setting our own task hook. */
2845:              		if( xTask == NULL )
2846:              		{
2847:              			xTCB = ( TCB_t * ) pxCurrentTCB;
2848:              		}
2849:              		else
2850:              		{
2851:              			xTCB = xTask;
2852:              		}
2853:              
2854:              		/* Save the hook function in the TCB.  A critical section is required as
2855:              		the value can be accessed from an interrupt. */
2856:              		taskENTER_CRITICAL();
2857:              		{
2858:              			xReturn = xTCB->pxTaskTag;
2859:              		}
2860:              		taskEXIT_CRITICAL();
2861:              
2862:              		return xReturn;
2863:              	}
2864:              
2865:              #endif /* configUSE_APPLICATION_TASK_TAG */
2866:              /*-----------------------------------------------------------*/
2867:              
2868:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2869:              
2870:              	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2871:              	{
2872:              	TCB_t *xTCB;
2873:              	BaseType_t xReturn;
2874:              
2875:              		/* If xTask is NULL then we are calling our own task hook. */
2876:              		if( xTask == NULL )
2877:              		{
2878:              			xTCB = pxCurrentTCB;
2879:              		}
2880:              		else
2881:              		{
2882:              			xTCB = xTask;
2883:              		}
2884:              
2885:              		if( xTCB->pxTaskTag != NULL )
2886:              		{
2887:              			xReturn = xTCB->pxTaskTag( pvParameter );
2888:              		}
2889:              		else
2890:              		{
2891:              			xReturn = pdFAIL;
2892:              		}
2893:              
2894:              		return xReturn;
2895:              	}
2896:              
2897:              #endif /* configUSE_APPLICATION_TASK_TAG */
2898:              /*-----------------------------------------------------------*/
2899:              
2900:              void vTaskSwitchContext( void )
2901:              {
000AAE  FA0014     LNK #0x14
2902:              	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000AB0  E20868     CP0 uxSchedulerSuspended
000AB2  320003     BRA Z, .L42
2903:              	{
2904:              		/* The scheduler is currently suspended - do not allow a context
2905:              		switch. */
2906:              		xYieldPending = pdTRUE;
000AB4  200010     MOV #0x1, W0
000AB6  8842F0     MOV W0, xYieldPending
000AB8  370035     BRA .L41, .LBE3
2907:              	}
2908:              	else
2909:              	{
2910:              		xYieldPending = pdFALSE;
000ABA  EF285E     CLR xYieldPending
2911:              		traceTASK_SWITCHED_OUT();
2912:              
2913:              		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2914:              		{
2915:              				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2916:              					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2917:              				#else
2918:              					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2919:              				#endif
2920:              
2921:              				/* Add the amount of time the task has been running to the
2922:              				accumulated time so far.  The time the task started running was
2923:              				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2924:              				protection here so count values are only valid until the timer
2925:              				overflows.  The guard against negative values is to protect
2926:              				against suspect run time stat counter implementations - which
2927:              				are provided by the application, not the kernel. */
2928:              				if( ulTotalRunTime > ulTaskSwitchedInTime )
2929:              				{
2930:              					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2931:              				}
2932:              				else
2933:              				{
2934:              					mtCOVERAGE_TEST_MARKER();
2935:              				}
2936:              				ulTaskSwitchedInTime = ulTotalRunTime;
2937:              		}
2938:              		#endif /* configGENERATE_RUN_TIME_STATS */
2939:              
2940:              		/* Check for stack overflow, if configured. */
2941:              		taskCHECK_FOR_STACK_OVERFLOW();
000ABC  804280     MOV pxCurrentTCB, W0
000ABE  900870     MOV [W0+30], W0
000AC0  5780F4     SUB W15, #0x14, W1
000AC2  288592     MOV #0x8859, W2
000AC4  090013     REPEAT #0x13
000AC6  7858B2     MOV.B [W2++], [W1++]
000AC8  500074     SUB W0, #0x14, W0
000ACA  200142     MOV #0x14, W2
000ACC  5780F4     SUB W15, #0x14, W1
000ACE  02079A     CALL _memcmp
000AD0  000000     NOP
000AD2  E00000     CP0 W0
000AD4  320005     BRA Z, .L44, .LBE2, .LBB3
000AD6  804281     MOV pxCurrentTCB, W1
000AD8  804280     MOV pxCurrentTCB, W0
000ADA  4080FA     ADD W1, #0x1A, W1
000ADC  022660     CALL vApplicationStackOverflowHook
000ADE  000000     NOP
2942:              
2943:              		/* Before the currently running task is switched out, save its errno. */
2944:              		#if( configUSE_POSIX_ERRNO == 1 )
2945:              		{
2946:              			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
2947:              		}
2948:              		#endif
2949:              
2950:              		/* Select a new task to run using either the generic C or port
2951:              		optimised asm code. */
2952:              		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000AE0  8042C0     MOV uxTopReadyPriority, W0
000AE2  B9016A     MUL.SU W0, #10, W2
000AE4  21CAC1     MOV #0x1CAC, W1
000AE6  7900E1     MOV [W1+W2], W1
000AE8  E00001     CP0 W1
000AEA  3A0006     BRA NZ, .L45, .LBB4
000AEC  21CAC4     MOV #0x1CAC, W4
000AEE  E90000     DEC W0, W0
000AF0  B9016A     MUL.SU W0, #10, W2
000AF2  7900E4     MOV [W4+W2], W1
000AF4  E00001     CP0 W1
000AF6  32FFFB     BRA Z, .L48
000AF8  B9016A     MUL.SU W0, #10, W2
000AFA  E88182     INC2 W2, W3
000AFC  21CAC1     MOV #0x1CAC, W1
000AFE  7981E1     MOV [W1+W3], W3
000B00  900193     MOV [W3+2], W3
000B02  408202     ADD W1, W2, W4
000B04  980213     MOV W3, [W4+2]
000B06  410164     ADD W2, #0x4, W2
000B08  410081     ADD W2, W1, W1
000B0A  518F81     SUB W3, W1, [W15]
000B0C  3A0004     BRA NZ, .L47
000B0E  B9026A     MUL.SU W0, #10, W4
000B10  21CAE1     MOV #0x1CAE, W1
000B12  900193     MOV [W3+2], W3
000B14  7A3083     MOV W3, [W1+W4]
000B16  B9016A     MUL.SU W0, #10, W2
000B18  E88082     INC2 W2, W1
000B1A  21CAC2     MOV #0x1CAC, W2
000B1C  7880E2     MOV [W2+W1], W1
000B1E  9000B1     MOV [W1+6], W1
000B20  884281     MOV W1, pxCurrentTCB
000B22  8842C0     MOV W0, uxTopReadyPriority
2953:              		traceTASK_SWITCHED_IN();
2954:              
2955:              		/* After the new task is switched in, update the global errno. */
2956:              		#if( configUSE_POSIX_ERRNO == 1 )
2957:              		{
2958:              			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
2959:              		}
2960:              		#endif
2961:              
2962:              		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2963:              		{
2964:              			/* Switch Newlib's _impure_ptr variable to point to the _reent
2965:              			structure specific to this task. */
2966:              			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2967:              		}
2968:              		#endif /* configUSE_NEWLIB_REENTRANT */
2969:              	}
2970:              }
000B24  FA8000     ULNK
000B26  060000     RETURN
2971:              /*-----------------------------------------------------------*/
2972:              
2973:              void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2974:              {
0012F0  781F88     MOV W8, [W15++]
0012F2  780401     MOV W1, W8
2975:              	configASSERT( pxEventList );
2976:              
2977:              	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2978:              	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2979:              
2980:              	/* Place the event list item of the TCB in the appropriate event list.
2981:              	This is placed in the list in priority order so the highest priority task
2982:              	is the first to be woken by the event.  The queue that contains the event
2983:              	list is locked, preventing simultaneous access from interrupts. */
2984:              	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
0012F4  804281     MOV pxCurrentTCB, W1
0012F6  4080EC     ADD W1, #0xC, W1
0012F8  022762     CALL vListInsert
0012FA  000000     NOP
2985:              
2986:              	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
0012FC  200011     MOV #0x1, W1
0012FE  780008     MOV W8, W0
001300  07FF3B     RCALL prvAddCurrentTaskToDelayedList
2987:              }
001302  78044F     MOV [--W15], W8
001304  060000     RETURN
2988:              /*-----------------------------------------------------------*/
2989:              
2990:              void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
2991:              {
0012D4  781F88     MOV W8, [W15++]
0012D6  780402     MOV W2, W8
2992:              	configASSERT( pxEventList );
2993:              
2994:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2995:              	the event groups implementation. */
2996:              	configASSERT( uxSchedulerSuspended != 0 );
2997:              
2998:              	/* Store the item value in the event list item.  It is safe to access the
2999:              	event list item here as interrupts won't access the event list item of a
3000:              	task that is not in the Blocked state. */
3001:              	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
0012D8  804282     MOV pxCurrentTCB, W2
0012DA  A0F001     BSET W1, #15
0012DC  980161     MOV W1, [W2+12]
3002:              
3003:              	/* Place the event list item of the TCB at the end of the appropriate event
3004:              	list.  It is safe to access the event list here because it is part of an
3005:              	event group implementation - and interrupts don't access event groups
3006:              	directly (instead they access them indirectly by pending function calls to
3007:              	the task level). */
3008:              	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
0012DE  804281     MOV pxCurrentTCB, W1
0012E0  4080EC     ADD W1, #0xC, W1
0012E2  02274E     CALL vListInsertEnd
0012E4  000000     NOP
3009:              
3010:              	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
0012E6  200011     MOV #0x1, W1
0012E8  780008     MOV W8, W0
0012EA  07FF46     RCALL prvAddCurrentTaskToDelayedList
3011:              }
0012EC  78044F     MOV [--W15], W8
0012EE  060000     RETURN
3012:              /*-----------------------------------------------------------*/
3013:              
3014:              #if( configUSE_TIMERS == 1 )
3015:              
3016:              	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
3017:              	{
3018:              		configASSERT( pxEventList );
3019:              
3020:              		/* This function should not be called by application code hence the
3021:              		'Restricted' in its name.  It is not part of the public API.  It is
3022:              		designed for use by kernel code, and has special calling requirements -
3023:              		it should be called with the scheduler suspended. */
3024:              
3025:              
3026:              		/* Place the event list item of the TCB in the appropriate event list.
3027:              		In this case it is assume that this is the only task that is going to
3028:              		be waiting on this event list, so the faster vListInsertEnd() function
3029:              		can be used in place of vListInsert. */
3030:              		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3031:              
3032:              		/* If the task should block indefinitely then set the block time to a
3033:              		value that will be recognised as an indefinite delay inside the
3034:              		prvAddCurrentTaskToDelayedList() function. */
3035:              		if( xWaitIndefinitely != pdFALSE )
3036:              		{
3037:              			xTicksToWait = portMAX_DELAY;
3038:              		}
3039:              
3040:              		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3041:              		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3042:              	}
3043:              
3044:              #endif /* configUSE_TIMERS */
3045:              /*-----------------------------------------------------------*/
3046:              
3047:              BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3048:              {
000B28  BE9F88     MOV.D W8, [W15++]
3049:              TCB_t *pxUnblockedTCB;
3050:              BaseType_t xReturn;
3051:              
3052:              	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3053:              	called from a critical section within an ISR. */
3054:              
3055:              	/* The event list is sorted in priority order, so the first in the list can
3056:              	be removed as it is known to be the highest priority.  Remove the TCB from
3057:              	the delayed list, and add it to the ready list.
3058:              
3059:              	If an event is for a queue that is locked then this function will never
3060:              	get called - the lock count on the queue will get modified instead.  This
3061:              	means exclusive access to the event list is guaranteed here.
3062:              
3063:              	This function assumes that a check has already been made to ensure that
3064:              	pxEventList is not empty. */
3065:              	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000B2A  900030     MOV [W0+6], W0
000B2C  9004B0     MOV [W0+6], W9
3066:              	configASSERT( pxUnblockedTCB );
3067:              	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000B2E  44846C     ADD W9, #0xC, W8
000B30  780008     MOV W8, W0
000B32  022788     CALL uxListRemove
000B34  000000     NOP
3068:              
3069:              	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000B36  E20868     CP0 uxSchedulerSuspended
000B38  3A000F     BRA NZ, .L51
3070:              	{
3071:              		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000B3A  E88409     INC2 W9, W8
000B3C  780008     MOV W8, W0
000B3E  022788     CALL uxListRemove
000B40  000000     NOP
3072:              		prvAddTaskToReadyList( pxUnblockedTCB );
000B42  900839     MOV [W9+22], W0
000B44  E30858     CP uxTopReadyPriority
000B46  310001     BRA C, .L52
000B48  8842C0     MOV W0, uxTopReadyPriority
000B4A  B9006A     MUL.SU W0, #10, W0
000B4C  21CAC2     MOV #0x1CAC, W2
000B4E  410000     ADD W2, W0, W0
000B50  780088     MOV W8, W1
000B52  02274E     CALL vListInsertEnd
000B54  000000     NOP
000B56  370004     BRA .L53
3073:              	}
3074:              	else
3075:              	{
3076:              		/* The delayed and ready lists cannot be accessed, so hold this task
3077:              		pending until the scheduler is resumed. */
3078:              		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
000B58  780088     MOV W8, W1
000B5A  21CE80     MOV #0x1CE8, W0
000B5C  02274E     CALL vListInsertEnd
000B5E  000000     NOP
3079:              	}
3080:              
3081:              	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000B60  804280     MOV pxCurrentTCB, W0
000B62  900939     MOV [W9+22], W2
000B64  9008B0     MOV [W0+22], W1
000B68  510F81     SUB W2, W1, [W15]
000B6A  360002     BRA LEU, .L54
3082:              	{
3083:              		/* Return true if the task removed from the event list has a higher
3084:              		priority than the calling task.  This allows the calling task to know if
3085:              		it should force a context switch now. */
3086:              		xReturn = pdTRUE;
3087:              
3088:              		/* Mark that a yield is pending in case the user is not using the
3089:              		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3090:              		xYieldPending = pdTRUE;
000B6C  200010     MOV #0x1, W0
000B6E  8842F0     MOV W0, xYieldPending
3091:              	}
3092:              	else
3093:              	{
3094:              		xReturn = pdFALSE;
000B66  EB0000     CLR W0
3095:              	}
3096:              
3097:              	#if( configUSE_TICKLESS_IDLE != 0 )
3098:              	{
3099:              		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3100:              		might be set to the blocked task's time out time.  If the task is
3101:              		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3102:              		normally left unchanged, because it is automatically reset to a new
3103:              		value when the tick count equals xNextTaskUnblockTime.  However if
3104:              		tickless idling is used it might be more important to enter sleep mode
3105:              		at the earliest possible time - so reset xNextTaskUnblockTime here to
3106:              		ensure it is updated at the earliest possible time. */
3107:              		prvResetNextTaskUnblockTime();
3108:              	}
3109:              	#endif
3110:              
3111:              	return xReturn;
3112:              }
000B70  BE044F     MOV.D [--W15], W8
000B72  060000     RETURN
3113:              /*-----------------------------------------------------------*/
3114:              
3115:              void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3116:              {
000B74  BE9F88     MOV.D W8, [W15++]
3117:              TCB_t *pxUnblockedTCB;
3118:              
3119:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3120:              	the event flags implementation. */
3121:              	configASSERT( uxSchedulerSuspended != pdFALSE );
3122:              
3123:              	/* Store the new item value in the event list. */
3124:              	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000B76  A0F001     BSET W1, #15
000B78  780801     MOV W1, [W0]
3125:              
3126:              	/* Remove the event list form the event flag.  Interrupts do not access
3127:              	event flags. */
3128:              	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000B7A  900430     MOV [W0+6], W8
3129:              	configASSERT( pxUnblockedTCB );
3130:              	( void ) uxListRemove( pxEventListItem );
000B7C  022788     CALL uxListRemove
000B7E  000000     NOP
3131:              
3132:              	/* Remove the task from the delayed list and add it to the ready list.  The
3133:              	scheduler is suspended so interrupts will not be accessing the ready
3134:              	lists. */
3135:              	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000B80  E88488     INC2 W8, W9
000B82  780009     MOV W9, W0
000B84  022788     CALL uxListRemove
000B86  000000     NOP
3136:              	prvAddTaskToReadyList( pxUnblockedTCB );
000B88  900838     MOV [W8+22], W0
000B8A  E30858     CP uxTopReadyPriority
000B8C  310001     BRA C, .L57
000B8E  8842C0     MOV W0, uxTopReadyPriority
000B90  B9006A     MUL.SU W0, #10, W0
000B92  21CAC2     MOV #0x1CAC, W2
000B94  410000     ADD W2, W0, W0
000B96  780089     MOV W9, W1
000B98  02274E     CALL vListInsertEnd
000B9A  000000     NOP
3137:              
3138:              	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000B9C  804280     MOV pxCurrentTCB, W0
000B9E  9008B8     MOV [W8+22], W1
000BA0  900830     MOV [W0+22], W0
000BA2  508F80     SUB W1, W0, [W15]
000BA4  360002     BRA LEU, .L56
3139:              	{
3140:              		/* The unblocked task has a priority above that of the calling task, so
3141:              		a context switch is required.  This function is called with the
3142:              		scheduler suspended so xYieldPending is set so the context switch
3143:              		occurs immediately that the scheduler is resumed (unsuspended). */
3144:              		xYieldPending = pdTRUE;
000BA6  200010     MOV #0x1, W0
000BA8  8842F0     MOV W0, xYieldPending
3145:              	}
3146:              }
000BAA  BE044F     MOV.D [--W15], W8
000BAC  060000     RETURN
3147:              /*-----------------------------------------------------------*/
3148:              
3149:              void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3150:              {
000BAE  781F88     MOV W8, [W15++]
000BB0  780400     MOV W0, W8
3151:              	configASSERT( pxTimeOut );
3152:              	taskENTER_CRITICAL();
000BB2  0225F4     CALL vPortEnterCritical
000BB4  000000     NOP
3153:              	{
3154:              		pxTimeOut->xOverflowCount = xNumOfOverflows;
000BB6  804300     MOV xNumOfOverflows, W0
000BB8  780C00     MOV W0, [W8]
3155:              		pxTimeOut->xTimeOnEntering = xTickCount;
000BBA  8042B0     MOV xTickCount, W0
000BBC  980410     MOV W0, [W8+2]
3156:              	}
3157:              	taskEXIT_CRITICAL();
000BBE  022604     CALL vPortExitCritical
000BC0  000000     NOP
3158:              }
000BC2  78044F     MOV [--W15], W8
000BC4  060000     RETURN
3159:              /*-----------------------------------------------------------*/
3160:              
3161:              void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3162:              {
3163:              	/* For internal use only as it does not use a critical section. */
3164:              	pxTimeOut->xOverflowCount = xNumOfOverflows;
000BC6  804301     MOV xNumOfOverflows, W1
000BC8  780801     MOV W1, [W0]
3165:              	pxTimeOut->xTimeOnEntering = xTickCount;
000BCA  8042B1     MOV xTickCount, W1
000BCC  980011     MOV W1, [W0+2]
3166:              }
000BCE  060000     RETURN
3167:              /*-----------------------------------------------------------*/
3168:              
3169:              BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3170:              {
000BD0  BE9F88     MOV.D W8, [W15++]
000BD2  781F8A     MOV W10, [W15++]
000BD4  780480     MOV W0, W9
000BD6  780501     MOV W1, W10
3171:              BaseType_t xReturn;
3172:              
3173:              	configASSERT( pxTimeOut );
3174:              	configASSERT( pxTicksToWait );
3175:              
3176:              	taskENTER_CRITICAL();
000BD8  0225F4     CALL vPortEnterCritical
000BDA  000000     NOP
3177:              	{
3178:              		/* Minor optimisation.  The tick count cannot change in this block. */
3179:              		const TickType_t xConstTickCount = xTickCount;
000BDC  8042B2     MOV xTickCount, W2
3180:              		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
000BDE  900099     MOV [W9+2], W1
000BF6  510081     SUB W2, W1, W1
3181:              
3182:              		#if( INCLUDE_xTaskAbortDelay == 1 )
3183:              			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3184:              			{
3185:              				/* The delay was aborted, which is not the same as a time out,
3186:              				but has the same result. */
3187:              				pxCurrentTCB->ucDelayAborted = pdFALSE;
3188:              				xReturn = pdTRUE;
3189:              			}
3190:              			else
3191:              		#endif
3192:              
3193:              		#if ( INCLUDE_vTaskSuspend == 1 )
3194:              			if( *pxTicksToWait == portMAX_DELAY )
000BE0  78001A     MOV [W10], W0
000BE4  400FE1     ADD W0, #0x1, [W15]
000BE6  320011     BRA Z, .L62, .LBE5
3195:              			{
3196:              				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3197:              				specified is the maximum block time then the task should block
3198:              				indefinitely, and therefore never time out. */
3199:              				xReturn = pdFALSE;
000BE2  EB0400     CLR W8
3200:              			}
3201:              			else
3202:              		#endif
3203:              
3204:              		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
000BE8  780199     MOV [W9], W3
000BEA  804304     MOV xNumOfOverflows, W4
000BEC  520F83     SUB W4, W3, [W15]
000BEE  320003     BRA Z, .L63
000BF2  510F81     SUB W2, W1, [W15]
000BF4  31000A     BRA C, .L62, .LBE5
3205:              		{
3206:              			/* The tick count is greater than the time at which
3207:              			vTaskSetTimeout() was called, but has also overflowed since
3208:              			vTaskSetTimeOut() was called.  It must have wrapped all the way
3209:              			around and gone past again. This passed since vTaskSetTimeout()
3210:              			was called. */
3211:              			xReturn = pdTRUE;
000BF0  200018     MOV #0x1, W8
3212:              		}
3213:              		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
000BF8  508F80     SUB W1, W0, [W15]
000BFA  310005     BRA C, .L64
3214:              		{
3215:              			/* Not a genuine timeout. Adjust parameters for time remaining. */
3216:              			*pxTicksToWait -= xElapsedTime;
000BFC  500D01     SUB W0, W1, [W10]
3217:              			vTaskInternalSetTimeOutState( pxTimeOut );
000BFE  780009     MOV W9, W0
000C00  07FFE2     RCALL vTaskInternalSetTimeOutState
3218:              			xReturn = pdFALSE;
000C02  EB0400     CLR W8
000C04  370002     BRA .L62, .LBE5
3219:              		}
3220:              		else
3221:              		{
3222:              			*pxTicksToWait = 0;
000C06  EB0D00     CLR [W10]
3223:              			xReturn = pdTRUE;
000C08  200018     MOV #0x1, W8
3224:              		}
3225:              	}
3226:              	taskEXIT_CRITICAL();
000C0A  022604     CALL vPortExitCritical
000C0C  000000     NOP
3227:              
3228:              	return xReturn;
3229:              }
000C0E  780008     MOV W8, W0
000C10  78054F     MOV [--W15], W10
000C12  BE044F     MOV.D [--W15], W8
000C14  060000     RETURN
3230:              /*-----------------------------------------------------------*/
3231:              
3232:              void vTaskMissedYield( void )
3233:              {
3234:              	xYieldPending = pdTRUE;
000C16  200010     MOV #0x1, W0
000C18  8842F0     MOV W0, xYieldPending
3235:              }
000C1A  060000     RETURN
3236:              /*-----------------------------------------------------------*/
3237:              
3238:              #if ( configUSE_TRACE_FACILITY == 1 )
3239:              
3240:              	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3241:              	{
3242:              	UBaseType_t uxReturn;
3243:              	TCB_t const *pxTCB;
3244:              
3245:              		if( xTask != NULL )
3246:              		{
3247:              			pxTCB = xTask;
3248:              			uxReturn = pxTCB->uxTaskNumber;
3249:              		}
3250:              		else
3251:              		{
3252:              			uxReturn = 0U;
3253:              		}
3254:              
3255:              		return uxReturn;
3256:              	}
3257:              
3258:              #endif /* configUSE_TRACE_FACILITY */
3259:              /*-----------------------------------------------------------*/
3260:              
3261:              #if ( configUSE_TRACE_FACILITY == 1 )
3262:              
3263:              	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3264:              	{
3265:              	TCB_t * pxTCB;
3266:              
3267:              		if( xTask != NULL )
3268:              		{
3269:              			pxTCB = xTask;
3270:              			pxTCB->uxTaskNumber = uxHandle;
3271:              		}
3272:              	}
3273:              
3274:              #endif /* configUSE_TRACE_FACILITY */
3275:              
3276:              /*
3277:               * -----------------------------------------------------------
3278:               * The Idle task.
3279:               * ----------------------------------------------------------
3280:               *
3281:               * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3282:               * language extensions.  The equivalent prototype for this function is:
3283:               *
3284:               * void prvIdleTask( void *pvParameters );
3285:               *
3286:               */
3287:              static portTASK_FUNCTION( prvIdleTask, pvParameters )
3288:              {
000D7A  781F88     MOV W8, [W15++]
3289:              	/* Stop warnings. */
3290:              	( void ) pvParameters;
3291:              
3292:              	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3293:              	SCHEDULER IS STARTED. **/
3294:              
3295:              	/* In case a task that has a secure context deletes itself, in which case
3296:              	the idle task is responsible for deleting the task's secure context, if
3297:              	any. */
3298:              	portTASK_CALLS_SECURE_FUNCTIONS();
3299:              
3300:              	for( ;; )
3301:              	{
3302:              		/* See if any tasks have deleted themselves - if so then the idle task
3303:              		is responsible for freeing the deleted task's TCB and stack. */
3304:              		prvCheckTasksWaitingTermination();
000D7C  21CAC8     MOV #0x1CAC, W8
000D7E  07FFE9     RCALL prvCheckTasksWaitingTermination
3305:              
3306:              		#if ( configUSE_PREEMPTION == 0 )
3307:              		{
3308:              			/* If we are not using preemption we keep forcing a task switch to
3309:              			see if any other task has become available.  If we are using
3310:              			preemption we don't need to do this as any task becoming available
3311:              			will automatically get the processor anyway. */
3312:              			taskYIELD();
3313:              		}
3314:              		#endif /* configUSE_PREEMPTION */
3315:              
3316:              		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3317:              		{
3318:              			/* When using preemption tasks of equal priority will be
3319:              			timesliced.  If a task that is sharing the idle priority is ready
3320:              			to run then the idle task should yield before the end of the
3321:              			timeslice.
3322:              
3323:              			A critical region is not required here as we are just reading from
3324:              			the list, and an occasional incorrect value will not matter.  If
3325:              			the ready list at the idle priority contains more than one task
3326:              			then a task other than the idle task is ready to execute. */
3327:              			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000D80  200010     MOV #0x1, W0
000D82  100F98     SUBR W0, [W8], [W15]
000D84  360003     BRA LEU, .L89, .LBB7
3328:              			{
3329:              				taskYIELD();
000D86  02286C     CALL .Letext0, .LFE2, _vPortYield
000D88  000000     NOP
000D8A  000000     NOP
3330:              			}
3331:              			else
3332:              			{
3333:              				mtCOVERAGE_TEST_MARKER();
3334:              			}
3335:              		}
3336:              		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3337:              
3338:              		#if ( configUSE_IDLE_HOOK == 1 )
3339:              		{
3340:              			extern void vApplicationIdleHook( void );
3341:              
3342:              			/* Call the user defined function from within the idle task.  This
3343:              			allows the application designer to add background functionality
3344:              			without the overhead of a separate task.
3345:              			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3346:              			CALL A FUNCTION THAT MIGHT BLOCK. */
3347:              			vApplicationIdleHook();
000D8C  02265A     CALL vApplicationIdleHook
000D8E  000000     NOP
3348:              		}
3349:              		#endif /* configUSE_IDLE_HOOK */
3350:              
3351:              		/* This conditional compilation should use inequality to 0, not equality
3352:              		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3353:              		user defined low power mode	implementations require
3354:              		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3355:              		#if ( configUSE_TICKLESS_IDLE != 0 )
3356:              		{
3357:              		TickType_t xExpectedIdleTime;
3358:              
3359:              			/* It is not desirable to suspend then resume the scheduler on
3360:              			each iteration of the idle task.  Therefore, a preliminary
3361:              			test of the expected idle time is performed without the
3362:              			scheduler suspended.  The result here is not necessarily
3363:              			valid. */
3364:              			xExpectedIdleTime = prvGetExpectedIdleTime();
3365:              
3366:              			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3367:              			{
3368:              				vTaskSuspendAll();
3369:              				{
3370:              					/* Now the scheduler is suspended, the expected idle
3371:              					time can be sampled again, and this time its value can
3372:              					be used. */
3373:              					configASSERT( xNextTaskUnblockTime >= xTickCount );
3374:              					xExpectedIdleTime = prvGetExpectedIdleTime();
3375:              
3376:              					/* Define the following macro to set xExpectedIdleTime to 0
3377:              					if the application does not want
3378:              					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3379:              					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3380:              
3381:              					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3382:              					{
3383:              						traceLOW_POWER_IDLE_BEGIN();
3384:              						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3385:              						traceLOW_POWER_IDLE_END();
3386:              					}
3387:              					else
3388:              					{
3389:              						mtCOVERAGE_TEST_MARKER();
3390:              					}
3391:              				}
3392:              				( void ) xTaskResumeAll();
3393:              			}
3394:              			else
3395:              			{
3396:              				mtCOVERAGE_TEST_MARKER();
3397:              			}
3398:              		}
3399:              		#endif /* configUSE_TICKLESS_IDLE */
3400:              	}
000D90  37FFF6     BRA .L90
3401:              }
3402:              /*-----------------------------------------------------------*/
3403:              
3404:              #if( configUSE_TICKLESS_IDLE != 0 )
3405:              
3406:              	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3407:              	{
3408:              	/* The idle task exists in addition to the application tasks. */
3409:              	const UBaseType_t uxNonApplicationTasks = 1;
3410:              	eSleepModeStatus eReturn = eStandardSleep;
3411:              
3412:              		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3413:              		{
3414:              			/* A task was made ready while the scheduler was suspended. */
3415:              			eReturn = eAbortSleep;
3416:              		}
3417:              		else if( xYieldPending != pdFALSE )
3418:              		{
3419:              			/* A yield was pended while the scheduler was suspended. */
3420:              			eReturn = eAbortSleep;
3421:              		}
3422:              		else
3423:              		{
3424:              			/* If all the tasks are in the suspended list (which might mean they
3425:              			have an infinite block time rather than actually being suspended)
3426:              			then it is safe to turn all clocks off and just wait for external
3427:              			interrupts. */
3428:              			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
3429:              			{
3430:              				eReturn = eNoTasksWaitingTimeout;
3431:              			}
3432:              			else
3433:              			{
3434:              				mtCOVERAGE_TEST_MARKER();
3435:              			}
3436:              		}
3437:              
3438:              		return eReturn;
3439:              	}
3440:              
3441:              #endif /* configUSE_TICKLESS_IDLE */
3442:              /*-----------------------------------------------------------*/
3443:              
3444:              #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3445:              
3446:              	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
3447:              	{
3448:              	TCB_t *pxTCB;
3449:              
3450:              		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3451:              		{
3452:              			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3453:              			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3454:              		}
3455:              	}
3456:              
3457:              #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3458:              /*-----------------------------------------------------------*/
3459:              
3460:              #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3461:              
3462:              	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3463:              	{
3464:              	void *pvReturn = NULL;
3465:              	TCB_t *pxTCB;
3466:              
3467:              		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3468:              		{
3469:              			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3470:              			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3471:              		}
3472:              		else
3473:              		{
3474:              			pvReturn = NULL;
3475:              		}
3476:              
3477:              		return pvReturn;
3478:              	}
3479:              
3480:              #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3481:              /*-----------------------------------------------------------*/
3482:              
3483:              #if ( portUSING_MPU_WRAPPERS == 1 )
3484:              
3485:              	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3486:              	{
3487:              	TCB_t *pxTCB;
3488:              
3489:              		/* If null is passed in here then we are modifying the MPU settings of
3490:              		the calling task. */
3491:              		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3492:              
3493:              		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3494:              	}
3495:              
3496:              #endif /* portUSING_MPU_WRAPPERS */
3497:              /*-----------------------------------------------------------*/
3498:              
3499:              static void prvInitialiseTaskLists( void )
3500:              {
000C1C  BE9F88     MOV.D W8, [W15++]
3501:              UBaseType_t uxPriority;
3502:              
3503:              	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
000C1E  EB0400     CLR W8
000C2A  E80408     INC W8, W8
000C2C  540FE4     SUB W8, #0x4, [W15]
000C2E  3AFFF9     BRA NZ, .L69
3504:              	{
3505:              		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000C20  21CAC9     MOV #0x1CAC, W9
000C22  B9406A     MUL.SU W8, #10, W0
000C24  448000     ADD W9, W0, W0
000C26  022738     CALL vListInitialise
000C28  000000     NOP
3506:              	}
3507:              
3508:              	vListInitialise( &xDelayedTaskList1 );
000C30  21CD40     MOV #0x1CD4, W0
000C32  022738     CALL vListInitialise
000C34  000000     NOP
3509:              	vListInitialise( &xDelayedTaskList2 );
000C36  21CDE0     MOV #0x1CDE, W0
000C38  022738     CALL vListInitialise
000C3A  000000     NOP
3510:              	vListInitialise( &xPendingReadyList );
000C3C  21CE80     MOV #0x1CE8, W0
000C3E  022738     CALL vListInitialise
000C40  000000     NOP
3511:              
3512:              	#if ( INCLUDE_vTaskDelete == 1 )
3513:              	{
3514:              		vListInitialise( &xTasksWaitingTermination );
000C42  21CF20     MOV #0x1CF2, W0
000C44  022738     CALL vListInitialise
000C46  000000     NOP
3515:              	}
3516:              	#endif /* INCLUDE_vTaskDelete */
3517:              
3518:              	#if ( INCLUDE_vTaskSuspend == 1 )
3519:              	{
3520:              		vListInitialise( &xSuspendedTaskList );
000C48  21CFC0     MOV #0x1CFC, W0
000C4A  022738     CALL vListInitialise
000C4C  000000     NOP
3521:              	}
3522:              	#endif /* INCLUDE_vTaskSuspend */
3523:              
3524:              	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3525:              	using list2. */
3526:              	pxDelayedTaskList = &xDelayedTaskList1;
000C4E  21CD40     MOV #0x1CD4, W0
000C50  884350     MOV W0, pxDelayedTaskList
3527:              	pxOverflowDelayedTaskList = &xDelayedTaskList2;
000C52  21CDE0     MOV #0x1CDE, W0
000C54  884360     MOV W0, pxOverflowDelayedTaskList
3528:              }
000C56  BE044F     MOV.D [--W15], W8
000C58  060000     RETURN
3529:              /*-----------------------------------------------------------*/
3530:              
3531:              static void prvCheckTasksWaitingTermination( void )
3532:              {
000D52  781F88     MOV W8, [W15++]
3533:              
3534:              	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3535:              
3536:              	#if ( INCLUDE_vTaskDelete == 1 )
3537:              	{
3538:              		TCB_t *pxTCB;
3539:              
3540:              		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3541:              		being called too often in the idle task. */
3542:              		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
000D54  E20852     CP0 uxDeletedTasksWaitingCleanUp
000D56  32000F     BRA Z, .L83, .LBE6
000D72  E20852     CP0 uxDeletedTasksWaitingCleanUp
000D74  3AFFF1     BRA NZ, .L86
3543:              		{
3544:              			taskENTER_CRITICAL();
000D58  0225F4     CALL vPortEnterCritical
000D5A  000000     NOP
3545:              			{
3546:              				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000D5C  80E7C0     MOV 0x1CF8, W0
000D5E  900430     MOV [W0+6], W8
3547:              				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000D60  E88008     INC2 W8, W0
000D62  022788     CALL uxListRemove
000D64  000000     NOP
3548:              				--uxCurrentNumberOfTasks;
000D66  ED2854     DEC uxCurrentNumberOfTasks
3549:              				--uxDeletedTasksWaitingCleanUp;
000D68  ED2852     DEC uxDeletedTasksWaitingCleanUp
3550:              			}
3551:              			taskEXIT_CRITICAL();
000D6A  022604     CALL vPortExitCritical
000D6C  000000     NOP
3552:              
3553:              			prvDeleteTCB( pxTCB );
000D6E  780008     MOV W8, W0
000D70  07FFE6     RCALL prvDeleteTCB
3554:              		}
3555:              	}
3556:              	#endif /* INCLUDE_vTaskDelete */
3557:              }
000D76  78044F     MOV [--W15], W8
000D78  060000     RETURN
3558:              /*-----------------------------------------------------------*/
3559:              
3560:              #if( configUSE_TRACE_FACILITY == 1 )
3561:              
3562:              	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
3563:              	{
3564:              	TCB_t *pxTCB;
3565:              
3566:              		/* xTask is NULL then get the state of the calling task. */
3567:              		pxTCB = prvGetTCBFromHandle( xTask );
3568:              
3569:              		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3570:              		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3571:              		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3572:              		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3573:              		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3574:              
3575:              		#if ( configUSE_MUTEXES == 1 )
3576:              		{
3577:              			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3578:              		}
3579:              		#else
3580:              		{
3581:              			pxTaskStatus->uxBasePriority = 0;
3582:              		}
3583:              		#endif
3584:              
3585:              		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3586:              		{
3587:              			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3588:              		}
3589:              		#else
3590:              		{
3591:              			pxTaskStatus->ulRunTimeCounter = 0;
3592:              		}
3593:              		#endif
3594:              
3595:              		/* Obtaining the task state is a little fiddly, so is only done if the
3596:              		value of eState passed into this function is eInvalid - otherwise the
3597:              		state is just set to whatever is passed in. */
3598:              		if( eState != eInvalid )
3599:              		{
3600:              			if( pxTCB == pxCurrentTCB )
3601:              			{
3602:              				pxTaskStatus->eCurrentState = eRunning;
3603:              			}
3604:              			else
3605:              			{
3606:              				pxTaskStatus->eCurrentState = eState;
3607:              
3608:              				#if ( INCLUDE_vTaskSuspend == 1 )
3609:              				{
3610:              					/* If the task is in the suspended list then there is a
3611:              					chance it is actually just blocked indefinitely - so really
3612:              					it should be reported as being in the Blocked state. */
3613:              					if( eState == eSuspended )
3614:              					{
3615:              						vTaskSuspendAll();
3616:              						{
3617:              							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3618:              							{
3619:              								pxTaskStatus->eCurrentState = eBlocked;
3620:              							}
3621:              						}
3622:              						( void ) xTaskResumeAll();
3623:              					}
3624:              				}
3625:              				#endif /* INCLUDE_vTaskSuspend */
3626:              			}
3627:              		}
3628:              		else
3629:              		{
3630:              			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3631:              		}
3632:              
3633:              		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3634:              		parameter is provided to allow it to be skipped. */
3635:              		if( xGetFreeStackSpace != pdFALSE )
3636:              		{
3637:              			#if ( portSTACK_GROWTH > 0 )
3638:              			{
3639:              				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
3640:              			}
3641:              			#else
3642:              			{
3643:              				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
3644:              			}
3645:              			#endif
3646:              		}
3647:              		else
3648:              		{
3649:              			pxTaskStatus->usStackHighWaterMark = 0;
3650:              		}
3651:              	}
3652:              
3653:              #endif /* configUSE_TRACE_FACILITY */
3654:              /*-----------------------------------------------------------*/
3655:              
3656:              #if ( configUSE_TRACE_FACILITY == 1 )
3657:              
3658:              	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
3659:              	{
3660:              	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3661:              	UBaseType_t uxTask = 0;
3662:              
3663:              		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3664:              		{
3665:              			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
3666:              
3667:              			/* Populate an TaskStatus_t structure within the
3668:              			pxTaskStatusArray array for each task that is referenced from
3669:              			pxList.  See the definition of TaskStatus_t in task.h for the
3670:              			meaning of each TaskStatus_t structure member. */
3671:              			do
3672:              			{
3673:              				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
3674:              				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3675:              				uxTask++;
3676:              			} while( pxNextTCB != pxFirstTCB );
3677:              		}
3678:              		else
3679:              		{
3680:              			mtCOVERAGE_TEST_MARKER();
3681:              		}
3682:              
3683:              		return uxTask;
3684:              	}
3685:              
3686:              #endif /* configUSE_TRACE_FACILITY */
3687:              /*-----------------------------------------------------------*/
3688:              
3689:              #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3690:              
3691:              	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3692:              	{
3693:              	uint32_t ulCount = 0U;
3694:              
3695:              		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3696:              		{
3697:              			pucStackByte -= portSTACK_GROWTH;
3698:              			ulCount++;
3699:              		}
3700:              
3701:              		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
3702:              
3703:              		return ( configSTACK_DEPTH_TYPE ) ulCount;
3704:              	}
3705:              
3706:              #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3707:              /*-----------------------------------------------------------*/
3708:              
3709:              #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3710:              
3711:              	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3712:              	{
3713:              	TCB_t *pxTCB;
3714:              	uint8_t *pucEndOfStack;
3715:              	UBaseType_t uxReturn;
3716:              
3717:              		pxTCB = prvGetTCBFromHandle( xTask );
3718:              
3719:              		#if portSTACK_GROWTH < 0
3720:              		{
3721:              			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3722:              		}
3723:              		#else
3724:              		{
3725:              			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3726:              		}
3727:              		#endif
3728:              
3729:              		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3730:              
3731:              		return uxReturn;
3732:              	}
3733:              
3734:              #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3735:              /*-----------------------------------------------------------*/
3736:              
3737:              #if ( INCLUDE_vTaskDelete == 1 )
3738:              
3739:              	static void prvDeleteTCB( TCB_t *pxTCB )
3740:              	{
000D3E  781F88     MOV W8, [W15++]
000D40  780400     MOV W0, W8
3741:              		/* This call is required specifically for the TriCore port.  It must be
3742:              		above the vPortFree() calls.  The call is also used by ports/demos that
3743:              		want to allocate and clean RAM statically. */
3744:              		portCLEAN_UP_TCB( pxTCB );
3745:              
3746:              		/* Free up the memory allocated by the scheduler for the task.  It is up
3747:              		to the task to free any memory allocated at the application level. */
3748:              		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3749:              		{
3750:              			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3751:              		}
3752:              		#endif /* configUSE_NEWLIB_REENTRANT */
3753:              
3754:              		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
3755:              		{
3756:              			/* The task can only have been allocated dynamically - free both
3757:              			the stack and TCB. */
3758:              			vPortFree( pxTCB->pxStack );
000D42  900848     MOV [W8+24], W0
000D44  0228FA     CALL vPortFree
000D46  000000     NOP
3759:              			vPortFree( pxTCB );
000D48  780008     MOV W8, W0
000D4A  0228FA     CALL vPortFree
000D4C  000000     NOP
3760:              		}
3761:              		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
3762:              		{
3763:              			/* The task could have been allocated statically or dynamically, so
3764:              			check what was statically allocated before trying to free the
3765:              			memory. */
3766:              			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3767:              			{
3768:              				/* Both the stack and TCB were allocated dynamically, so both
3769:              				must be freed. */
3770:              				vPortFree( pxTCB->pxStack );
3771:              				vPortFree( pxTCB );
3772:              			}
3773:              			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3774:              			{
3775:              				/* Only the stack was statically allocated, so the TCB is the
3776:              				only memory that must be freed. */
3777:              				vPortFree( pxTCB );
3778:              			}
3779:              			else
3780:              			{
3781:              				/* Neither the stack nor the TCB were allocated dynamically, so
3782:              				nothing needs to be freed. */
3783:              				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3784:              				mtCOVERAGE_TEST_MARKER();
3785:              			}
3786:              		}
3787:              		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3788:              	}
000D4E  78044F     MOV [--W15], W8
000D50  060000     RETURN
3789:              
3790:              #endif /* INCLUDE_vTaskDelete */
3791:              /*-----------------------------------------------------------*/
3792:              
3793:              static void prvResetNextTaskUnblockTime( void )
3794:              {
3795:              TCB_t *pxTCB;
3796:              
3797:              	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000D92  804350     MOV pxDelayedTaskList, W0
000D94  E00010     CP0 [W0]
000D96  3A0002     BRA NZ, .L92
3798:              	{
3799:              		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3800:              		the maximum possible value so it is	extremely unlikely that the
3801:              		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3802:              		there is an item in the delayed list. */
3803:              		xNextTaskUnblockTime = portMAX_DELAY;
000D98  EFA864     SETM xNextTaskUnblockTime
000D9A  370005     BRA .L91
3804:              	}
3805:              	else
3806:              	{
3807:              		/* The new current delayed list is not empty, get the value of
3808:              		the item at the head of the delayed list.  This is the time at
3809:              		which the task at the head of the delayed list should be removed
3810:              		from the Blocked state. */
3811:              		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000D9C  804350     MOV pxDelayedTaskList, W0
000D9E  900030     MOV [W0+6], W0
3812:              		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
000DA0  900030     MOV [W0+6], W0
000DA2  900010     MOV [W0+2], W0
000DA4  884320     MOV W0, xNextTaskUnblockTime
3813:              	}
3814:              }
000DA6  060000     RETURN
3815:              /*-----------------------------------------------------------*/
3816:              
3817:              #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3818:              
3819:              	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3820:              	{
3821:              	TaskHandle_t xReturn;
3822:              
3823:              		/* A critical section is not required as this is not called from
3824:              		an interrupt and the current TCB will always be the same for any
3825:              		individual execution thread. */
3826:              		xReturn = pxCurrentTCB;
3827:              
3828:              		return xReturn;
3829:              	}
3830:              
3831:              #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3832:              /*-----------------------------------------------------------*/
3833:              
3834:              #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3835:              
3836:              	BaseType_t xTaskGetSchedulerState( void )
3837:              	{
3838:              	BaseType_t xReturn;
3839:              
3840:              		if( xSchedulerRunning == pdFALSE )
3841:              		{
3842:              			xReturn = taskSCHEDULER_NOT_STARTED;
3843:              		}
3844:              		else
3845:              		{
3846:              			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3847:              			{
3848:              				xReturn = taskSCHEDULER_RUNNING;
3849:              			}
3850:              			else
3851:              			{
3852:              				xReturn = taskSCHEDULER_SUSPENDED;
3853:              			}
3854:              		}
3855:              
3856:              		return xReturn;
3857:              	}
3858:              
3859:              #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3860:              /*-----------------------------------------------------------*/
3861:              
3862:              #if ( configUSE_MUTEXES == 1 )
3863:              
3864:              	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3865:              	{
3866:              	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
3867:              	BaseType_t xReturn = pdFALSE;
3868:              
3869:              		/* If the mutex was given back by an interrupt while the queue was
3870:              		locked then the mutex holder might now be NULL.  _RB_ Is this still
3871:              		needed as interrupts can no longer use mutexes? */
3872:              		if( pxMutexHolder != NULL )
3873:              		{
3874:              			/* If the holder of the mutex has a priority below the priority of
3875:              			the task attempting to obtain the mutex then it will temporarily
3876:              			inherit the priority of the task attempting to obtain the mutex. */
3877:              			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
3878:              			{
3879:              				/* Adjust the mutex holder state to account for its new
3880:              				priority.  Only reset the event list item value if the value is
3881:              				not being used for anything else. */
3882:              				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
3883:              				{
3884:              					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
3885:              				}
3886:              				else
3887:              				{
3888:              					mtCOVERAGE_TEST_MARKER();
3889:              				}
3890:              
3891:              				/* If the task being modified is in the ready state it will need
3892:              				to be moved into a new list. */
3893:              				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
3894:              				{
3895:              					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3896:              					{
3897:              						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
3898:              					}
3899:              					else
3900:              					{
3901:              						mtCOVERAGE_TEST_MARKER();
3902:              					}
3903:              
3904:              					/* Inherit the priority before being moved into the new list. */
3905:              					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3906:              					prvAddTaskToReadyList( pxMutexHolderTCB );
3907:              				}
3908:              				else
3909:              				{
3910:              					/* Just inherit the priority. */
3911:              					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3912:              				}
3913:              
3914:              				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
3915:              
3916:              				/* Inheritance occurred. */
3917:              				xReturn = pdTRUE;
3918:              			}
3919:              			else
3920:              			{
3921:              				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
3922:              				{
3923:              					/* The base priority of the mutex holder is lower than the
3924:              					priority of the task attempting to take the mutex, but the
3925:              					current priority of the mutex holder is not lower than the
3926:              					priority of the task attempting to take the mutex.
3927:              					Therefore the mutex holder must have already inherited a
3928:              					priority, but inheritance would have occurred if that had
3929:              					not been the case. */
3930:              					xReturn = pdTRUE;
3931:              				}
3932:              				else
3933:              				{
3934:              					mtCOVERAGE_TEST_MARKER();
3935:              				}
3936:              			}
3937:              		}
3938:              		else
3939:              		{
3940:              			mtCOVERAGE_TEST_MARKER();
3941:              		}
3942:              
3943:              		return xReturn;
3944:              	}
3945:              
3946:              #endif /* configUSE_MUTEXES */
3947:              /*-----------------------------------------------------------*/
3948:              
3949:              #if ( configUSE_MUTEXES == 1 )
3950:              
3951:              	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3952:              	{
3953:              	TCB_t * const pxTCB = pxMutexHolder;
3954:              	BaseType_t xReturn = pdFALSE;
3955:              
3956:              		if( pxMutexHolder != NULL )
3957:              		{
3958:              			/* A task can only have an inherited priority if it holds the mutex.
3959:              			If the mutex is held by a task then it cannot be given from an
3960:              			interrupt, and if a mutex is given by the holding task then it must
3961:              			be the running state task. */
3962:              			configASSERT( pxTCB == pxCurrentTCB );
3963:              			configASSERT( pxTCB->uxMutexesHeld );
3964:              			( pxTCB->uxMutexesHeld )--;
3965:              
3966:              			/* Has the holder of the mutex inherited the priority of another
3967:              			task? */
3968:              			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3969:              			{
3970:              				/* Only disinherit if no other mutexes are held. */
3971:              				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
3972:              				{
3973:              					/* A task can only have an inherited priority if it holds
3974:              					the mutex.  If the mutex is held by a task then it cannot be
3975:              					given from an interrupt, and if a mutex is given by the
3976:              					holding task then it must be the running state task.  Remove
3977:              					the holding task from the ready list. */
3978:              					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3979:              					{
3980:              						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3981:              					}
3982:              					else
3983:              					{
3984:              						mtCOVERAGE_TEST_MARKER();
3985:              					}
3986:              
3987:              					/* Disinherit the priority before adding the task into the
3988:              					new	ready list. */
3989:              					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3990:              					pxTCB->uxPriority = pxTCB->uxBasePriority;
3991:              
3992:              					/* Reset the event list item value.  It cannot be in use for
3993:              					any other purpose if this task is running, and it must be
3994:              					running to give back the mutex. */
3995:              					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
3996:              					prvAddTaskToReadyList( pxTCB );
3997:              
3998:              					/* Return true to indicate that a context switch is required.
3999:              					This is only actually required in the corner case whereby
4000:              					multiple mutexes were held and the mutexes were given back
4001:              					in an order different to that in which they were taken.
4002:              					If a context switch did not occur when the first mutex was
4003:              					returned, even if a task was waiting on it, then a context
4004:              					switch should occur when the last mutex is returned whether
4005:              					a task is waiting on it or not. */
4006:              					xReturn = pdTRUE;
4007:              				}
4008:              				else
4009:              				{
4010:              					mtCOVERAGE_TEST_MARKER();
4011:              				}
4012:              			}
4013:              			else
4014:              			{
4015:              				mtCOVERAGE_TEST_MARKER();
4016:              			}
4017:              		}
4018:              		else
4019:              		{
4020:              			mtCOVERAGE_TEST_MARKER();
4021:              		}
4022:              
4023:              		return xReturn;
4024:              	}
4025:              
4026:              #endif /* configUSE_MUTEXES */
4027:              /*-----------------------------------------------------------*/
4028:              
4029:              #if ( configUSE_MUTEXES == 1 )
4030:              
4031:              	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
4032:              	{
4033:              	TCB_t * const pxTCB = pxMutexHolder;
4034:              	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4035:              	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4036:              
4037:              		if( pxMutexHolder != NULL )
4038:              		{
4039:              			/* If pxMutexHolder is not NULL then the holder must hold at least
4040:              			one mutex. */
4041:              			configASSERT( pxTCB->uxMutexesHeld );
4042:              
4043:              			/* Determine the priority to which the priority of the task that
4044:              			holds the mutex should be set.  This will be the greater of the
4045:              			holding task's base priority and the priority of the highest
4046:              			priority task that is waiting to obtain the mutex. */
4047:              			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4048:              			{
4049:              				uxPriorityToUse = uxHighestPriorityWaitingTask;
4050:              			}
4051:              			else
4052:              			{
4053:              				uxPriorityToUse = pxTCB->uxBasePriority;
4054:              			}
4055:              
4056:              			/* Does the priority need to change? */
4057:              			if( pxTCB->uxPriority != uxPriorityToUse )
4058:              			{
4059:              				/* Only disinherit if no other mutexes are held.  This is a
4060:              				simplification in the priority inheritance implementation.  If
4061:              				the task that holds the mutex is also holding other mutexes then
4062:              				the other mutexes may have caused the priority inheritance. */
4063:              				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4064:              				{
4065:              					/* If a task has timed out because it already holds the
4066:              					mutex it was trying to obtain then it cannot of inherited
4067:              					its own priority. */
4068:              					configASSERT( pxTCB != pxCurrentTCB );
4069:              
4070:              					/* Disinherit the priority, remembering the previous
4071:              					priority to facilitate determining the subject task's
4072:              					state. */
4073:              					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4074:              					uxPriorityUsedOnEntry = pxTCB->uxPriority;
4075:              					pxTCB->uxPriority = uxPriorityToUse;
4076:              
4077:              					/* Only reset the event list item value if the value is not
4078:              					being used for anything else. */
4079:              					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4080:              					{
4081:              						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4082:              					}
4083:              					else
4084:              					{
4085:              						mtCOVERAGE_TEST_MARKER();
4086:              					}
4087:              
4088:              					/* If the running task is not the task that holds the mutex
4089:              					then the task that holds the mutex could be in either the
4090:              					Ready, Blocked or Suspended states.  Only remove the task
4091:              					from its current state list if it is in the Ready state as
4092:              					the task's priority is going to change and there is one
4093:              					Ready list per priority. */
4094:              					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
4095:              					{
4096:              						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4097:              						{
4098:              							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
4099:              						}
4100:              						else
4101:              						{
4102:              							mtCOVERAGE_TEST_MARKER();
4103:              						}
4104:              
4105:              						prvAddTaskToReadyList( pxTCB );
4106:              					}
4107:              					else
4108:              					{
4109:              						mtCOVERAGE_TEST_MARKER();
4110:              					}
4111:              				}
4112:              				else
4113:              				{
4114:              					mtCOVERAGE_TEST_MARKER();
4115:              				}
4116:              			}
4117:              			else
4118:              			{
4119:              				mtCOVERAGE_TEST_MARKER();
4120:              			}
4121:              		}
4122:              		else
4123:              		{
4124:              			mtCOVERAGE_TEST_MARKER();
4125:              		}
4126:              	}
4127:              
4128:              #endif /* configUSE_MUTEXES */
4129:              /*-----------------------------------------------------------*/
4130:              
4131:              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4132:              
4133:              	void vTaskEnterCritical( void )
4134:              	{
4135:              		portDISABLE_INTERRUPTS();
4136:              
4137:              		if( xSchedulerRunning != pdFALSE )
4138:              		{
4139:              			( pxCurrentTCB->uxCriticalNesting )++;
4140:              
4141:              			/* This is not the interrupt safe version of the enter critical
4142:              			function so	assert() if it is being called from an interrupt
4143:              			context.  Only API functions that end in "FromISR" can be used in an
4144:              			interrupt.  Only assert if the critical nesting count is 1 to
4145:              			protect against recursive calls if the assert function also uses a
4146:              			critical section. */
4147:              			if( pxCurrentTCB->uxCriticalNesting == 1 )
4148:              			{
4149:              				portASSERT_IF_IN_ISR();
4150:              			}
4151:              		}
4152:              		else
4153:              		{
4154:              			mtCOVERAGE_TEST_MARKER();
4155:              		}
4156:              	}
4157:              
4158:              #endif /* portCRITICAL_NESTING_IN_TCB */
4159:              /*-----------------------------------------------------------*/
4160:              
4161:              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4162:              
4163:              	void vTaskExitCritical( void )
4164:              	{
4165:              		if( xSchedulerRunning != pdFALSE )
4166:              		{
4167:              			if( pxCurrentTCB->uxCriticalNesting > 0U )
4168:              			{
4169:              				( pxCurrentTCB->uxCriticalNesting )--;
4170:              
4171:              				if( pxCurrentTCB->uxCriticalNesting == 0U )
4172:              				{
4173:              					portENABLE_INTERRUPTS();
4174:              				}
4175:              				else
4176:              				{
4177:              					mtCOVERAGE_TEST_MARKER();
4178:              				}
4179:              			}
4180:              			else
4181:              			{
4182:              				mtCOVERAGE_TEST_MARKER();
4183:              			}
4184:              		}
4185:              		else
4186:              		{
4187:              			mtCOVERAGE_TEST_MARKER();
4188:              		}
4189:              	}
4190:              
4191:              #endif /* portCRITICAL_NESTING_IN_TCB */
4192:              /*-----------------------------------------------------------*/
4193:              
4194:              #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4195:              
4196:              	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4197:              	{
4198:              	size_t x;
4199:              
4200:              		/* Start by copying the entire string. */
4201:              		strcpy( pcBuffer, pcTaskName );
4202:              
4203:              		/* Pad the end of the string with spaces to ensure columns line up when
4204:              		printed out. */
4205:              		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4206:              		{
4207:              			pcBuffer[ x ] = ' ';
4208:              		}
4209:              
4210:              		/* Terminate. */
4211:              		pcBuffer[ x ] = ( char ) 0x00;
4212:              
4213:              		/* Return the new end of string. */
4214:              		return &( pcBuffer[ x ] );
4215:              	}
4216:              
4217:              #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4218:              /*-----------------------------------------------------------*/
4219:              
4220:              #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
4221:              
4222:              	void vTaskList( char * pcWriteBuffer )
4223:              	{
4224:              	TaskStatus_t *pxTaskStatusArray;
4225:              	UBaseType_t uxArraySize, x;
4226:              	char cStatus;
4227:              
4228:              		/*
4229:              		 * PLEASE NOTE:
4230:              		 *
4231:              		 * This function is provided for convenience only, and is used by many
4232:              		 * of the demo applications.  Do not consider it to be part of the
4233:              		 * scheduler.
4234:              		 *
4235:              		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4236:              		 * uxTaskGetSystemState() output into a human readable table that
4237:              		 * displays task names, states and stack usage.
4238:              		 *
4239:              		 * vTaskList() has a dependency on the sprintf() C library function that
4240:              		 * might bloat the code size, use a lot of stack, and provide different
4241:              		 * results on different platforms.  An alternative, tiny, third party,
4242:              		 * and limited functionality implementation of sprintf() is provided in
4243:              		 * many of the FreeRTOS/Demo sub-directories in a file called
4244:              		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4245:              		 * snprintf() implementation!).
4246:              		 *
4247:              		 * It is recommended that production systems call uxTaskGetSystemState()
4248:              		 * directly to get access to raw stats data, rather than indirectly
4249:              		 * through a call to vTaskList().
4250:              		 */
4251:              
4252:              
4253:              		/* Make sure the write buffer does not contain a string. */
4254:              		*pcWriteBuffer = ( char ) 0x00;
4255:              
4256:              		/* Take a snapshot of the number of tasks in case it changes while this
4257:              		function is executing. */
4258:              		uxArraySize = uxCurrentNumberOfTasks;
4259:              
4260:              		/* Allocate an array index for each task.  NOTE!  if
4261:              		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4262:              		equate to NULL. */
4263:              		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
4264:              
4265:              		if( pxTaskStatusArray != NULL )
4266:              		{
4267:              			/* Generate the (binary) data. */
4268:              			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4269:              
4270:              			/* Create a human readable table from the binary data. */
4271:              			for( x = 0; x < uxArraySize; x++ )
4272:              			{
4273:              				switch( pxTaskStatusArray[ x ].eCurrentState )
4274:              				{
4275:              					case eRunning:		cStatus = tskRUNNING_CHAR;
4276:              										break;
4277:              
4278:              					case eReady:		cStatus = tskREADY_CHAR;
4279:              										break;
4280:              
4281:              					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4282:              										break;
4283:              
4284:              					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4285:              										break;
4286:              
4287:              					case eDeleted:		cStatus = tskDELETED_CHAR;
4288:              										break;
4289:              
4290:              					case eInvalid:		/* Fall through. */
4291:              					default:			/* Should not get here, but it is included
4292:              										to prevent static checking errors. */
4293:              										cStatus = ( char ) 0x00;
4294:              										break;
4295:              				}
4296:              
4297:              				/* Write the task name to the string, padding with spaces so it
4298:              				can be printed in tabular form more easily. */
4299:              				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4300:              
4301:              				/* Write the rest of the string. */
4302:              				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
4303:              				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
4304:              			}
4305:              
4306:              			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4307:              			is 0 then vPortFree() will be #defined to nothing. */
4308:              			vPortFree( pxTaskStatusArray );
4309:              		}
4310:              		else
4311:              		{
4312:              			mtCOVERAGE_TEST_MARKER();
4313:              		}
4314:              	}
4315:              
4316:              #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
4317:              /*----------------------------------------------------------*/
4318:              
4319:              #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
4320:              
4321:              	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4322:              	{
4323:              	TaskStatus_t *pxTaskStatusArray;
4324:              	UBaseType_t uxArraySize, x;
4325:              	uint32_t ulTotalTime, ulStatsAsPercentage;
4326:              
4327:              		#if( configUSE_TRACE_FACILITY != 1 )
4328:              		{
4329:              			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
4330:              		}
4331:              		#endif
4332:              
4333:              		/*
4334:              		 * PLEASE NOTE:
4335:              		 *
4336:              		 * This function is provided for convenience only, and is used by many
4337:              		 * of the demo applications.  Do not consider it to be part of the
4338:              		 * scheduler.
4339:              		 *
4340:              		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4341:              		 * of the uxTaskGetSystemState() output into a human readable table that
4342:              		 * displays the amount of time each task has spent in the Running state
4343:              		 * in both absolute and percentage terms.
4344:              		 *
4345:              		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4346:              		 * function that might bloat the code size, use a lot of stack, and
4347:              		 * provide different results on different platforms.  An alternative,
4348:              		 * tiny, third party, and limited functionality implementation of
4349:              		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4350:              		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4351:              		 * a full snprintf() implementation!).
4352:              		 *
4353:              		 * It is recommended that production systems call uxTaskGetSystemState()
4354:              		 * directly to get access to raw stats data, rather than indirectly
4355:              		 * through a call to vTaskGetRunTimeStats().
4356:              		 */
4357:              
4358:              		/* Make sure the write buffer does not contain a string. */
4359:              		*pcWriteBuffer = ( char ) 0x00;
4360:              
4361:              		/* Take a snapshot of the number of tasks in case it changes while this
4362:              		function is executing. */
4363:              		uxArraySize = uxCurrentNumberOfTasks;
4364:              
4365:              		/* Allocate an array index for each task.  NOTE!  If
4366:              		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4367:              		equate to NULL. */
4368:              		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
4369:              
4370:              		if( pxTaskStatusArray != NULL )
4371:              		{
4372:              			/* Generate the (binary) data. */
4373:              			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4374:              
4375:              			/* For percentage calculations. */
4376:              			ulTotalTime /= 100UL;
4377:              
4378:              			/* Avoid divide by zero errors. */
4379:              			if( ulTotalTime > 0UL )
4380:              			{
4381:              				/* Create a human readable table from the binary data. */
4382:              				for( x = 0; x < uxArraySize; x++ )
4383:              				{
4384:              					/* What percentage of the total run time has the task used?
4385:              					This will always be rounded down to the nearest integer.
4386:              					ulTotalRunTimeDiv100 has already been divided by 100. */
4387:              					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4388:              
4389:              					/* Write the task name to the string, padding with
4390:              					spaces so it can be printed in tabular form more
4391:              					easily. */
4392:              					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4393:              
4394:              					if( ulStatsAsPercentage > 0UL )
4395:              					{
4396:              						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4397:              						{
4398:              							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
4399:              						}
4400:              						#else
4401:              						{
4402:              							/* sizeof( int ) == sizeof( long ) so a smaller
4403:              							printf() library can be used. */
4404:              							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
4405:              						}
4406:              						#endif
4407:              					}
4408:              					else
4409:              					{
4410:              						/* If the percentage is zero here then the task has
4411:              						consumed less than 1% of the total run time. */
4412:              						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4413:              						{
4414:              							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4415:              						}
4416:              						#else
4417:              						{
4418:              							/* sizeof( int ) == sizeof( long ) so a smaller
4419:              							printf() library can be used. */
4420:              							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
4421:              						}
4422:              						#endif
4423:              					}
4424:              
4425:              					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
4426:              				}
4427:              			}
4428:              			else
4429:              			{
4430:              				mtCOVERAGE_TEST_MARKER();
4431:              			}
4432:              
4433:              			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4434:              			is 0 then vPortFree() will be #defined to nothing. */
4435:              			vPortFree( pxTaskStatusArray );
4436:              		}
4437:              		else
4438:              		{
4439:              			mtCOVERAGE_TEST_MARKER();
4440:              		}
4441:              	}
4442:              
4443:              #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
4444:              /*-----------------------------------------------------------*/
4445:              
4446:              TickType_t uxTaskResetEventItemValue( void )
4447:              {
4448:              TickType_t uxReturn;
4449:              
4450:              	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000F92  804280     MOV pxCurrentTCB, W0
000F94  900060     MOV [W0+12], W0
4451:              
4452:              	/* Reset the event list item to its normal value - so it can be used with
4453:              	queues and semaphores. */
4454:              	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000F96  804281     MOV pxCurrentTCB, W1
000F98  804282     MOV pxCurrentTCB, W2
000F9A  900932     MOV [W2+22], W2
000F9C  110164     SUBR W2, #0x4, W2
000F9E  9800E2     MOV W2, [W1+12]
4455:              
4456:              	return uxReturn;
4457:              }
000FA0  060000     RETURN
4458:              /*-----------------------------------------------------------*/
4459:              
4460:              #if ( configUSE_MUTEXES == 1 )
4461:              
4462:              	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4463:              	{
4464:              		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4465:              		then pxCurrentTCB will be NULL. */
4466:              		if( pxCurrentTCB != NULL )
4467:              		{
4468:              			( pxCurrentTCB->uxMutexesHeld )++;
4469:              		}
4470:              
4471:              		return pxCurrentTCB;
4472:              	}
4473:              
4474:              #endif /* configUSE_MUTEXES */
4475:              /*-----------------------------------------------------------*/
4476:              
4477:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4478:              
4479:              	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4480:              	{
001268  BE9F88     MOV.D W8, [W15++]
00126A  781F8A     MOV W10, [W15++]
00126C  780500     MOV W0, W10
00126E  780401     MOV W1, W8
4481:              	uint32_t ulReturn;
4482:              
4483:              		taskENTER_CRITICAL();
001270  0225F4     CALL vPortEnterCritical
001272  000000     NOP
4484:              		{
4485:              			/* Only block if the notification count is not already non-zero. */
4486:              			if( pxCurrentTCB->ulNotifiedValue == 0UL )
001274  804280     MOV pxCurrentTCB, W0
001276  901090     MOV [W0+34], W1
001278  901000     MOV [W0+32], W0
00127A  500FE0     SUB W0, #0x0, [W15]
00127C  588FE0     SUBB W1, #0x0, [W15]
00127E  3A000B     BRA NZ, .L204
4487:              			{
4488:              				/* Mark this task as waiting for a notification. */
4489:              				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
001280  804280     MOV pxCurrentTCB, W0
001282  B3C011     MOV.B #0x1, W1
001284  986041     MOV.B W1, [W0+36]
4490:              
4491:              				if( xTicksToWait > ( TickType_t ) 0 )
001286  E00008     CP0 W8
001288  320006     BRA Z, .L204
4492:              				{
4493:              					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00128A  200011     MOV #0x1, W1
00128C  780008     MOV W8, W0
00128E  07FF74     RCALL prvAddCurrentTaskToDelayedList
4494:              					traceTASK_NOTIFY_TAKE_BLOCK();
4495:              
4496:              					/* All ports are written to allow a yield in a critical
4497:              					section (some will yield immediately, others wait until the
4498:              					critical section exits) - but it is not something that
4499:              					application code should ever do. */
4500:              					portYIELD_WITHIN_API();
001290  02286C     CALL .Letext0, .LFE2, _vPortYield
001292  000000     NOP
001294  000000     NOP
4501:              				}
4502:              				else
4503:              				{
4504:              					mtCOVERAGE_TEST_MARKER();
4505:              				}
4506:              			}
4507:              			else
4508:              			{
4509:              				mtCOVERAGE_TEST_MARKER();
4510:              			}
4511:              		}
4512:              		taskEXIT_CRITICAL();
001296  022604     CALL vPortExitCritical
001298  000000     NOP
4513:              
4514:              		taskENTER_CRITICAL();
00129A  0225F4     CALL vPortEnterCritical
00129C  000000     NOP
4515:              		{
4516:              			traceTASK_NOTIFY_TAKE();
4517:              			ulReturn = pxCurrentTCB->ulNotifiedValue;
00129E  804280     MOV pxCurrentTCB, W0
0012A0  901400     MOV [W0+32], W8
0012A2  901490     MOV [W0+34], W9
4518:              
4519:              			if( ulReturn != 0UL )
0012A4  540FE0     SUB W8, #0x0, [W15]
0012A6  5C8FE0     SUBB W9, #0x0, [W15]
0012A8  32000C     BRA Z, .L205
4520:              			{
4521:              				if( xClearCountOnExit != pdFALSE )
0012AA  E0000A     CP0 W10
0012AC  320005     BRA Z, .L206
4522:              				{
4523:              					pxCurrentTCB->ulNotifiedValue = 0UL;
0012AE  804280     MOV pxCurrentTCB, W0
0012B0  B81160     MUL.UU W2, #0, W2
0012B2  981002     MOV W2, [W0+32]
0012B4  981013     MOV W3, [W0+34]
0012B6  370005     BRA .L205
4524:              				}
4525:              				else
4526:              				{
4527:              					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
0012B8  804280     MOV pxCurrentTCB, W0
0012BA  540161     SUB W8, #0x1, W2
0012BC  5C81E0     SUBB W9, #0x0, W3
0012BE  981002     MOV W2, [W0+32]
0012C0  981013     MOV W3, [W0+34]
4528:              				}
4529:              			}
4530:              			else
4531:              			{
4532:              				mtCOVERAGE_TEST_MARKER();
4533:              			}
4534:              
4535:              			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
0012C2  804280     MOV pxCurrentTCB, W0
0012C4  EB4080     CLR.B W1
0012C6  986041     MOV.B W1, [W0+36]
4536:              		}
4537:              		taskEXIT_CRITICAL();
0012C8  022604     CALL vPortExitCritical
0012CA  000000     NOP
4538:              
4539:              		return ulReturn;
4540:              	}
0012CC  BE0008     MOV.D W8, W0
0012CE  78054F     MOV [--W15], W10
0012D0  BE044F     MOV.D [--W15], W8
0012D2  060000     RETURN
4541:              
4542:              #endif /* configUSE_TASK_NOTIFICATIONS */
4543:              /*-----------------------------------------------------------*/
4544:              
4545:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4546:              
4547:              	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
4548:              	{
0011CA  BE9F88     MOV.D W8, [W15++]
0011CC  BE9F8A     MOV.D W10, [W15++]
0011CE  BE9F8C     MOV.D W12, [W15++]
0011D0  BE0400     MOV.D W0, W8
0011D2  BE0502     MOV.D W2, W10
0011D4  BE0604     MOV.D W4, W12
4549:              	BaseType_t xReturn;
4550:              
4551:              		taskENTER_CRITICAL();
0011D6  0225F4     CALL vPortEnterCritical
0011D8  000000     NOP
4552:              		{
4553:              			/* Only block if a notification is not already pending. */
4554:              			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
0011DA  804280     MOV pxCurrentTCB, W0
0011DC  906040     MOV.B [W0+36], W0
0011DE  504FE2     SUB.B W0, #0x2, [W15]
0011E0  32001A     BRA Z, .L199
4555:              			{
4556:              				/* Clear bits in the task's notification value as bits may get
4557:              				set	by the notifying task or interrupt.  This can be used to
4558:              				clear the value to zero. */
4559:              				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
0011E2  804284     MOV pxCurrentTCB, W4
0011E4  901004     MOV [W4+32], W0
0011E6  901094     MOV [W4+34], W1
0011E8  EA8408     COM W8, W8
0011EA  EA8489     COM W9, W9
0011EC  600288     AND W0, W8, W5
0011EE  608109     AND W1, W9, W2
0011F0  EB0180     CLR W3
0011F2  DD10C0     SL W2, #0, W1
0011F4  200000     MOV #0x0, W0
0011F6  B82961     MUL.UU W5, #1, W2
0011F8  700002     IOR W0, W2, W0
0011FA  708083     IOR W1, W3, W1
0011FC  981200     MOV W0, [W4+32]
0011FE  981211     MOV W1, [W4+34]
4560:              
4561:              				/* Mark this task as waiting for a notification. */
4562:              				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
001200  804280     MOV pxCurrentTCB, W0
001202  B3C011     MOV.B #0x1, W1
001204  986041     MOV.B W1, [W0+36]
4563:              
4564:              				if( xTicksToWait > ( TickType_t ) 0 )
001206  E0000D     CP0 W13
001208  320006     BRA Z, .L199
4565:              				{
4566:              					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00120A  200011     MOV #0x1, W1
00120C  78000D     MOV W13, W0
00120E  07FFB4     RCALL prvAddCurrentTaskToDelayedList
4567:              					traceTASK_NOTIFY_WAIT_BLOCK();
4568:              
4569:              					/* All ports are written to allow a yield in a critical
4570:              					section (some will yield immediately, others wait until the
4571:              					critical section exits) - but it is not something that
4572:              					application code should ever do. */
4573:              					portYIELD_WITHIN_API();
001210  02286C     CALL .Letext0, .LFE2, _vPortYield
001212  000000     NOP
001214  000000     NOP
4574:              				}
4575:              				else
4576:              				{
4577:              					mtCOVERAGE_TEST_MARKER();
4578:              				}
4579:              			}
4580:              			else
4581:              			{
4582:              				mtCOVERAGE_TEST_MARKER();
4583:              			}
4584:              		}
4585:              		taskEXIT_CRITICAL();
001216  022604     CALL vPortExitCritical
001218  000000     NOP
4586:              
4587:              		taskENTER_CRITICAL();
00121A  0225F4     CALL vPortEnterCritical
00121C  000000     NOP
4588:              		{
4589:              			traceTASK_NOTIFY_WAIT();
4590:              
4591:              			if( pulNotificationValue != NULL )
00121E  E0000C     CP0 W12
001220  320004     BRA Z, .L200
4592:              			{
4593:              				/* Output the current notification value, which may or may not
4594:              				have changed. */
4595:              				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
001222  804280     MOV pxCurrentTCB, W0
001224  901100     MOV [W0+32], W2
001226  901190     MOV [W0+34], W3
001228  BE8E02     MOV.D W2, [W12]
4596:              			}
4597:              
4598:              			/* If ucNotifyValue is set then either the task never entered the
4599:              			blocked state (because a notification was already pending) or the
4600:              			task unblocked because of a notification.  Otherwise the task
4601:              			unblocked because of a timeout. */
4602:              			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
00122A  804280     MOV pxCurrentTCB, W0
00122C  906040     MOV.B [W0+36], W0
001230  504FE2     SUB.B W0, #0x2, [W15]
001232  3A0010     BRA NZ, .L201
4603:              			{
4604:              				/* A notification was not received. */
4605:              				xReturn = pdFALSE;
00122E  EB0400     CLR W8
4606:              			}
4607:              			else
4608:              			{
4609:              				/* A notification was already pending or a notification was
4610:              				received while the task was waiting. */
4611:              				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
001234  804284     MOV pxCurrentTCB, W4
001236  901004     MOV [W4+32], W0
001238  901094     MOV [W4+34], W1
00123A  EA850A     COM W10, W10
00123C  EA858B     COM W11, W11
00123E  60028A     AND W0, W10, W5
001240  60810B     AND W1, W11, W2
001242  EB0180     CLR W3
001244  DD10C0     SL W2, #0, W1
001246  200000     MOV #0x0, W0
001248  B82961     MUL.UU W5, #1, W2
00124A  700002     IOR W0, W2, W0
00124C  708083     IOR W1, W3, W1
00124E  981200     MOV W0, [W4+32]
001250  981211     MOV W1, [W4+34]
4612:              				xReturn = pdTRUE;
001252  200018     MOV #0x1, W8
4613:              			}
4614:              
4615:              			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
001254  804280     MOV pxCurrentTCB, W0
001256  EB4080     CLR.B W1
001258  986041     MOV.B W1, [W0+36]
4616:              		}
4617:              		taskEXIT_CRITICAL();
00125A  022604     CALL vPortExitCritical
00125C  000000     NOP
4618:              
4619:              		return xReturn;
4620:              	}
00125E  780008     MOV W8, W0
001260  BE064F     MOV.D [--W15], W12
001262  BE054F     MOV.D [--W15], W10
001264  BE044F     MOV.D [--W15], W8
001266  060000     RETURN
4621:              
4622:              #endif /* configUSE_TASK_NOTIFICATIONS */
4623:              /*-----------------------------------------------------------*/
4624:              
4625:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4626:              
4627:              	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
4628:              	{
000FA2  BE9F88     MOV.D W8, [W15++]
000FA4  BE9F8A     MOV.D W10, [W15++]
000FA6  781F8C     MOV W12, [W15++]
000FA8  780480     MOV W0, W9
000FAA  BE0502     MOV.D W2, W10
000FAC  780601     MOV W1, W12
000FAE  780404     MOV W4, W8
4629:              	TCB_t * pxTCB;
4630:              	BaseType_t xReturn = pdPASS;
4631:              	uint8_t ucOriginalNotifyState;
4632:              
4633:              		configASSERT( xTaskToNotify );
4634:              		pxTCB = xTaskToNotify;
4635:              
4636:              		taskENTER_CRITICAL();
000FB0  0225F4     CALL vPortEnterCritical
000FB2  000000     NOP
4637:              		{
4638:              			if( pulPreviousNotificationValue != NULL )
000FB4  E00008     CP0 W8
000FB6  320003     BRA Z, .L151
4639:              			{
4640:              				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000FB8  901009     MOV [W9+32], W0
000FBA  901099     MOV [W9+34], W1
000FBC  BE8C00     MOV.D W0, [W8]
4641:              			}
4642:              
4643:              			ucOriginalNotifyState = pxTCB->ucNotifyState;
000FBE  906049     MOV.B [W9+36], W0
4644:              
4645:              			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000FC0  B3C021     MOV.B #0x2, W1
000FC2  9864C1     MOV.B W1, [W9+36]
4646:              
4647:              			switch( eAction )
000FC4  560FE2     SUB W12, #0x2, [W15]
000FC6  320010     BRA Z, .L154
000FC8  3E0003     BRA GTU, .L157
000FCA  560FE1     SUB W12, #0x1, [W15]
000FCC  3A001C     BRA NZ, .L152
000FCE  370005     BRA .L163
000FD0  560FE3     SUB W12, #0x3, [W15]
000FD2  320011     BRA Z, .L155
000FD4  560FE4     SUB W12, #0x4, [W15]
000FD6  3A0017     BRA NZ, .L152
000FD8  370011     BRA .L164
4648:              			{
4649:              				case eSetBits	:
4650:              					pxTCB->ulNotifiedValue |= ulValue;
000FDA  901109     MOV [W9+32], W2
000FDC  901199     MOV [W9+34], W3
000FDE  750502     IOR W10, W2, W10
000FE0  758583     IOR W11, W3, W11
000FE2  98148A     MOV W10, [W9+32]
000FE4  98149B     MOV W11, [W9+34]
4651:              					break;
000FE6  37000F     BRA .L152
4652:              
4653:              				case eIncrement	:
4654:              					( pxTCB->ulNotifiedValue )++;
000FE8  901109     MOV [W9+32], W2
000FEA  901199     MOV [W9+34], W3
000FEC  410161     ADD W2, #0x1, W2
000FEE  4981E0     ADDC W3, #0x0, W3
000FF0  981482     MOV W2, [W9+32]
000FF2  981493     MOV W3, [W9+34]
4655:              					break;
000FF4  370008     BRA .L152
4656:              
4657:              				case eSetValueWithOverwrite	:
4658:              					pxTCB->ulNotifiedValue = ulValue;
000FF6  98148A     MOV W10, [W9+32]
000FF8  98149B     MOV W11, [W9+34]
4659:              					break;
000FFA  370005     BRA .L152
4660:              
4661:              				case eSetValueWithoutOverwrite :
4662:              					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000FFE  504FE2     SUB.B W0, #0x2, [W15]
001000  32001C     BRA Z, .L158
4663:              					{
4664:              						pxTCB->ulNotifiedValue = ulValue;
001002  98148A     MOV W10, [W9+32]
001004  98149B     MOV W11, [W9+34]
4665:              					}
4666:              					else
4667:              					{
4668:              						/* The value could not be written to the task. */
4669:              						xReturn = pdFAIL;
000FFC  EB0400     CLR W8
4670:              					}
4671:              					break;
4672:              
4673:              				case eNoAction:
4674:              					/* The task is being notified without its notify value being
4675:              					updated. */
4676:              					break;
4677:              
4678:              				default:
4679:              					/* Should not get here if all enums are handled.
4680:              					Artificially force an assert by testing a value the
4681:              					compiler can't assume is const. */
4682:              					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4683:              
4684:              					break;
4685:              			}
4686:              
4687:              			traceTASK_NOTIFY();
4688:              
4689:              			/* If the task is in the blocked state specifically to wait for a
4690:              			notification then unblock it now. */
4691:              			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
001006  200018     MOV #0x1, W8
001008  504FE1     SUB.B W0, #0x1, [W15]
00100A  3A0017     BRA NZ, .L158
4692:              			{
4693:              				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00100C  E88409     INC2 W9, W8
00100E  780008     MOV W8, W0
001010  022788     CALL uxListRemove
001012  000000     NOP
4694:              				prvAddTaskToReadyList( pxTCB );
001014  900839     MOV [W9+22], W0
001016  E30858     CP uxTopReadyPriority
001018  310001     BRA C, .L159
00101A  8842C0     MOV W0, uxTopReadyPriority
00101C  B9006A     MUL.SU W0, #10, W0
00101E  21CAC2     MOV #0x1CAC, W2
001020  410000     ADD W2, W0, W0
001022  780088     MOV W8, W1
001024  02274E     CALL vListInsertEnd
001026  000000     NOP
4695:              
4696:              				/* The task should not have been on an event list. */
4697:              				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4698:              
4699:              				#if( configUSE_TICKLESS_IDLE != 0 )
4700:              				{
4701:              					/* If a task is blocked waiting for a notification then
4702:              					xNextTaskUnblockTime might be set to the blocked task's time
4703:              					out time.  If the task is unblocked for a reason other than
4704:              					a timeout xNextTaskUnblockTime is normally left unchanged,
4705:              					because it will automatically get reset to a new value when
4706:              					the tick count equals xNextTaskUnblockTime.  However if
4707:              					tickless idling is used it might be more important to enter
4708:              					sleep mode at the earliest possible time - so reset
4709:              					xNextTaskUnblockTime here to ensure it is updated at the
4710:              					earliest possible time. */
4711:              					prvResetNextTaskUnblockTime();
4712:              				}
4713:              				#endif
4714:              
4715:              				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
001028  804280     MOV pxCurrentTCB, W0
00102A  9008B9     MOV [W9+22], W1
00102C  900830     MOV [W0+22], W0
00102E  200018     MOV #0x1, W8
001030  508F80     SUB W1, W0, [W15]
001032  360003     BRA LEU, .L158
4716:              				{
4717:              					/* The notified task has a priority above the currently
4718:              					executing task so a yield is required. */
4719:              					taskYIELD_IF_USING_PREEMPTION();
001034  02286C     CALL .Letext0, .LFE2, _vPortYield
001036  000000     NOP
001038  000000     NOP
4720:              				}
4721:              				else
4722:              				{
4723:              					mtCOVERAGE_TEST_MARKER();
4724:              				}
4725:              			}
4726:              			else
4727:              			{
4728:              				mtCOVERAGE_TEST_MARKER();
4729:              			}
4730:              		}
4731:              		taskEXIT_CRITICAL();
00103A  022604     CALL vPortExitCritical
00103C  000000     NOP
4732:              
4733:              		return xReturn;
4734:              	}
00103E  780008     MOV W8, W0
001040  78064F     MOV [--W15], W12
001042  BE054F     MOV.D [--W15], W10
001044  BE044F     MOV.D [--W15], W8
001046  060000     RETURN
4735:              
4736:              #endif /* configUSE_TASK_NOTIFICATIONS */
4737:              /*-----------------------------------------------------------*/
4738:              
4739:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4740:              
4741:              	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
4742:              	{
001048  BE9F88     MOV.D W8, [W15++]
00104A  781F8A     MOV W10, [W15++]
00104C  780400     MOV W0, W8
00104E  780485     MOV W5, W9
4743:              	TCB_t * pxTCB;
4744:              	uint8_t ucOriginalNotifyState;
4745:              	BaseType_t xReturn = pdPASS;
4746:              	UBaseType_t uxSavedInterruptStatus;
4747:              
4748:              		configASSERT( xTaskToNotify );
4749:              
4750:              		/* RTOS ports that support interrupt nesting have the concept of a
4751:              		maximum	system call (or maximum API call) interrupt priority.
4752:              		Interrupts that are	above the maximum system call priority are keep
4753:              		permanently enabled, even when the RTOS kernel is in a critical section,
4754:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4755:              		is defined in FreeRTOSConfig.h then
4756:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4757:              		failure if a FreeRTOS API function is called from an interrupt that has
4758:              		been assigned a priority above the configured maximum system call
4759:              		priority.  Only FreeRTOS functions that end in FromISR can be called
4760:              		from interrupts	that have been assigned a priority at or (logically)
4761:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
4762:              		separate interrupt safe API to ensure interrupt entry is as fast and as
4763:              		simple as possible.  More information (albeit Cortex-M specific) is
4764:              		provided on the following link:
4765:              		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4766:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4767:              
4768:              		pxTCB = xTaskToNotify;
4769:              
4770:              		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4771:              		{
4772:              			if( pulPreviousNotificationValue != NULL )
001050  E00004     CP0 W4
001052  320003     BRA Z, .L166
4773:              			{
4774:              				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
001054  901308     MOV [W8+32], W6
001056  901398     MOV [W8+34], W7
001058  BE8A06     MOV.D W6, [W4]
4775:              			}
4776:              
4777:              			ucOriginalNotifyState = pxTCB->ucNotifyState;
00105A  906248     MOV.B [W8+36], W4
4778:              			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
00105C  B3C020     MOV.B #0x2, W0
00105E  986440     MOV.B W0, [W8+36]
4779:              
4780:              			switch( eAction )
001060  508FE2     SUB W1, #0x2, [W15]
001062  320010     BRA Z, .L169
001064  3E0003     BRA GTU, .L172
001066  508FE1     SUB W1, #0x1, [W15]
001068  3A001C     BRA NZ, .L167
00106A  370005     BRA .L181
00106C  508FE3     SUB W1, #0x3, [W15]
00106E  320011     BRA Z, .L170
001070  508FE4     SUB W1, #0x4, [W15]
001072  3A0017     BRA NZ, .L167
001074  370011     BRA .L182
4781:              			{
4782:              				case eSetBits	:
4783:              					pxTCB->ulNotifiedValue |= ulValue;
001076  901008     MOV [W8+32], W0
001078  901098     MOV [W8+34], W1
00107A  710100     IOR W2, W0, W2
00107C  718181     IOR W3, W1, W3
00107E  981402     MOV W2, [W8+32]
001080  981413     MOV W3, [W8+34]
4784:              					break;
001082  37000F     BRA .L167
4785:              
4786:              				case eIncrement	:
4787:              					( pxTCB->ulNotifiedValue )++;
001084  901008     MOV [W8+32], W0
001086  901098     MOV [W8+34], W1
001088  400061     ADD W0, #0x1, W0
00108A  4880E0     ADDC W1, #0x0, W1
00108C  981400     MOV W0, [W8+32]
00108E  981411     MOV W1, [W8+34]
4788:              					break;
001090  370008     BRA .L167
4789:              
4790:              				case eSetValueWithOverwrite	:
4791:              					pxTCB->ulNotifiedValue = ulValue;
001092  981402     MOV W2, [W8+32]
001094  981413     MOV W3, [W8+34]
4792:              					break;
001096  370005     BRA .L167
4793:              
4794:              				case eSetValueWithoutOverwrite :
4795:              					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
00109A  524FE2     SUB.B W4, #0x2, [W15]
00109C  320025     BRA Z, .L173
4796:              					{
4797:              						pxTCB->ulNotifiedValue = ulValue;
00109E  981402     MOV W2, [W8+32]
0010A0  981413     MOV W3, [W8+34]
4798:              					}
4799:              					else
4800:              					{
4801:              						/* The value could not be written to the task. */
4802:              						xReturn = pdFAIL;
001098  EB0000     CLR W0
4803:              					}
4804:              					break;
4805:              
4806:              				case eNoAction :
4807:              					/* The task is being notified without its notify value being
4808:              					updated. */
4809:              					break;
4810:              
4811:              				default:
4812:              					/* Should not get here if all enums are handled.
4813:              					Artificially force an assert by testing a value the
4814:              					compiler can't assume is const. */
4815:              					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4816:              					break;
4817:              			}
4818:              
4819:              			traceTASK_NOTIFY_FROM_ISR();
4820:              
4821:              			/* If the task is in the blocked state specifically to wait for a
4822:              			notification then unblock it now. */
4823:              			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
0010A2  200010     MOV #0x1, W0
0010A4  524FE1     SUB.B W4, #0x1, [W15]
0010A6  3A0020     BRA NZ, .L173
4824:              			{
4825:              				/* The task should not have been on an event list. */
4826:              				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4827:              
4828:              				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0010A8  E20868     CP0 uxSchedulerSuspended
0010AA  3A000F     BRA NZ, .L174
4829:              				{
4830:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
0010AC  E88508     INC2 W8, W10
0010AE  78000A     MOV W10, W0
0010B0  022788     CALL uxListRemove
0010B2  000000     NOP
4831:              					prvAddTaskToReadyList( pxTCB );
0010B4  900838     MOV [W8+22], W0
0010B6  E30858     CP uxTopReadyPriority
0010B8  310001     BRA C, .L175
0010BA  8842C0     MOV W0, uxTopReadyPriority
0010BC  B9006A     MUL.SU W0, #10, W0
0010BE  21CAC2     MOV #0x1CAC, W2
0010C0  410000     ADD W2, W0, W0
0010C2  78008A     MOV W10, W1
0010C4  02274E     CALL vListInsertEnd
0010C6  000000     NOP
0010C8  370004     BRA .L176
4832:              				}
4833:              				else
4834:              				{
4835:              					/* The delayed and ready lists cannot be accessed, so hold
4836:              					this task pending until the scheduler is resumed. */
4837:              					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0010CA  4400EC     ADD W8, #0xC, W1
0010CC  21CE80     MOV #0x1CE8, W0
0010CE  02274E     CALL vListInsertEnd
0010D0  000000     NOP
4838:              				}
4839:              
4840:              				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0010D2  804280     MOV pxCurrentTCB, W0
0010D4  900938     MOV [W8+22], W2
0010D6  9008B0     MOV [W0+22], W1
0010D8  200010     MOV #0x1, W0
0010DA  510F81     SUB W2, W1, [W15]
0010DC  360005     BRA LEU, .L173
4841:              				{
4842:              					/* The notified task has a priority above the currently
4843:              					executing task so a yield is required. */
4844:              					if( pxHigherPriorityTaskWoken != NULL )
0010DE  E00009     CP0 W9
0010E0  320001     BRA Z, .L177
4845:              					{
4846:              						*pxHigherPriorityTaskWoken = pdTRUE;
0010E2  780C80     MOV W0, [W9]
4847:              					}
4848:              
4849:              					/* Mark that a yield is pending in case the user is not
4850:              					using the "xHigherPriorityTaskWoken" parameter to an ISR
4851:              					safe FreeRTOS function. */
4852:              					xYieldPending = pdTRUE;
0010E4  200010     MOV #0x1, W0
0010E6  8842F0     MOV W0, xYieldPending
4853:              				}
4854:              				else
4855:              				{
4856:              					mtCOVERAGE_TEST_MARKER();
4857:              				}
4858:              			}
4859:              		}
4860:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4861:              
4862:              		return xReturn;
4863:              	}
0010E8  78054F     MOV [--W15], W10
0010EA  BE044F     MOV.D [--W15], W8
0010EC  060000     RETURN
4864:              
4865:              #endif /* configUSE_TASK_NOTIFICATIONS */
4866:              /*-----------------------------------------------------------*/
4867:              
4868:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4869:              
4870:              	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4871:              	{
0010EE  BE9F88     MOV.D W8, [W15++]
0010F0  781F8A     MOV W10, [W15++]
0010F2  BE0400     MOV.D W0, W8
4872:              	TCB_t * pxTCB;
4873:              	uint8_t ucOriginalNotifyState;
4874:              	UBaseType_t uxSavedInterruptStatus;
4875:              
4876:              		configASSERT( xTaskToNotify );
4877:              
4878:              		/* RTOS ports that support interrupt nesting have the concept of a
4879:              		maximum	system call (or maximum API call) interrupt priority.
4880:              		Interrupts that are	above the maximum system call priority are keep
4881:              		permanently enabled, even when the RTOS kernel is in a critical section,
4882:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4883:              		is defined in FreeRTOSConfig.h then
4884:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4885:              		failure if a FreeRTOS API function is called from an interrupt that has
4886:              		been assigned a priority above the configured maximum system call
4887:              		priority.  Only FreeRTOS functions that end in FromISR can be called
4888:              		from interrupts	that have been assigned a priority at or (logically)
4889:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
4890:              		separate interrupt safe API to ensure interrupt entry is as fast and as
4891:              		simple as possible.  More information (albeit Cortex-M specific) is
4892:              		provided on the following link:
4893:              		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4894:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4895:              
4896:              		pxTCB = xTaskToNotify;
4897:              
4898:              		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4899:              		{
4900:              			ucOriginalNotifyState = pxTCB->ucNotifyState;
0010F4  906048     MOV.B [W8+36], W0
4901:              			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
0010F6  B3C021     MOV.B #0x2, W1
0010F8  986441     MOV.B W1, [W8+36]
4902:              
4903:              			/* 'Giving' is equivalent to incrementing a count in a counting
4904:              			semaphore. */
4905:              			( pxTCB->ulNotifiedValue )++;
0010FA  901108     MOV [W8+32], W2
0010FC  901198     MOV [W8+34], W3
0010FE  410161     ADD W2, #0x1, W2
001100  4981E0     ADDC W3, #0x0, W3
001102  981402     MOV W2, [W8+32]
001104  981413     MOV W3, [W8+34]
4906:              
4907:              			traceTASK_NOTIFY_GIVE_FROM_ISR();
4908:              
4909:              			/* If the task is in the blocked state specifically to wait for a
4910:              			notification then unblock it now. */
4911:              			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
001106  504FE1     SUB.B W0, #0x1, [W15]
001108  3A0020     BRA NZ, .L183
4912:              			{
4913:              				/* The task should not have been on an event list. */
4914:              				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4915:              
4916:              				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00110A  E20868     CP0 uxSchedulerSuspended
00110C  3A000F     BRA NZ, .L185
4917:              				{
4918:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00110E  E88508     INC2 W8, W10
001110  78000A     MOV W10, W0
001112  022788     CALL uxListRemove
001114  000000     NOP
4919:              					prvAddTaskToReadyList( pxTCB );
001116  900838     MOV [W8+22], W0
001118  E30858     CP uxTopReadyPriority
00111A  310001     BRA C, .L186
00111C  8842C0     MOV W0, uxTopReadyPriority
00111E  B9006A     MUL.SU W0, #10, W0
001120  21CAC2     MOV #0x1CAC, W2
001122  410000     ADD W2, W0, W0
001124  78008A     MOV W10, W1
001126  02274E     CALL vListInsertEnd
001128  000000     NOP
00112A  370004     BRA .L187
4920:              				}
4921:              				else
4922:              				{
4923:              					/* The delayed and ready lists cannot be accessed, so hold
4924:              					this task pending until the scheduler is resumed. */
4925:              					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00112C  4400EC     ADD W8, #0xC, W1
00112E  21CE80     MOV #0x1CE8, W0
001130  02274E     CALL vListInsertEnd
001132  000000     NOP
4926:              				}
4927:              
4928:              				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
001134  804280     MOV pxCurrentTCB, W0
001136  9008B8     MOV [W8+22], W1
001138  900830     MOV [W0+22], W0
00113A  508F80     SUB W1, W0, [W15]
00113C  360006     BRA LEU, .L183
4929:              				{
4930:              					/* The notified task has a priority above the currently
4931:              					executing task so a yield is required. */
4932:              					if( pxHigherPriorityTaskWoken != NULL )
00113E  E00009     CP0 W9
001140  320002     BRA Z, .L188
4933:              					{
4934:              						*pxHigherPriorityTaskWoken = pdTRUE;
001142  200010     MOV #0x1, W0
001144  780C80     MOV W0, [W9]
4935:              					}
4936:              
4937:              					/* Mark that a yield is pending in case the user is not
4938:              					using the "xHigherPriorityTaskWoken" parameter in an ISR
4939:              					safe FreeRTOS function. */
4940:              					xYieldPending = pdTRUE;
001146  200010     MOV #0x1, W0
001148  8842F0     MOV W0, xYieldPending
4941:              				}
4942:              				else
4943:              				{
4944:              					mtCOVERAGE_TEST_MARKER();
4945:              				}
4946:              			}
4947:              		}
4948:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4949:              	}
00114A  78054F     MOV [--W15], W10
00114C  BE044F     MOV.D [--W15], W8
00114E  060000     RETURN
4950:              
4951:              #endif /* configUSE_TASK_NOTIFICATIONS */
4952:              
4953:              /*-----------------------------------------------------------*/
4954:              
4955:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4956:              
4957:              	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4958:              	{
001150  BE9F88     MOV.D W8, [W15++]
4959:              	TCB_t *pxTCB;
4960:              	BaseType_t xReturn;
4961:              
4962:              		/* If null is passed in here then it is the calling task that is having
4963:              		its notification state cleared. */
4964:              		pxTCB = prvGetTCBFromHandle( xTask );
001152  E00000     CP0 W0
001154  3A0002     BRA NZ, .L192
001156  804289     MOV pxCurrentTCB, W9
001158  370001     BRA .L190
00115A  780480     MOV W0, W9
4965:              
4966:              		taskENTER_CRITICAL();
00115C  0225F4     CALL vPortEnterCritical
00115E  000000     NOP
4967:              		{
4968:              			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
001160  906049     MOV.B [W9+36], W0
001164  504FE2     SUB.B W0, #0x2, [W15]
001166  3A0003     BRA NZ, .L191
4969:              			{
4970:              				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
001168  EB4000     CLR.B W0
00116A  9864C0     MOV.B W0, [W9+36]
4971:              				xReturn = pdPASS;
00116C  200018     MOV #0x1, W8
4972:              			}
4973:              			else
4974:              			{
4975:              				xReturn = pdFAIL;
001162  EB0400     CLR W8
4976:              			}
4977:              		}
4978:              		taskEXIT_CRITICAL();
00116E  022604     CALL vPortExitCritical
001170  000000     NOP
4979:              
4980:              		return xReturn;
4981:              	}
001172  780008     MOV W8, W0
001174  BE044F     MOV.D [--W15], W8
001176  060000     RETURN
4982:              
4983:              #endif /* configUSE_TASK_NOTIFICATIONS */
4984:              /*-----------------------------------------------------------*/
4985:              
4986:              
4987:              static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
4988:              {
001178  BE9F88     MOV.D W8, [W15++]
00117A  781F8A     MOV W10, [W15++]
00117C  780400     MOV W0, W8
00117E  780501     MOV W1, W10
4989:              TickType_t xTimeToWake;
4990:              const TickType_t xConstTickCount = xTickCount;
001180  8042B9     MOV xTickCount, W9
4991:              
4992:              	#if( INCLUDE_xTaskAbortDelay == 1 )
4993:              	{
4994:              		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4995:              		reset to pdFALSE so it can be detected as having been set to pdTRUE
4996:              		when the task leaves the Blocked state. */
4997:              		pxCurrentTCB->ucDelayAborted = pdFALSE;
4998:              	}
4999:              	#endif
5000:              
5001:              	/* Remove the task from the ready list before adding it to the blocked list
5002:              	as the same list item is used for both lists. */
5003:              	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
001182  EC8850     INC2 pxCurrentTCB, WREG
001184  022788     CALL uxListRemove
001186  000000     NOP
5004:              	{
5005:              		/* The current task must be in a ready list, so there is no need to
5006:              		check, and the port reset macro can be called directly. */
5007:              		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
5008:              	}
5009:              	else
5010:              	{
5011:              		mtCOVERAGE_TEST_MARKER();
5012:              	}
5013:              
5014:              	#if ( INCLUDE_vTaskSuspend == 1 )
5015:              	{
5016:              		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
001188  440FE1     ADD W8, #0x1, [W15]
00118A  3A0008     BRA NZ, .L195
00118C  E0000A     CP0 W10
00118E  320006     BRA Z, .L195
5017:              		{
5018:              			/* Add the task to the suspended task list instead of a delayed task
5019:              			list to ensure it is not woken by a timing event.  It will block
5020:              			indefinitely. */
5021:              			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
001190  804281     MOV pxCurrentTCB, W1
001192  E88081     INC2 W1, W1
001194  21CFC0     MOV #0x1CFC, W0
001196  02274E     CALL vListInsertEnd
001198  000000     NOP
00119A  370014     BRA .L194
5022:              		}
5023:              		else
5024:              		{
5025:              			/* Calculate the time at which the task should be woken if the event
5026:              			does not occur.  This may overflow but this doesn't matter, the
5027:              			kernel will manage it correctly. */
5028:              			xTimeToWake = xConstTickCount + xTicksToWait;
00119C  440409     ADD W8, W9, W8
5029:              
5030:              			/* The list item will be inserted in wake time order. */
5031:              			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
00119E  804280     MOV pxCurrentTCB, W0
0011A0  980018     MOV W8, [W0+2]
5032:              
5033:              			if( xTimeToWake < xConstTickCount )
0011A2  548F88     SUB W9, W8, [W15]
0011A4  360006     BRA LEU, .L197
5034:              			{
5035:              				/* Wake time has overflowed.  Place this item in the overflow
5036:              				list. */
5037:              				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
0011A6  804281     MOV pxCurrentTCB, W1
0011A8  804360     MOV pxOverflowDelayedTaskList, W0
0011AA  E88081     INC2 W1, W1
0011AC  022762     CALL vListInsert
0011AE  000000     NOP
0011B0  370009     BRA .L194
5038:              			}
5039:              			else
5040:              			{
5041:              				/* The wake time has not overflowed, so the current block list
5042:              				is used. */
5043:              				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
0011B2  804281     MOV pxCurrentTCB, W1
0011B4  804350     MOV pxDelayedTaskList, W0
0011B6  E88081     INC2 W1, W1
0011B8  022762     CALL vListInsert
0011BA  000000     NOP
5044:              
5045:              				/* If the task entering the blocked state was placed at the
5046:              				head of the list of blocked tasks then xNextTaskUnblockTime
5047:              				needs to be updated too. */
5048:              				if( xTimeToWake < xNextTaskUnblockTime )
0011BC  804320     MOV xNextTaskUnblockTime, W0
0011BE  500F88     SUB W0, W8, [W15]
0011C0  360001     BRA LEU, .L194
5049:              				{
5050:              					xNextTaskUnblockTime = xTimeToWake;
0011C2  884328     MOV W8, xNextTaskUnblockTime
5051:              				}
5052:              				else
5053:              				{
5054:              					mtCOVERAGE_TEST_MARKER();
5055:              				}
5056:              			}
5057:              		}
5058:              	}
5059:              	#else /* INCLUDE_vTaskSuspend */
5060:              	{
5061:              		/* Calculate the time at which the task should be woken if the event
5062:              		does not occur.  This may overflow but this doesn't matter, the kernel
5063:              		will manage it correctly. */
5064:              		xTimeToWake = xConstTickCount + xTicksToWait;
5065:              
5066:              		/* The list item will be inserted in wake time order. */
5067:              		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5068:              
5069:              		if( xTimeToWake < xConstTickCount )
5070:              		{
5071:              			/* Wake time has overflowed.  Place this item in the overflow list. */
5072:              			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5073:              		}
5074:              		else
5075:              		{
5076:              			/* The wake time has not overflowed, so the current block list is used. */
5077:              			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5078:              
5079:              			/* If the task entering the blocked state was placed at the head of the
5080:              			list of blocked tasks then xNextTaskUnblockTime needs to be updated
5081:              			too. */
5082:              			if( xTimeToWake < xNextTaskUnblockTime )
5083:              			{
5084:              				xNextTaskUnblockTime = xTimeToWake;
5085:              			}
5086:              			else
5087:              			{
5088:              				mtCOVERAGE_TEST_MARKER();
5089:              			}
5090:              		}
5091:              
5092:              		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5093:              		( void ) xCanBlockIndefinitely;
5094:              	}
5095:              	#endif /* INCLUDE_vTaskSuspend */
5096:              }
0011C4  78054F     MOV [--W15], W10
0011C6  BE044F     MOV.D [--W15], W8
0011C8  060000     RETURN
5097:              
5098:              /* Code below here allows additional code to be inserted into this source file,
5099:              especially where access to file scope functions and data is needed (for example
5100:              when performing module tests). */
5101:              
5102:              #ifdef FREERTOS_MODULE_TEST
5103:              	#include "tasks_test_access_functions.h"
5104:              #endif
5105:              
5106:              
5107:              #if( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )
5108:              
5109:              	#include "freertos_tasks_c_additions.h"
5110:              
5111:              	#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
5112:              		static void freertos_tasks_c_additions_init( void )
5113:              		{
5114:              			FREERTOS_TASKS_C_ADDITIONS_INIT();
5115:              		}
5116:              	#endif
5117:              
5118:              #endif
5119:              
5120:              
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Source/queue.c  -----------------------------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                #include <stdlib.h>
29:                #include <string.h>
30:                
31:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
32:                all the API functions to use the MPU wrappers.  That should only be done when
33:                task.h is included from an application file. */
34:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
35:                
36:                #include "FreeRTOS.h"
37:                #include "task.h"
38:                #include "queue.h"
39:                
40:                #if ( configUSE_CO_ROUTINES == 1 )
41:                	#include "croutine.h"
42:                #endif
43:                
44:                /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
45:                because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
46:                for the header files above, but not in this file, in order to generate the
47:                correct privileged Vs unprivileged linkage and placement. */
48:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
49:                
50:                
51:                /* Constants used with the cRxLock and cTxLock structure members. */
52:                #define queueUNLOCKED					( ( int8_t ) -1 )
53:                #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
54:                
55:                /* When the Queue_t structure is used to represent a base queue its pcHead and
56:                pcTail members are used as pointers into the queue storage area.  When the
57:                Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
58:                not necessary, and the pcHead pointer is set to NULL to indicate that the
59:                structure instead holds a pointer to the mutex holder (if any).  Map alternative
60:                names to the pcHead and structure member to ensure the readability of the code
61:                is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
62:                a union as their usage is mutually exclusive dependent on what the queue is
63:                being used for. */
64:                #define uxQueueType						pcHead
65:                #define queueQUEUE_IS_MUTEX				NULL
66:                
67:                typedef struct QueuePointers
68:                {
69:                	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
70:                	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
71:                } QueuePointers_t;
72:                
73:                typedef struct SemaphoreData
74:                {
75:                	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
76:                	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
77:                } SemaphoreData_t;
78:                
79:                /* Semaphores do not actually store or copy data, so have an item size of
80:                zero. */
81:                #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
82:                #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
83:                
84:                #if( configUSE_PREEMPTION == 0 )
85:                	/* If the cooperative scheduler is being used then a yield should not be
86:                	performed just because a higher priority task has been woken. */
87:                	#define queueYIELD_IF_USING_PREEMPTION()
88:                #else
89:                	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
90:                #endif
91:                
92:                /*
93:                 * Definition of the queue used by the scheduler.
94:                 * Items are queued by copy, not reference.  See the following link for the
95:                 * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
96:                 */
97:                typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel aware debuggers. */
98:                {
99:                	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
100:               	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
101:               
102:               	union
103:               	{
104:               		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
105:               		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaphore. */
106:               	} u;
107:               
108:               	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
109:               	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
110:               
111:               	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
112:               	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
113:               	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
114:               
115:               	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
116:               	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
117:               
118:               	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
119:               		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
120:               	#endif
121:               
122:               	#if ( configUSE_QUEUE_SETS == 1 )
123:               		struct QueueDefinition *pxQueueSetContainer;
124:               	#endif
125:               
126:               	#if ( configUSE_TRACE_FACILITY == 1 )
127:               		UBaseType_t uxQueueNumber;
128:               		uint8_t ucQueueType;
129:               	#endif
130:               
131:               } xQUEUE;
132:               
133:               /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
134:               name below to enable the use of older kernel aware debuggers. */
135:               typedef xQUEUE Queue_t;
136:               
137:               /*-----------------------------------------------------------*/
138:               
139:               /*
140:                * The queue registry is just a means for kernel aware debuggers to locate
141:                * queue structures.  It has no other purpose so is an optional component.
142:                */
143:               #if ( configQUEUE_REGISTRY_SIZE > 0 )
144:               
145:               	/* The type stored within the queue registry array.  This allows a name
146:               	to be assigned to each queue making kernel aware debugging a little
147:               	more user friendly. */
148:               	typedef struct QUEUE_REGISTRY_ITEM
149:               	{
150:               		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
151:               		QueueHandle_t xHandle;
152:               	} xQueueRegistryItem;
153:               
154:               	/* The old xQueueRegistryItem name is maintained above then typedefed to the
155:               	new xQueueRegistryItem name below to enable the use of older kernel aware
156:               	debuggers. */
157:               	typedef xQueueRegistryItem QueueRegistryItem_t;
158:               
159:               	/* The queue registry is simply an array of QueueRegistryItem_t structures.
160:               	The pcQueueName member of a structure being NULL is indicative of the
161:               	array position being vacant. */
162:               	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
163:               
164:               #endif /* configQUEUE_REGISTRY_SIZE */
165:               
166:               /*
167:                * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
168:                * prevent an ISR from adding or removing items to the queue, but does prevent
169:                * an ISR from removing tasks from the queue event lists.  If an ISR finds a
170:                * queue is locked it will instead increment the appropriate queue lock count
171:                * to indicate that a task may require unblocking.  When the queue in unlocked
172:                * these lock counts are inspected, and the appropriate action taken.
173:                */
174:               static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
175:               
176:               /*
177:                * Uses a critical section to determine if there is any data in a queue.
178:                *
179:                * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
180:                */
181:               static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
182:               
183:               /*
184:                * Uses a critical section to determine if there is any space in a queue.
185:                *
186:                * @return pdTRUE if there is no space, otherwise pdFALSE;
187:                */
188:               static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
189:               
190:               /*
191:                * Copies an item into the queue, either at the front of the queue or the
192:                * back of the queue.
193:                */
194:               static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
195:               
196:               /*
197:                * Copies an item out of a queue.
198:                */
199:               static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
200:               
201:               #if ( configUSE_QUEUE_SETS == 1 )
202:               	/*
203:               	 * Checks to see if a queue is a member of a queue set, and if so, notifies
204:               	 * the queue set that the queue contains data.
205:               	 */
206:               	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
207:               #endif
208:               
209:               /*
210:                * Called after a Queue_t structure has been allocated either statically or
211:                * dynamically to fill in the structure's members.
212:                */
213:               static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
214:               
215:               /*
216:                * Mutexes are a special type of queue.  When a mutex is created, first the
217:                * queue is created, then prvInitialiseMutex() is called to configure the queue
218:                * as a mutex.
219:                */
220:               #if( configUSE_MUTEXES == 1 )
221:               	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
222:               #endif
223:               
224:               #if( configUSE_MUTEXES == 1 )
225:               	/*
226:               	 * If a task waiting for a mutex causes the mutex holder to inherit a
227:               	 * priority, but the waiting task times out, then the holder should
228:               	 * disinherit the priority - but only down to the highest priority of any
229:               	 * other tasks that are waiting for the same mutex.  This function returns
230:               	 * that priority.
231:               	 */
232:               	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
233:               #endif
234:               /*-----------------------------------------------------------*/
235:               
236:               /*
237:                * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
238:                * accessing the queue event lists.
239:                */
240:               #define prvLockQueue( pxQueue )								\
241:               	taskENTER_CRITICAL();									\
242:               	{														\
243:               		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
244:               		{													\
245:               			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
246:               		}													\
247:               		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
248:               		{													\
249:               			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
250:               		}													\
251:               	}														\
252:               	taskEXIT_CRITICAL()
253:               /*-----------------------------------------------------------*/
254:               
255:               BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
256:               {
0014A2  BE9F88     MOV.D W8, [W15++]
0014A4  BE0400     MOV.D W0, W8
257:               Queue_t * const pxQueue = xQueue;
258:               
259:               	configASSERT( pxQueue );
260:               
261:               	taskENTER_CRITICAL();
0014A6  0225F4     CALL vPortEnterCritical
0014A8  000000     NOP
262:               	{
263:               		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
0014AA  780018     MOV [W8], W0
0014AC  900978     MOV [W8+30], W2
0014AE  901088     MOV [W8+32], W1
0014B0  B98A02     MUL.SS W1, W2, W4
0014B2  400184     ADD W0, W4, W3
0014B4  980423     MOV W3, [W8+4]
264:               		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
0014B6  EB0180     CLR W3
0014B8  980C63     MOV W3, [W8+28]
265:               		pxQueue->pcWriteTo = pxQueue->pcHead;
0014BA  980410     MOV W0, [W8+2]
266:               		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
0014BC  E90102     DEC W2, W2
0014BE  B99101     MUL.SS W2, W1, W2
0014C0  400082     ADD W0, W2, W1
0014C2  980431     MOV W1, [W8+6]
267:               		pxQueue->cRxLock = queueUNLOCKED;
0014C4  EBC000     SETM.B W0
0014C6  986420     MOV.B W0, [W8+34]
268:               		pxQueue->cTxLock = queueUNLOCKED;
0014C8  986430     MOV.B W0, [W8+35]
269:               
270:               		if( xNewQueue == pdFALSE )
0014CA  E00009     CP0 W9
0014CC  3A000C     BRA NZ, .L22
271:               		{
272:               			/* If there are tasks blocked waiting to read from the queue, then
273:               			the tasks will remain blocked as after this function exits the queue
274:               			will still be empty.  If there are tasks blocked waiting to write to
275:               			the queue, then one should be unblocked as after this function exits
276:               			it will be possible to write to it. */
277:               			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
0014CE  900048     MOV [W8+8], W0
0014D0  E00000     CP0 W0
0014D2  32000F     BRA Z, .L23
278:               			{
279:               				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
0014D4  440068     ADD W8, #0x8, W0
0014D6  020B28     CALL xTaskRemoveFromEventList
0014D8  000000     NOP
0014DA  E00000     CP0 W0
0014DC  32000A     BRA Z, .L23
280:               				{
281:               					queueYIELD_IF_USING_PREEMPTION();
0014DE  02286C     CALL .Letext0, .LFE2, _vPortYield
0014E0  000000     NOP
0014E2  000000     NOP
0014E4  370006     BRA .L23
282:               				}
283:               				else
284:               				{
285:               					mtCOVERAGE_TEST_MARKER();
286:               				}
287:               			}
288:               			else
289:               			{
290:               				mtCOVERAGE_TEST_MARKER();
291:               			}
292:               		}
293:               		else
294:               		{
295:               			/* Ensure the event queues start in the correct state. */
296:               			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
0014E6  440068     ADD W8, #0x8, W0
0014E8  022738     CALL vListInitialise
0014EA  000000     NOP
297:               			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
0014EC  440072     ADD W8, #0x12, W0
0014EE  022738     CALL vListInitialise
0014F0  000000     NOP
298:               		}
299:               	}
300:               	taskEXIT_CRITICAL();
0014F2  022604     CALL vPortExitCritical
0014F4  000000     NOP
301:               
302:               	/* A value is returned for calling semantic consistency with previous
303:               	versions. */
304:               	return pdPASS;
305:               }
0014F6  200010     MOV #0x1, W0
0014F8  BE044F     MOV.D [--W15], W8
0014FA  060000     RETURN
306:               /*-----------------------------------------------------------*/
307:               
308:               #if( configSUPPORT_STATIC_ALLOCATION == 1 )
309:               
310:               	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
311:               	{
312:               	Queue_t *pxNewQueue;
313:               
314:               		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
315:               
316:               		/* The StaticQueue_t structure and the queue storage area must be
317:               		supplied. */
318:               		configASSERT( pxStaticQueue != NULL );
319:               
320:               		/* A queue storage area should be provided if the item size is not 0, and
321:               		should not be provided if the item size is 0. */
322:               		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
323:               		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
324:               
325:               		#if( configASSERT_DEFINED == 1 )
326:               		{
327:               			/* Sanity check that the size of the structure used to declare a
328:               			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
329:               			the real queue and semaphore structures. */
330:               			volatile size_t xSize = sizeof( StaticQueue_t );
331:               			configASSERT( xSize == sizeof( Queue_t ) );
332:               			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
333:               		}
334:               		#endif /* configASSERT_DEFINED */
335:               
336:               		/* The address of a statically allocated queue was passed in, use it.
337:               		The address of a statically allocated storage area was also passed in
338:               		but is already set. */
339:               		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
340:               
341:               		if( pxNewQueue != NULL )
342:               		{
343:               			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
344:               			{
345:               				/* Queues can be allocated wither statically or dynamically, so
346:               				note this queue was allocated statically in case the queue is
347:               				later deleted. */
348:               				pxNewQueue->ucStaticallyAllocated = pdTRUE;
349:               			}
350:               			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
351:               
352:               			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
353:               		}
354:               		else
355:               		{
356:               			traceQUEUE_CREATE_FAILED( ucQueueType );
357:               			mtCOVERAGE_TEST_MARKER();
358:               		}
359:               
360:               		return pxNewQueue;
361:               	}
362:               
363:               #endif /* configSUPPORT_STATIC_ALLOCATION */
364:               /*-----------------------------------------------------------*/
365:               
366:               #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
367:               
368:               	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
369:               	{
001512  BE9F88     MOV.D W8, [W15++]
001514  BE9F8A     MOV.D W10, [W15++]
001516  780500     MOV W0, W10
001518  780481     MOV W1, W9
00151A  784582     MOV.B W2, W11
370:               	Queue_t *pxNewQueue;
371:               	size_t xQueueSizeInBytes;
372:               	uint8_t *pucQueueStorage;
373:               
374:               		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
375:               
376:               		if( uxItemSize == ( UBaseType_t ) 0 )
00151E  E00009     CP0 W9
001520  320001     BRA Z, .L28
377:               		{
378:               			/* There is not going to be a queue storage area. */
379:               			xQueueSizeInBytes = ( size_t ) 0;
00151C  EB0000     CLR W0
380:               		}
381:               		else
382:               		{
383:               			/* Allocate enough space to hold the maximum number of items that
384:               			can be in the queue at any time. */
385:               			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
001522  B9C80A     MUL.SS W9, W10, W0
386:               		}
387:               
388:               		/* Allocate the queue and storage area.  Justification for MISRA
389:               		deviation as follows:  pvPortMalloc() always ensures returned memory
390:               		blocks are aligned per the requirements of the MCU stack.  In this case
391:               		pvPortMalloc() must return a pointer that is guaranteed to meet the
392:               		alignment requirements of the Queue_t structure - which in this case
393:               		is an int8_t *.  Therefore, whenever the stack alignment requirements
394:               		are greater than or equal to the pointer to char requirements the cast
395:               		is safe.  In other cases alignment requirements are not strict (one or
396:               		two bytes). */
397:               		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
001524  B00240     ADD #0x24, W0
001526  0228C0     CALL pvPortMalloc
001528  000000     NOP
00152A  780400     MOV W0, W8
398:               
399:               		if( pxNewQueue != NULL )
00152C  E00008     CP0 W8
00152E  320007     BRA Z, .L29
400:               		{
401:               			/* Jump past the queue structure to find the location of the queue
402:               			storage area. */
403:               			pucQueueStorage = ( uint8_t * ) pxNewQueue;
404:               			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
001530  200242     MOV #0x24, W2
001532  410108     ADD W2, W8, W2
405:               
406:               			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
407:               			{
408:               				/* Queues can be created either statically or dynamically, so
409:               				note this task was created dynamically in case it is later
410:               				deleted. */
411:               				pxNewQueue->ucStaticallyAllocated = pdFALSE;
412:               			}
413:               			#endif /* configSUPPORT_STATIC_ALLOCATION */
414:               
415:               			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
001534  780208     MOV W8, W4
001536  78418B     MOV.B W11, W3
001538  780089     MOV W9, W1
00153A  78000A     MOV W10, W0
00153C  07FFDF     RCALL _prvInitialiseNewQueue, .LFE0, .LFB2
416:               		}
417:               		else
418:               		{
419:               			traceQUEUE_CREATE_FAILED( ucQueueType );
420:               			mtCOVERAGE_TEST_MARKER();
421:               		}
422:               
423:               		return pxNewQueue;
424:               	}
00153E  780008     MOV W8, W0
001540  BE054F     MOV.D [--W15], W10
001542  BE044F     MOV.D [--W15], W8
001544  060000     RETURN
425:               
426:               #endif /* configSUPPORT_STATIC_ALLOCATION */
427:               /*-----------------------------------------------------------*/
428:               
429:               static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
430:               {
431:               	/* Remove compiler warnings about unused parameters should
432:               	configUSE_TRACE_FACILITY not be set to 1. */
433:               	( void ) ucQueueType;
434:               
435:               	if( uxItemSize == ( UBaseType_t ) 0 )
0014FC  E00001     CP0 W1
0014FE  3A0002     BRA NZ, .L25
436:               	{
437:               		/* No RAM was allocated for the queue storage area, but PC head cannot
438:               		be set to NULL because NULL is used as a key to say the queue is used as
439:               		a mutex.  Therefore just set pcHead to point to the queue as a benign
440:               		value that is known to be within the memory map. */
441:               		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
001500  780A04     MOV W4, [W4]
001502  370001     BRA .L26
442:               	}
443:               	else
444:               	{
445:               		/* Set the head to the start of the queue storage area. */
446:               		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
001504  780A02     MOV W2, [W4]
447:               	}
448:               
449:               	/* Initialise the queue members as described where the queue type is
450:               	defined. */
451:               	pxNewQueue->uxLength = uxQueueLength;
001506  980A70     MOV W0, [W4+30]
452:               	pxNewQueue->uxItemSize = uxItemSize;
001508  981201     MOV W1, [W4+32]
453:               	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
00150A  200011     MOV #0x1, W1
00150C  780004     MOV W4, W0
00150E  07FFC9     RCALL xQueueGenericReset
454:               
455:               	#if ( configUSE_TRACE_FACILITY == 1 )
456:               	{
457:               		pxNewQueue->ucQueueType = ucQueueType;
458:               	}
459:               	#endif /* configUSE_TRACE_FACILITY */
460:               
461:               	#if( configUSE_QUEUE_SETS == 1 )
462:               	{
463:               		pxNewQueue->pxQueueSetContainer = NULL;
464:               	}
465:               	#endif /* configUSE_QUEUE_SETS */
466:               
467:               	traceQUEUE_CREATE( pxNewQueue );
468:               }
001510  060000     RETURN
469:               /*-----------------------------------------------------------*/
470:               
471:               #if( configUSE_MUTEXES == 1 )
472:               
473:               	static void prvInitialiseMutex( Queue_t *pxNewQueue )
474:               	{
475:               		if( pxNewQueue != NULL )
476:               		{
477:               			/* The queue create function will set all the queue structure members
478:               			correctly for a generic queue, but this function is creating a
479:               			mutex.  Overwrite those members that need to be set differently -
480:               			in particular the information required for priority inheritance. */
481:               			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
482:               			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
483:               
484:               			/* In case this is a recursive mutex. */
485:               			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
486:               
487:               			traceCREATE_MUTEX( pxNewQueue );
488:               
489:               			/* Start with the semaphore in the expected state. */
490:               			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
491:               		}
492:               		else
493:               		{
494:               			traceCREATE_MUTEX_FAILED();
495:               		}
496:               	}
497:               
498:               #endif /* configUSE_MUTEXES */
499:               /*-----------------------------------------------------------*/
500:               
501:               #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
502:               
503:               	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
504:               	{
505:               	QueueHandle_t xNewQueue;
506:               	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
507:               
508:               		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
509:               		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
510:               
511:               		return xNewQueue;
512:               	}
513:               
514:               #endif /* configUSE_MUTEXES */
515:               /*-----------------------------------------------------------*/
516:               
517:               #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
518:               
519:               	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
520:               	{
521:               	QueueHandle_t xNewQueue;
522:               	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
523:               
524:               		/* Prevent compiler warnings about unused parameters if
525:               		configUSE_TRACE_FACILITY does not equal 1. */
526:               		( void ) ucQueueType;
527:               
528:               		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
529:               		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
530:               
531:               		return xNewQueue;
532:               	}
533:               
534:               #endif /* configUSE_MUTEXES */
535:               /*-----------------------------------------------------------*/
536:               
537:               #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
538:               
539:               	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
540:               	{
541:               	TaskHandle_t pxReturn;
542:               	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
543:               
544:               		/* This function is called by xSemaphoreGetMutexHolder(), and should not
545:               		be called directly.  Note:  This is a good way of determining if the
546:               		calling task is the mutex holder, but not a good way of determining the
547:               		identity of the mutex holder, as the holder may change between the
548:               		following critical section exiting and the function returning. */
549:               		taskENTER_CRITICAL();
550:               		{
551:               			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
552:               			{
553:               				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
554:               			}
555:               			else
556:               			{
557:               				pxReturn = NULL;
558:               			}
559:               		}
560:               		taskEXIT_CRITICAL();
561:               
562:               		return pxReturn;
563:               	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
564:               
565:               #endif
566:               /*-----------------------------------------------------------*/
567:               
568:               #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
569:               
570:               	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
571:               	{
572:               	TaskHandle_t pxReturn;
573:               
574:               		configASSERT( xSemaphore );
575:               
576:               		/* Mutexes cannot be used in interrupt service routines, so the mutex
577:               		holder should not change in an ISR, and therefore a critical section is
578:               		not required here. */
579:               		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
580:               		{
581:               			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
582:               		}
583:               		else
584:               		{
585:               			pxReturn = NULL;
586:               		}
587:               
588:               		return pxReturn;
589:               	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
590:               
591:               #endif
592:               /*-----------------------------------------------------------*/
593:               
594:               #if ( configUSE_RECURSIVE_MUTEXES == 1 )
595:               
596:               	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
597:               	{
598:               	BaseType_t xReturn;
599:               	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
600:               
601:               		configASSERT( pxMutex );
602:               
603:               		/* If this is the task that holds the mutex then xMutexHolder will not
604:               		change outside of this task.  If this task does not hold the mutex then
605:               		pxMutexHolder can never coincidentally equal the tasks handle, and as
606:               		this is the only condition we are interested in it does not matter if
607:               		pxMutexHolder is accessed simultaneously by another task.  Therefore no
608:               		mutual exclusion is required to test the pxMutexHolder variable. */
609:               		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
610:               		{
611:               			traceGIVE_MUTEX_RECURSIVE( pxMutex );
612:               
613:               			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
614:               			the task handle, therefore no underflow check is required.  Also,
615:               			uxRecursiveCallCount is only modified by the mutex holder, and as
616:               			there can only be one, no mutual exclusion is required to modify the
617:               			uxRecursiveCallCount member. */
618:               			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
619:               
620:               			/* Has the recursive call count unwound to 0? */
621:               			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
622:               			{
623:               				/* Return the mutex.  This will automatically unblock any other
624:               				task that might be waiting to access the mutex. */
625:               				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
626:               			}
627:               			else
628:               			{
629:               				mtCOVERAGE_TEST_MARKER();
630:               			}
631:               
632:               			xReturn = pdPASS;
633:               		}
634:               		else
635:               		{
636:               			/* The mutex cannot be given because the calling task is not the
637:               			holder. */
638:               			xReturn = pdFAIL;
639:               
640:               			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
641:               		}
642:               
643:               		return xReturn;
644:               	}
645:               
646:               #endif /* configUSE_RECURSIVE_MUTEXES */
647:               /*-----------------------------------------------------------*/
648:               
649:               #if ( configUSE_RECURSIVE_MUTEXES == 1 )
650:               
651:               	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
652:               	{
653:               	BaseType_t xReturn;
654:               	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
655:               
656:               		configASSERT( pxMutex );
657:               
658:               		/* Comments regarding mutual exclusion as per those within
659:               		xQueueGiveMutexRecursive(). */
660:               
661:               		traceTAKE_MUTEX_RECURSIVE( pxMutex );
662:               
663:               		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
664:               		{
665:               			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
666:               			xReturn = pdPASS;
667:               		}
668:               		else
669:               		{
670:               			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
671:               
672:               			/* pdPASS will only be returned if the mutex was successfully
673:               			obtained.  The calling task may have entered the Blocked state
674:               			before reaching here. */
675:               			if( xReturn != pdFAIL )
676:               			{
677:               				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
678:               			}
679:               			else
680:               			{
681:               				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
682:               			}
683:               		}
684:               
685:               		return xReturn;
686:               	}
687:               
688:               #endif /* configUSE_RECURSIVE_MUTEXES */
689:               /*-----------------------------------------------------------*/
690:               
691:               #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
692:               
693:               	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
694:               	{
695:               	QueueHandle_t xHandle;
696:               
697:               		configASSERT( uxMaxCount != 0 );
698:               		configASSERT( uxInitialCount <= uxMaxCount );
699:               
700:               		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
701:               
702:               		if( xHandle != NULL )
703:               		{
704:               			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
705:               
706:               			traceCREATE_COUNTING_SEMAPHORE();
707:               		}
708:               		else
709:               		{
710:               			traceCREATE_COUNTING_SEMAPHORE_FAILED();
711:               		}
712:               
713:               		return xHandle;
714:               	}
715:               
716:               #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
717:               /*-----------------------------------------------------------*/
718:               
719:               #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
720:               
721:               	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
722:               	{
723:               	QueueHandle_t xHandle;
724:               
725:               		configASSERT( uxMaxCount != 0 );
726:               		configASSERT( uxInitialCount <= uxMaxCount );
727:               
728:               		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
729:               
730:               		if( xHandle != NULL )
731:               		{
732:               			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
733:               
734:               			traceCREATE_COUNTING_SEMAPHORE();
735:               		}
736:               		else
737:               		{
738:               			traceCREATE_COUNTING_SEMAPHORE_FAILED();
739:               		}
740:               
741:               		return xHandle;
742:               	}
743:               
744:               #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
745:               /*-----------------------------------------------------------*/
746:               
747:               BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
748:               {
001546  FA0006     LNK #0x6
001548  BE9F88     MOV.D W8, [W15++]
00154A  BE9F8A     MOV.D W10, [W15++]
00154C  781F8C     MOV W12, [W15++]
00154E  780400     MOV W0, W8
001550  780601     MOV W1, W12
001552  9FBFA2     MOV W2, [W15-12]
001554  780503     MOV W3, W10
749:               BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
001556  EB0480     CLR W9
750:               TimeOut_t xTimeOut;
751:               Queue_t * const pxQueue = xQueue;
752:               
753:               	configASSERT( pxQueue );
754:               	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
755:               	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
756:               	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
757:               	{
758:               		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
759:               	}
760:               	#endif
761:               
762:               
763:               	/*lint -save -e904 This function relaxes the coding standard somewhat to
764:               	allow return statements within the function itself.  This is done in the
765:               	interest of execution time efficiency. */
766:               	for( ;; )
767:               	{
768:               		taskENTER_CRITICAL();
00155A  0225F4     CALL vPortEnterCritical
00155C  000000     NOP
769:               		{
770:               			/* Is there room on the queue now?  The running task must be the
771:               			highest priority task wanting to access the queue.  If the head item
772:               			in the queue is to be overwritten then it does not matter if the
773:               			queue is full. */
774:               			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
00155E  9008E8     MOV [W8+28], W1
001560  900878     MOV [W8+30], W0
001562  508F80     SUB W1, W0, [W15]
001564  390002     BRA NC, .L33
001566  550FE2     SUB W10, #0x2, [W15]
001568  3A0019     BRA NZ, .L34
775:               			{
776:               				traceQUEUE_SEND( pxQueue );
777:               
778:               				#if ( configUSE_QUEUE_SETS == 1 )
779:               				{
780:               				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
781:               
782:               					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
783:               
784:               					if( pxQueue->pxQueueSetContainer != NULL )
785:               					{
786:               						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
787:               						{
788:               							/* Do not notify the queue set as an existing item
789:               							was overwritten in the queue so the number of items
790:               							in the queue has not changed. */
791:               							mtCOVERAGE_TEST_MARKER();
792:               						}
793:               						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
794:               						{
795:               							/* The queue is a member of a queue set, and posting
796:               							to the queue set caused a higher priority task to
797:               							unblock. A context switch is required. */
798:               							queueYIELD_IF_USING_PREEMPTION();
799:               						}
800:               						else
801:               						{
802:               							mtCOVERAGE_TEST_MARKER();
803:               						}
804:               					}
805:               					else
806:               					{
807:               						/* If there was a task waiting for data to arrive on the
808:               						queue then unblock it now. */
809:               						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
810:               						{
811:               							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
812:               							{
813:               								/* The unblocked task has a priority higher than
814:               								our own so yield immediately.  Yes it is ok to
815:               								do this from within the critical section - the
816:               								kernel takes care of that. */
817:               								queueYIELD_IF_USING_PREEMPTION();
818:               							}
819:               							else
820:               							{
821:               								mtCOVERAGE_TEST_MARKER();
822:               							}
823:               						}
824:               						else if( xYieldRequired != pdFALSE )
825:               						{
826:               							/* This path is a special case that will only get
827:               							executed if the task was holding multiple mutexes
828:               							and the mutexes were given back in an order that is
829:               							different to that in which they were taken. */
830:               							queueYIELD_IF_USING_PREEMPTION();
831:               						}
832:               						else
833:               						{
834:               							mtCOVERAGE_TEST_MARKER();
835:               						}
836:               					}
837:               				}
838:               				#else /* configUSE_QUEUE_SETS */
839:               				{
840:               					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
00156A  78010A     MOV W10, W2
00156C  78008C     MOV W12, W1
00156E  780008     MOV W8, W0
001570  07FEFD     RCALL .Letext0, .LFE4, _prvCopyDataToQueue, .Ltext0, .LFB15
841:               
842:               					/* If there was a task waiting for data to arrive on the
843:               					queue then unblock it now. */
844:               					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001572  900898     MOV [W8+18], W1
001574  E00001     CP0 W1
001576  320009     BRA Z, .L35
845:               					{
846:               						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001578  440072     ADD W8, #0x12, W0
00157A  020B28     CALL xTaskRemoveFromEventList
00157C  000000     NOP
00157E  E00000     CP0 W0
001580  320009     BRA Z, .L36
847:               						{
848:               							/* The unblocked task has a priority higher than
849:               							our own so yield immediately.  Yes it is ok to do
850:               							this from within the critical section - the kernel
851:               							takes care of that. */
852:               							queueYIELD_IF_USING_PREEMPTION();
001582  02286C     CALL .Letext0, .LFE2, _vPortYield
001584  000000     NOP
001586  000000     NOP
001588  370005     BRA .L36
853:               						}
854:               						else
855:               						{
856:               							mtCOVERAGE_TEST_MARKER();
857:               						}
858:               					}
859:               					else if( xYieldRequired != pdFALSE )
00158A  E00000     CP0 W0
00158C  320003     BRA Z, .L36
860:               					{
861:               						/* This path is a special case that will only get
862:               						executed if the task was holding multiple mutexes and
863:               						the mutexes were given back in an order that is
864:               						different to that in which they were taken. */
865:               						queueYIELD_IF_USING_PREEMPTION();
00158E  02286C     CALL .Letext0, .LFE2, _vPortYield
001590  000000     NOP
001592  000000     NOP
866:               					}
867:               					else
868:               					{
869:               						mtCOVERAGE_TEST_MARKER();
870:               					}
871:               				}
872:               				#endif /* configUSE_QUEUE_SETS */
873:               
874:               				taskEXIT_CRITICAL();
001594  022604     CALL vPortExitCritical
001596  000000     NOP
875:               				return pdPASS;
001598  200010     MOV #0x1, W0
00159A  370041     BRA .L37
876:               			}
877:               			else
878:               			{
879:               				if( xTicksToWait == ( TickType_t ) 0 )
00159C  97B82F     MOV [W15-12], W0
00159E  E00000     CP0 W0
0015A0  3A0004     BRA NZ, .L38
880:               				{
881:               					/* The queue was full and no block time is specified (or
882:               					the block time has expired) so leave now. */
883:               					taskEXIT_CRITICAL();
0015A2  022604     CALL vPortExitCritical
0015A4  000000     NOP
884:               
885:               					/* Return to the original privilege level before exiting
886:               					the function. */
887:               					traceQUEUE_SEND_FAILED( pxQueue );
888:               					return errQUEUE_FULL;
0015A6  EB0000     CLR W0
0015A8  37003A     BRA .L37
889:               				}
890:               				else if( xEntryTimeSet == pdFALSE )
0015AA  E00009     CP0 W9
0015AC  3A0004     BRA NZ, .L39
891:               				{
892:               					/* The queue was full and a block time was specified so
893:               					configure the timeout structure. */
894:               					vTaskInternalSetTimeOutState( &xTimeOut );
0015AE  578070     SUB W15, #0x10, W0
0015B0  020BC6     CALL vTaskInternalSetTimeOutState
0015B2  000000     NOP
895:               					xEntryTimeSet = pdTRUE;
0015B4  200019     MOV #0x1, W9
896:               				}
897:               				else
898:               				{
899:               					/* Entry time was already set. */
900:               					mtCOVERAGE_TEST_MARKER();
901:               				}
902:               			}
903:               		}
904:               		taskEXIT_CRITICAL();
0015B6  022604     CALL vPortExitCritical
0015B8  000000     NOP
905:               
906:               		/* Interrupts and other tasks can send to and receive from the queue
907:               		now the critical section has been exited. */
908:               
909:               		vTaskSuspendAll();
0015BA  020A86     CALL vTaskSuspendAll
0015BC  000000     NOP
910:               		prvLockQueue( pxQueue );
0015BE  0225F4     CALL vPortEnterCritical
0015C0  000000     NOP
0015C2  906028     MOV.B [W8+34], W0
0015C4  404FE1     ADD.B W0, #0x1, [W15]
0015C6  3A0002     BRA NZ, .L40
0015C8  EB4000     CLR.B W0
0015CA  986420     MOV.B W0, [W8+34]
0015CC  906038     MOV.B [W8+35], W0
0015CE  404FE1     ADD.B W0, #0x1, [W15]
0015D0  3A0002     BRA NZ, .L41
0015D2  EB4000     CLR.B W0
0015D4  986430     MOV.B W0, [W8+35]
0015D6  022604     CALL vPortExitCritical
0015D8  000000     NOP
911:               
912:               		/* Update the timeout state to see if it has expired yet. */
913:               		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
0015DA  5780EC     SUB W15, #0xC, W1
0015DC  578070     SUB W15, #0x10, W0
0015DE  020BD0     CALL xTaskCheckForTimeOut
0015E0  000000     NOP
0015E2  E00000     CP0 W0
0015E4  3A0017     BRA NZ, .L42
914:               		{
915:               			if( prvIsQueueFull( pxQueue ) != pdFALSE )
0015E6  780008     MOV W8, W0
0015E8  07FF01     RCALL _prvIsQueueFull, .LFE16, .LFB20
0015EA  E00000     CP0 W0
0015EC  32000E     BRA Z, .L43
916:               			{
917:               				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
918:               				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
001558  4405E8     ADD W8, #0x8, W11
0015EE  97B8AF     MOV [W15-12], W1
0015F0  78000B     MOV W11, W0
0015F2  0212F0     CALL vTaskPlaceOnEventList
0015F4  000000     NOP
919:               
920:               				/* Unlocking the queue means queue events can effect the
921:               				event list.  It is possible that interrupts occurring now
922:               				remove this task from the event list again - but as the
923:               				scheduler is suspended the task will go onto the pending
924:               				ready last instead of the actual ready list. */
925:               				prvUnlockQueue( pxQueue );
0015F6  780008     MOV W8, W0
0015F8  07FF16     RCALL _prvUnlockQueue, .LFE18, .LFB17
926:               
927:               				/* Resuming the scheduler will move tasks from the pending
928:               				ready list into the ready list - so it is feasible that this
929:               				task is already in a ready list before it yields - in which
930:               				case the yield will not cause a context switch unless there
931:               				is also a higher priority task in the pending ready list. */
932:               				if( xTaskResumeAll() == pdFALSE )
0015FA  020E4C     CALL xTaskResumeAll
0015FC  000000     NOP
0015FE  E00000     CP0 W0
001600  3AFFAC     BRA NZ, .L47
933:               				{
934:               					portYIELD_WITHIN_API();
001602  02286C     CALL .Letext0, .LFE2, _vPortYield
001604  000000     NOP
001606  000000     NOP
001608  37FFA8     BRA .L47
935:               				}
936:               			}
937:               			else
938:               			{
939:               				/* Try again. */
940:               				prvUnlockQueue( pxQueue );
00160A  780008     MOV W8, W0
00160C  07FF0C     RCALL _prvUnlockQueue, .LFE18, .LFB17
941:               				( void ) xTaskResumeAll();
00160E  020E4C     CALL xTaskResumeAll
001610  000000     NOP
001612  37FFA3     BRA .L47
942:               			}
943:               		}
944:               		else
945:               		{
946:               			/* The timeout has expired. */
947:               			prvUnlockQueue( pxQueue );
001614  780008     MOV W8, W0
001616  07FF07     RCALL _prvUnlockQueue, .LFE18, .LFB17
948:               			( void ) xTaskResumeAll();
001618  020E4C     CALL xTaskResumeAll
00161A  000000     NOP
949:               
950:               			traceQUEUE_SEND_FAILED( pxQueue );
951:               			return errQUEUE_FULL;
00161C  EB0000     CLR W0
952:               		}
953:               	} /*lint -restore */
954:               }
00161E  78064F     MOV [--W15], W12
001620  BE054F     MOV.D [--W15], W10
001622  BE044F     MOV.D [--W15], W8
001624  FA8000     ULNK
001626  060000     RETURN
955:               /*-----------------------------------------------------------*/
956:               
957:               BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
958:               {
001628  BE9F88     MOV.D W8, [W15++]
00162A  781F8A     MOV W10, [W15++]
00162C  780480     MOV W0, W9
00162E  780502     MOV W2, W10
959:               BaseType_t xReturn;
960:               UBaseType_t uxSavedInterruptStatus;
961:               Queue_t * const pxQueue = xQueue;
962:               
963:               	configASSERT( pxQueue );
964:               	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
965:               	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
966:               
967:               	/* RTOS ports that support interrupt nesting have the concept of a maximum
968:               	system call (or maximum API call) interrupt priority.  Interrupts that are
969:               	above the maximum system call priority are kept permanently enabled, even
970:               	when the RTOS kernel is in a critical section, but cannot make any calls to
971:               	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
972:               	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
973:               	failure if a FreeRTOS API function is called from an interrupt that has been
974:               	assigned a priority above the configured maximum system call priority.
975:               	Only FreeRTOS functions that end in FromISR can be called from interrupts
976:               	that have been assigned a priority at or (logically) below the maximum
977:               	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
978:               	safe API to ensure interrupt entry is as fast and as simple as possible.
979:               	More information (albeit Cortex-M specific) is provided on the following
980:               	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
981:               	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
982:               
983:               	/* Similar to xQueueGenericSend, except without blocking if there is no room
984:               	in the queue.  Also don't directly wake a task that was blocked on a queue
985:               	read, instead return a flag to say whether a context switch is required or
986:               	not (i.e. has a task with a higher priority than us been woken by this
987:               	post). */
988:               	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
989:               	{
990:               		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
001630  900969     MOV [W9+28], W2
001632  900879     MOV [W9+30], W0
001634  510F80     SUB W2, W0, [W15]
001636  390003     BRA NC, .L49, .LBB4
00163A  518FE2     SUB W3, #0x2, [W15]
00163C  3A0018     BRA NZ, .L50, .LBE4
991:               		{
992:               			const int8_t cTxLock = pxQueue->cTxLock;
00163E  906439     MOV.B [W9+35], W8
993:               
994:               			traceQUEUE_SEND_FROM_ISR( pxQueue );
995:               
996:               			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
997:               			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
998:               			in a task disinheriting a priority and prvCopyDataToQueue() can be
999:               			called here even though the disinherit function does not check if
1000:              			the scheduler is suspended before accessing the ready lists. */
1001:              			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
001640  780103     MOV W3, W2
001642  780009     MOV W9, W0
001644  07FE93     RCALL .Letext0, .LFE4, _prvCopyDataToQueue, .Ltext0, .LFB15
1002:              
1003:              			/* The event list is not altered if the queue is locked.  This will
1004:              			be done when the queue is unlocked later. */
1005:              			if( cTxLock == queueUNLOCKED )
001646  444FE1     ADD.B W8, #0x1, [W15]
001648  3A000F     BRA NZ, .L51
1006:              			{
1007:              				#if ( configUSE_QUEUE_SETS == 1 )
1008:              				{
1009:              					if( pxQueue->pxQueueSetContainer != NULL )
1010:              					{
1011:              						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
1012:              						{
1013:              							/* The queue is a member of a queue set, and posting
1014:              							to the queue set caused a higher priority task to
1015:              							unblock.  A context switch is required. */
1016:              							if( pxHigherPriorityTaskWoken != NULL )
1017:              							{
1018:              								*pxHigherPriorityTaskWoken = pdTRUE;
1019:              							}
1020:              							else
1021:              							{
1022:              								mtCOVERAGE_TEST_MARKER();
1023:              							}
1024:              						}
1025:              						else
1026:              						{
1027:              							mtCOVERAGE_TEST_MARKER();
1028:              						}
1029:              					}
1030:              					else
1031:              					{
1032:              						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1033:              						{
1034:              							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1035:              							{
1036:              								/* The task waiting has a higher priority so
1037:              								record that a context switch is required. */
1038:              								if( pxHigherPriorityTaskWoken != NULL )
1039:              								{
1040:              									*pxHigherPriorityTaskWoken = pdTRUE;
1041:              								}
1042:              								else
1043:              								{
1044:              									mtCOVERAGE_TEST_MARKER();
1045:              								}
1046:              							}
1047:              							else
1048:              							{
1049:              								mtCOVERAGE_TEST_MARKER();
1050:              							}
1051:              						}
1052:              						else
1053:              						{
1054:              							mtCOVERAGE_TEST_MARKER();
1055:              						}
1056:              					}
1057:              				}
1058:              				#else /* configUSE_QUEUE_SETS */
1059:              				{
1060:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00164A  900899     MOV [W9+18], W1
00164E  E00001     CP0 W1
001650  32000E     BRA Z, .L50, .LBE4
1061:              					{
1062:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001652  448072     ADD W9, #0x12, W0
001654  020B28     CALL xTaskRemoveFromEventList
001656  000000     NOP
001658  780080     MOV W0, W1
00165C  E00001     CP0 W1
00165E  320007     BRA Z, .L50, .LBE4
1063:              						{
1064:              							/* The task waiting has a higher priority so record that a
1065:              							context	switch is required. */
1066:              							if( pxHigherPriorityTaskWoken != NULL )
001660  E0000A     CP0 W10
001662  320005     BRA Z, .L50, .LBE4
1067:              							{
1068:              								*pxHigherPriorityTaskWoken = pdTRUE;
001664  780D00     MOV W0, [W10]
001666  370003     BRA .L50, .LBE4
1069:              							}
1070:              							else
1071:              							{
1072:              								mtCOVERAGE_TEST_MARKER();
1073:              							}
1074:              						}
1075:              						else
1076:              						{
1077:              							mtCOVERAGE_TEST_MARKER();
1078:              						}
1079:              					}
1080:              					else
1081:              					{
1082:              						mtCOVERAGE_TEST_MARKER();
1083:              					}
1084:              				}
1085:              				#endif /* configUSE_QUEUE_SETS */
1086:              			}
1087:              			else
1088:              			{
1089:              				/* Increment the lock count so the task that unlocks the queue
1090:              				knows that data was posted while it was locked. */
1091:              				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
001668  E84408     INC.B W8, W8
00166A  9864B8     MOV.B W8, [W9+35]
1092:              			}
1093:              
1094:              			xReturn = pdPASS;
00164C  200010     MOV #0x1, W0
00165A  200010     MOV #0x1, W0
00166C  200010     MOV #0x1, W0
1095:              		}
1096:              		else
1097:              		{
1098:              			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1099:              			xReturn = errQUEUE_FULL;
001638  EB0000     CLR W0
1100:              		}
1101:              	}
1102:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1103:              
1104:              	return xReturn;
1105:              }
00166E  78054F     MOV [--W15], W10
001670  BE044F     MOV.D [--W15], W8
001672  060000     RETURN
1106:              /*-----------------------------------------------------------*/
1107:              
1108:              BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1109:              {
001674  781F88     MOV W8, [W15++]
001676  780401     MOV W1, W8
1110:              BaseType_t xReturn;
1111:              UBaseType_t uxSavedInterruptStatus;
1112:              Queue_t * const pxQueue = xQueue;
1113:              
1114:              	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1115:              	item size is 0.  Don't directly wake a task that was blocked on a queue
1116:              	read, instead return a flag to say whether a context switch is required or
1117:              	not (i.e. has a task with a higher priority than us been woken by this
1118:              	post). */
1119:              
1120:              	configASSERT( pxQueue );
1121:              
1122:              	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1123:              	if the item size is not 0. */
1124:              	configASSERT( pxQueue->uxItemSize == 0 );
1125:              
1126:              	/* Normally a mutex would not be given from an interrupt, especially if
1127:              	there is a mutex holder, as priority inheritance makes no sense for an
1128:              	interrupts, only tasks. */
1129:              	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
1130:              
1131:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1132:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1133:              	above the maximum system call priority are kept permanently enabled, even
1134:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1135:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1136:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1137:              	failure if a FreeRTOS API function is called from an interrupt that has been
1138:              	assigned a priority above the configured maximum system call priority.
1139:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1140:              	that have been assigned a priority at or (logically) below the maximum
1141:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1142:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1143:              	More information (albeit Cortex-M specific) is provided on the following
1144:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1145:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1146:              
1147:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1148:              	{
1149:              		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
001678  900960     MOV [W0+28], W2
1150:              
1151:              		/* When the queue is used to implement a semaphore no data is ever
1152:              		moved through the queue but it is still valid to see if the queue 'has
1153:              		space'. */
1154:              		if( uxMessagesWaiting < pxQueue->uxLength )
00167A  9009F0     MOV [W0+30], W3
00167E  510F83     SUB W2, W3, [W15]
001680  310016     BRA C, .L57, .LBE5, .LBE6
1155:              		{
1156:              			const int8_t cTxLock = pxQueue->cTxLock;
001682  9060B0     MOV.B [W0+35], W1
1157:              
1158:              			traceQUEUE_SEND_FROM_ISR( pxQueue );
1159:              
1160:              			/* A task can only have an inherited priority if it is a mutex
1161:              			holder - and if there is a mutex holder then the mutex cannot be
1162:              			given from an ISR.  As this is the ISR version of the function it
1163:              			can be assumed there is no mutex holder and no need to determine if
1164:              			priority disinheritance is needed.  Simply increase the count of
1165:              			messages (semaphores) available. */
1166:              			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
001684  E80102     INC W2, W2
001686  980862     MOV W2, [W0+28]
1167:              
1168:              			/* The event list is not altered if the queue is locked.  This will
1169:              			be done when the queue is unlocked later. */
1170:              			if( cTxLock == queueUNLOCKED )
001688  40CFE1     ADD.B W1, #0x1, [W15]
00168A  3A000E     BRA NZ, .L58
1171:              			{
1172:              				#if ( configUSE_QUEUE_SETS == 1 )
1173:              				{
1174:              					if( pxQueue->pxQueueSetContainer != NULL )
1175:              					{
1176:              						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1177:              						{
1178:              							/* The semaphore is a member of a queue set, and
1179:              							posting	to the queue set caused a higher priority
1180:              							task to	unblock.  A context switch is required. */
1181:              							if( pxHigherPriorityTaskWoken != NULL )
1182:              							{
1183:              								*pxHigherPriorityTaskWoken = pdTRUE;
1184:              							}
1185:              							else
1186:              							{
1187:              								mtCOVERAGE_TEST_MARKER();
1188:              							}
1189:              						}
1190:              						else
1191:              						{
1192:              							mtCOVERAGE_TEST_MARKER();
1193:              						}
1194:              					}
1195:              					else
1196:              					{
1197:              						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1198:              						{
1199:              							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1200:              							{
1201:              								/* The task waiting has a higher priority so
1202:              								record that a context switch is required. */
1203:              								if( pxHigherPriorityTaskWoken != NULL )
1204:              								{
1205:              									*pxHigherPriorityTaskWoken = pdTRUE;
1206:              								}
1207:              								else
1208:              								{
1209:              									mtCOVERAGE_TEST_MARKER();
1210:              								}
1211:              							}
1212:              							else
1213:              							{
1214:              								mtCOVERAGE_TEST_MARKER();
1215:              							}
1216:              						}
1217:              						else
1218:              						{
1219:              							mtCOVERAGE_TEST_MARKER();
1220:              						}
1221:              					}
1222:              				}
1223:              				#else /* configUSE_QUEUE_SETS */
1224:              				{
1225:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00168C  900910     MOV [W0+18], W2
001690  E00002     CP0 W2
001692  32000D     BRA Z, .L57, .LBE5, .LBE6
1226:              					{
1227:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001694  400072     ADD W0, #0x12, W0
001696  020B28     CALL xTaskRemoveFromEventList
001698  000000     NOP
00169C  E00000     CP0 W0
00169E  320007     BRA Z, .L57, .LBE5, .LBE6
1228:              						{
1229:              							/* The task waiting has a higher priority so record that a
1230:              							context	switch is required. */
1231:              							if( pxHigherPriorityTaskWoken != NULL )
0016A0  E00008     CP0 W8
0016A2  320005     BRA Z, .L57, .LBE5, .LBE6
1232:              							{
1233:              								*pxHigherPriorityTaskWoken = pdTRUE;
0016A4  780C01     MOV W1, [W8]
0016A6  370003     BRA .L57, .LBE5, .LBE6
1234:              							}
1235:              							else
1236:              							{
1237:              								mtCOVERAGE_TEST_MARKER();
1238:              							}
1239:              						}
1240:              						else
1241:              						{
1242:              							mtCOVERAGE_TEST_MARKER();
1243:              						}
1244:              					}
1245:              					else
1246:              					{
1247:              						mtCOVERAGE_TEST_MARKER();
1248:              					}
1249:              				}
1250:              				#endif /* configUSE_QUEUE_SETS */
1251:              			}
1252:              			else
1253:              			{
1254:              				/* Increment the lock count so the task that unlocks the queue
1255:              				knows that data was posted while it was locked. */
1256:              				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
0016A8  E84081     INC.B W1, W1
0016AA  986031     MOV.B W1, [W0+35]
1257:              			}
1258:              
1259:              			xReturn = pdPASS;
00168E  200011     MOV #0x1, W1
00169A  200011     MOV #0x1, W1
0016AC  200011     MOV #0x1, W1
1260:              		}
1261:              		else
1262:              		{
1263:              			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1264:              			xReturn = errQUEUE_FULL;
00167C  EB0080     CLR W1
1265:              		}
1266:              	}
1267:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1268:              
1269:              	return xReturn;
1270:              }
0016AE  780001     MOV W1, W0
0016B0  78044F     MOV [--W15], W8
0016B2  060000     RETURN
1271:              /*-----------------------------------------------------------*/
1272:              
1273:              BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1274:              {
0016B4  FA0006     LNK #0x6
0016B6  BE9F88     MOV.D W8, [W15++]
0016B8  BE9F8A     MOV.D W10, [W15++]
0016BA  781F8C     MOV W12, [W15++]
0016BC  780400     MOV W0, W8
0016BE  780601     MOV W1, W12
0016C0  9FBFA2     MOV W2, [W15-12]
1275:              BaseType_t xEntryTimeSet = pdFALSE;
0016C2  EB0500     CLR W10
1276:              TimeOut_t xTimeOut;
1277:              Queue_t * const pxQueue = xQueue;
1278:              
1279:              	/* Check the pointer is not NULL. */
1280:              	configASSERT( ( pxQueue ) );
1281:              
1282:              	/* The buffer into which data is received can only be NULL if the data size
1283:              	is zero (so no data is copied into the buffer. */
1284:              	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
1285:              
1286:              	/* Cannot block if the scheduler is suspended. */
1287:              	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1288:              	{
1289:              		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
1290:              	}
1291:              	#endif
1292:              
1293:              
1294:              	/*lint -save -e904  This function relaxes the coding standard somewhat to
1295:              	allow return statements within the function itself.  This is done in the
1296:              	interest of execution time efficiency. */
1297:              	for( ;; )
1298:              	{
1299:              		taskENTER_CRITICAL();
0016C6  0225F4     CALL vPortEnterCritical
0016C8  000000     NOP
1300:              		{
1301:              			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
0016CA  900CE8     MOV [W8+28], W9
1302:              
1303:              			/* Is there data in the queue now?  To be running the calling task
1304:              			must be the highest priority task wanting to access the queue. */
1305:              			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
0016CC  E00009     CP0 W9
0016CE  320014     BRA Z, .L65
1306:              			{
1307:              				/* Data available, remove one item. */
1308:              				prvCopyDataFromQueue( pxQueue, pvBuffer );
0016D0  78008C     MOV W12, W1
0016D2  780008     MOV W8, W0
0016D4  07FE7A     RCALL _prvCopyDataFromQueue, .LFE15, .LFB16
1309:              				traceQUEUE_RECEIVE( pxQueue );
1310:              				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
0016D6  E90489     DEC W9, W9
0016D8  980C69     MOV W9, [W8+28]
1311:              
1312:              				/* There is now space in the queue, were any tasks waiting to
1313:              				post to the queue?  If so, unblock the highest priority waiting
1314:              				task. */
1315:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
0016DA  900048     MOV [W8+8], W0
0016DC  E00000     CP0 W0
0016DE  320008     BRA Z, .L66
1316:              				{
1317:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
0016E0  440068     ADD W8, #0x8, W0
0016E2  020B28     CALL xTaskRemoveFromEventList
0016E4  000000     NOP
0016E6  E00000     CP0 W0
0016E8  320003     BRA Z, .L66
1318:              					{
1319:              						queueYIELD_IF_USING_PREEMPTION();
0016EA  02286C     CALL .Letext0, .LFE2, _vPortYield
0016EC  000000     NOP
0016EE  000000     NOP
1320:              					}
1321:              					else
1322:              					{
1323:              						mtCOVERAGE_TEST_MARKER();
1324:              					}
1325:              				}
1326:              				else
1327:              				{
1328:              					mtCOVERAGE_TEST_MARKER();
1329:              				}
1330:              
1331:              				taskEXIT_CRITICAL();
0016F0  022604     CALL vPortExitCritical
0016F2  000000     NOP
1332:              				return pdPASS;
0016F4  200010     MOV #0x1, W0
0016F6  370045     BRA .L67
1333:              			}
1334:              			else
1335:              			{
1336:              				if( xTicksToWait == ( TickType_t ) 0 )
0016F8  97B82F     MOV [W15-12], W0
0016FA  E00000     CP0 W0
0016FC  3A0004     BRA NZ, .L68
1337:              				{
1338:              					/* The queue was empty and no block time is specified (or
1339:              					the block time has expired) so leave now. */
1340:              					taskEXIT_CRITICAL();
0016FE  022604     CALL vPortExitCritical
001700  000000     NOP
1341:              					traceQUEUE_RECEIVE_FAILED( pxQueue );
1342:              					return errQUEUE_EMPTY;
001702  EB0000     CLR W0
001704  37003E     BRA .L67
1343:              				}
1344:              				else if( xEntryTimeSet == pdFALSE )
001706  E0000A     CP0 W10
001708  3A0004     BRA NZ, .L69, .LBE7
1345:              				{
1346:              					/* The queue was empty and a block time was specified so
1347:              					configure the timeout structure. */
1348:              					vTaskInternalSetTimeOutState( &xTimeOut );
00170A  578070     SUB W15, #0x10, W0
00170C  020BC6     CALL vTaskInternalSetTimeOutState
00170E  000000     NOP
1349:              					xEntryTimeSet = pdTRUE;
001710  20001A     MOV #0x1, W10
1350:              				}
1351:              				else
1352:              				{
1353:              					/* Entry time was already set. */
1354:              					mtCOVERAGE_TEST_MARKER();
1355:              				}
1356:              			}
1357:              		}
1358:              		taskEXIT_CRITICAL();
001712  022604     CALL vPortExitCritical
001714  000000     NOP
1359:              
1360:              		/* Interrupts and other tasks can send to and receive from the queue
1361:              		now the critical section has been exited. */
1362:              
1363:              		vTaskSuspendAll();
001716  020A86     CALL vTaskSuspendAll
001718  000000     NOP
1364:              		prvLockQueue( pxQueue );
00171A  0225F4     CALL vPortEnterCritical
00171C  000000     NOP
00171E  906028     MOV.B [W8+34], W0
001720  404FE1     ADD.B W0, #0x1, [W15]
001722  3A0002     BRA NZ, .L70
001724  EB4000     CLR.B W0
001726  986420     MOV.B W0, [W8+34]
001728  906038     MOV.B [W8+35], W0
00172A  404FE1     ADD.B W0, #0x1, [W15]
00172C  3A0002     BRA NZ, .L71
00172E  EB4000     CLR.B W0
001730  986430     MOV.B W0, [W8+35]
001732  022604     CALL vPortExitCritical
001734  000000     NOP
1365:              
1366:              		/* Update the timeout state to see if it has expired yet. */
1367:              		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
001736  5780EC     SUB W15, #0xC, W1
001738  578070     SUB W15, #0x10, W0
00173A  020BD0     CALL xTaskCheckForTimeOut
00173C  000000     NOP
00173E  E00000     CP0 W0
001740  3A0017     BRA NZ, .L72
1368:              		{
1369:              			/* The timeout has not expired.  If the queue is still empty place
1370:              			the task on the list of tasks waiting to receive from the queue. */
1371:              			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
001742  780008     MOV W8, W0
001744  07FE63     RCALL _prvIsQueueEmpty, .LFE20, .LFB18
001746  E00000     CP0 W0
001748  32000E     BRA Z, .L73
1372:              			{
1373:              				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1374:              				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
0016C4  4405F2     ADD W8, #0x12, W11
00174A  97B8AF     MOV [W15-12], W1
00174C  78000B     MOV W11, W0
00174E  0212F0     CALL vTaskPlaceOnEventList
001750  000000     NOP
1375:              				prvUnlockQueue( pxQueue );
001752  780008     MOV W8, W0
001754  07FE68     RCALL _prvUnlockQueue, .LFE18, .LFB17
1376:              				if( xTaskResumeAll() == pdFALSE )
001756  020E4C     CALL xTaskResumeAll
001758  000000     NOP
00175A  E00000     CP0 W0
00175C  3AFFB4     BRA NZ, .L77
1377:              				{
1378:              					portYIELD_WITHIN_API();
00175E  02286C     CALL .Letext0, .LFE2, _vPortYield
001760  000000     NOP
001762  000000     NOP
001764  37FFB0     BRA .L77
1379:              				}
1380:              				else
1381:              				{
1382:              					mtCOVERAGE_TEST_MARKER();
1383:              				}
1384:              			}
1385:              			else
1386:              			{
1387:              				/* The queue contains data again.  Loop back to try and read the
1388:              				data. */
1389:              				prvUnlockQueue( pxQueue );
001766  780008     MOV W8, W0
001768  07FE5E     RCALL _prvUnlockQueue, .LFE18, .LFB17
1390:              				( void ) xTaskResumeAll();
00176A  020E4C     CALL xTaskResumeAll
00176C  000000     NOP
00176E  37FFAB     BRA .L77
1391:              			}
1392:              		}
1393:              		else
1394:              		{
1395:              			/* Timed out.  If there is no data in the queue exit, otherwise loop
1396:              			back and attempt to read the data. */
1397:              			prvUnlockQueue( pxQueue );
001770  780008     MOV W8, W0
001772  07FE59     RCALL _prvUnlockQueue, .LFE18, .LFB17
1398:              			( void ) xTaskResumeAll();
001774  020E4C     CALL xTaskResumeAll
001776  000000     NOP
1399:              
1400:              			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
001778  780008     MOV W8, W0
00177A  07FE48     RCALL _prvIsQueueEmpty, .LFE20, .LFB18
00177C  E00000     CP0 W0
00177E  32FFA3     BRA Z, .L77
1401:              			{
1402:              				traceQUEUE_RECEIVE_FAILED( pxQueue );
1403:              				return errQUEUE_EMPTY;
001780  EB0000     CLR W0
1404:              			}
1405:              			else
1406:              			{
1407:              				mtCOVERAGE_TEST_MARKER();
1408:              			}
1409:              		}
1410:              	} /*lint -restore */
1411:              }
001782  78064F     MOV [--W15], W12
001784  BE054F     MOV.D [--W15], W10
001786  BE044F     MOV.D [--W15], W8
001788  FA8000     ULNK
00178A  060000     RETURN
1412:              /*-----------------------------------------------------------*/
1413:              
1414:              BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1415:              {
00178C  FA0006     LNK #0x6
00178E  BE9F88     MOV.D W8, [W15++]
001790  781F8A     MOV W10, [W15++]
001792  780400     MOV W0, W8
001794  9FBFC1     MOV W1, [W15-8]
1416:              BaseType_t xEntryTimeSet = pdFALSE;
001796  EB0480     CLR W9
1417:              TimeOut_t xTimeOut;
1418:              Queue_t * const pxQueue = xQueue;
1419:              
1420:              #if( configUSE_MUTEXES == 1 )
1421:              	BaseType_t xInheritanceOccurred = pdFALSE;
1422:              #endif
1423:              
1424:              	/* Check the queue pointer is not NULL. */
1425:              	configASSERT( ( pxQueue ) );
1426:              
1427:              	/* Check this really is a semaphore, in which case the item size will be
1428:              	0. */
1429:              	configASSERT( pxQueue->uxItemSize == 0 );
1430:              
1431:              	/* Cannot block if the scheduler is suspended. */
1432:              	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1433:              	{
1434:              		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
1435:              	}
1436:              	#endif
1437:              
1438:              
1439:              	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1440:              	statements within the function itself.  This is done in the interest
1441:              	of execution time efficiency. */
1442:              	for( ;; )
1443:              	{
1444:              		taskENTER_CRITICAL();
00179A  0225F4     CALL vPortEnterCritical
00179C  000000     NOP
1445:              		{
1446:              			/* Semaphores are queues with an item size of 0, and where the
1447:              			number of messages in the queue is the semaphore's count value. */
1448:              			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
00179E  900868     MOV [W8+28], W0
1449:              
1450:              			/* Is there data in the queue now?  To be running the calling task
1451:              			must be the highest priority task wanting to access the queue. */
1452:              			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
0017A0  E00000     CP0 W0
0017A2  320011     BRA Z, .L80
1453:              			{
1454:              				traceQUEUE_RECEIVE( pxQueue );
1455:              
1456:              				/* Semaphores are queues with a data size of zero and where the
1457:              				messages waiting is the semaphore's count.  Reduce the count. */
1458:              				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
0017A4  E90000     DEC W0, W0
0017A6  980C60     MOV W0, [W8+28]
1459:              
1460:              				#if ( configUSE_MUTEXES == 1 )
1461:              				{
1462:              					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1463:              					{
1464:              						/* Record the information required to implement
1465:              						priority inheritance should it become necessary. */
1466:              						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1467:              					}
1468:              					else
1469:              					{
1470:              						mtCOVERAGE_TEST_MARKER();
1471:              					}
1472:              				}
1473:              				#endif /* configUSE_MUTEXES */
1474:              
1475:              				/* Check to see if other tasks are blocked waiting to give the
1476:              				semaphore, and if so, unblock the highest priority such task. */
1477:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
0017A8  900048     MOV [W8+8], W0
0017AA  E00000     CP0 W0
0017AC  320008     BRA Z, .L81
1478:              				{
1479:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
0017AE  440068     ADD W8, #0x8, W0
0017B0  020B28     CALL xTaskRemoveFromEventList
0017B2  000000     NOP
0017B4  E00000     CP0 W0
0017B6  320003     BRA Z, .L81
1480:              					{
1481:              						queueYIELD_IF_USING_PREEMPTION();
0017B8  02286C     CALL .Letext0, .LFE2, _vPortYield
0017BA  000000     NOP
0017BC  000000     NOP
1482:              					}
1483:              					else
1484:              					{
1485:              						mtCOVERAGE_TEST_MARKER();
1486:              					}
1487:              				}
1488:              				else
1489:              				{
1490:              					mtCOVERAGE_TEST_MARKER();
1491:              				}
1492:              
1493:              				taskEXIT_CRITICAL();
0017BE  022604     CALL vPortExitCritical
0017C0  000000     NOP
1494:              				return pdPASS;
0017C2  200010     MOV #0x1, W0
0017C4  370045     BRA .L82
1495:              			}
1496:              			else
1497:              			{
1498:              				if( xTicksToWait == ( TickType_t ) 0 )
0017C6  97B84F     MOV [W15-8], W0
0017C8  E00000     CP0 W0
0017CA  3A0004     BRA NZ, .L83
1499:              				{
1500:              					/* For inheritance to have occurred there must have been an
1501:              					initial timeout, and an adjusted timeout cannot become 0, as
1502:              					if it were 0 the function would have exited. */
1503:              					#if( configUSE_MUTEXES == 1 )
1504:              					{
1505:              						configASSERT( xInheritanceOccurred == pdFALSE );
1506:              					}
1507:              					#endif /* configUSE_MUTEXES */
1508:              
1509:              					/* The semaphore count was 0 and no block time is specified
1510:              					(or the block time has expired) so exit now. */
1511:              					taskEXIT_CRITICAL();
0017CC  022604     CALL vPortExitCritical
0017CE  000000     NOP
1512:              					traceQUEUE_RECEIVE_FAILED( pxQueue );
1513:              					return errQUEUE_EMPTY;
0017D0  EB0000     CLR W0
0017D2  37003E     BRA .L82
1514:              				}
1515:              				else if( xEntryTimeSet == pdFALSE )
0017D4  E00009     CP0 W9
0017D6  3A0004     BRA NZ, .L84, .LBE8
1516:              				{
1517:              					/* The semaphore count was 0 and a block time was specified
1518:              					so configure the timeout structure ready to block. */
1519:              					vTaskInternalSetTimeOutState( &xTimeOut );
0017D8  57806C     SUB W15, #0xC, W0
0017DA  020BC6     CALL vTaskInternalSetTimeOutState
0017DC  000000     NOP
1520:              					xEntryTimeSet = pdTRUE;
0017DE  200019     MOV #0x1, W9
1521:              				}
1522:              				else
1523:              				{
1524:              					/* Entry time was already set. */
1525:              					mtCOVERAGE_TEST_MARKER();
1526:              				}
1527:              			}
1528:              		}
1529:              		taskEXIT_CRITICAL();
0017E0  022604     CALL vPortExitCritical
0017E2  000000     NOP
1530:              
1531:              		/* Interrupts and other tasks can give to and take from the semaphore
1532:              		now the critical section has been exited. */
1533:              
1534:              		vTaskSuspendAll();
0017E4  020A86     CALL vTaskSuspendAll
0017E6  000000     NOP
1535:              		prvLockQueue( pxQueue );
0017E8  0225F4     CALL vPortEnterCritical
0017EA  000000     NOP
0017EC  906028     MOV.B [W8+34], W0
0017EE  404FE1     ADD.B W0, #0x1, [W15]
0017F0  3A0002     BRA NZ, .L85
0017F2  EB4000     CLR.B W0
0017F4  986420     MOV.B W0, [W8+34]
0017F6  906038     MOV.B [W8+35], W0
0017F8  404FE1     ADD.B W0, #0x1, [W15]
0017FA  3A0002     BRA NZ, .L86
0017FC  EB4000     CLR.B W0
0017FE  986430     MOV.B W0, [W8+35]
001800  022604     CALL vPortExitCritical
001802  000000     NOP
1536:              
1537:              		/* Update the timeout state to see if it has expired yet. */
1538:              		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
001804  5780E8     SUB W15, #0x8, W1
001806  57806C     SUB W15, #0xC, W0
001808  020BD0     CALL xTaskCheckForTimeOut
00180A  000000     NOP
00180C  E00000     CP0 W0
00180E  3A0017     BRA NZ, .L87
1539:              		{
1540:              			/* A block time is specified and not expired.  If the semaphore
1541:              			count is 0 then enter the Blocked state to wait for a semaphore to
1542:              			become available.  As semaphores are implemented with queues the
1543:              			queue being empty is equivalent to the semaphore count being 0. */
1544:              			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
001810  780008     MOV W8, W0
001812  07FDFC     RCALL _prvIsQueueEmpty, .LFE20, .LFB18
001814  E00000     CP0 W0
001816  32000E     BRA Z, .L88
1545:              			{
1546:              				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1547:              
1548:              				#if ( configUSE_MUTEXES == 1 )
1549:              				{
1550:              					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1551:              					{
1552:              						taskENTER_CRITICAL();
1553:              						{
1554:              							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
1555:              						}
1556:              						taskEXIT_CRITICAL();
1557:              					}
1558:              					else
1559:              					{
1560:              						mtCOVERAGE_TEST_MARKER();
1561:              					}
1562:              				}
1563:              				#endif
1564:              
1565:              				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
001798  440572     ADD W8, #0x12, W10
001818  97B8CF     MOV [W15-8], W1
00181A  78000A     MOV W10, W0
00181C  0212F0     CALL vTaskPlaceOnEventList
00181E  000000     NOP
1566:              				prvUnlockQueue( pxQueue );
001820  780008     MOV W8, W0
001822  07FE01     RCALL _prvUnlockQueue, .LFE18, .LFB17
1567:              				if( xTaskResumeAll() == pdFALSE )
001824  020E4C     CALL xTaskResumeAll
001826  000000     NOP
001828  E00000     CP0 W0
00182A  3AFFB7     BRA NZ, .L92
1568:              				{
1569:              					portYIELD_WITHIN_API();
00182C  02286C     CALL .Letext0, .LFE2, _vPortYield
00182E  000000     NOP
001830  000000     NOP
001832  37FFB3     BRA .L92
1570:              				}
1571:              				else
1572:              				{
1573:              					mtCOVERAGE_TEST_MARKER();
1574:              				}
1575:              			}
1576:              			else
1577:              			{
1578:              				/* There was no timeout and the semaphore count was not 0, so
1579:              				attempt to take the semaphore again. */
1580:              				prvUnlockQueue( pxQueue );
001834  780008     MOV W8, W0
001836  07FDF7     RCALL _prvUnlockQueue, .LFE18, .LFB17
1581:              				( void ) xTaskResumeAll();
001838  020E4C     CALL xTaskResumeAll
00183A  000000     NOP
00183C  37FFAE     BRA .L92
1582:              			}
1583:              		}
1584:              		else
1585:              		{
1586:              			/* Timed out. */
1587:              			prvUnlockQueue( pxQueue );
00183E  780008     MOV W8, W0
001840  07FDF2     RCALL _prvUnlockQueue, .LFE18, .LFB17
1588:              			( void ) xTaskResumeAll();
001842  020E4C     CALL xTaskResumeAll
001844  000000     NOP
1589:              
1590:              			/* If the semaphore count is 0 exit now as the timeout has
1591:              			expired.  Otherwise return to attempt to take the semaphore that is
1592:              			known to be available.  As semaphores are implemented by queues the
1593:              			queue being empty is equivalent to the semaphore count being 0. */
1594:              			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
001846  780008     MOV W8, W0
001848  07FDE1     RCALL _prvIsQueueEmpty, .LFE20, .LFB18
00184A  E00000     CP0 W0
00184C  32FFA6     BRA Z, .L92
1595:              			{
1596:              				#if ( configUSE_MUTEXES == 1 )
1597:              				{
1598:              					/* xInheritanceOccurred could only have be set if
1599:              					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1600:              					test the mutex type again to check it is actually a mutex. */
1601:              					if( xInheritanceOccurred != pdFALSE )
1602:              					{
1603:              						taskENTER_CRITICAL();
1604:              						{
1605:              							UBaseType_t uxHighestWaitingPriority;
1606:              
1607:              							/* This task blocking on the mutex caused another
1608:              							task to inherit this task's priority.  Now this task
1609:              							has timed out the priority should be disinherited
1610:              							again, but only as low as the next highest priority
1611:              							task that is waiting for the same mutex. */
1612:              							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
1613:              							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
1614:              						}
1615:              						taskEXIT_CRITICAL();
1616:              					}
1617:              				}
1618:              				#endif /* configUSE_MUTEXES */
1619:              
1620:              				traceQUEUE_RECEIVE_FAILED( pxQueue );
1621:              				return errQUEUE_EMPTY;
00184E  EB0000     CLR W0
1622:              			}
1623:              			else
1624:              			{
1625:              				mtCOVERAGE_TEST_MARKER();
1626:              			}
1627:              		}
1628:              	} /*lint -restore */
1629:              }
001850  78054F     MOV [--W15], W10
001852  BE044F     MOV.D [--W15], W8
001854  FA8000     ULNK
001856  060000     RETURN
1630:              /*-----------------------------------------------------------*/
1631:              
1632:              BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1633:              {
001858  FA0006     LNK #0x6
00185A  BE9F88     MOV.D W8, [W15++]
00185C  BE9F8A     MOV.D W10, [W15++]
00185E  780400     MOV W0, W8
001860  780581     MOV W1, W11
001862  9FBFB2     MOV W2, [W15-10]
1634:              BaseType_t xEntryTimeSet = pdFALSE;
001864  EB0480     CLR W9
1635:              TimeOut_t xTimeOut;
1636:              int8_t *pcOriginalReadPosition;
1637:              Queue_t * const pxQueue = xQueue;
1638:              
1639:              	/* Check the pointer is not NULL. */
1640:              	configASSERT( ( pxQueue ) );
1641:              
1642:              	/* The buffer into which data is received can only be NULL if the data size
1643:              	is zero (so no data is copied into the buffer. */
1644:              	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
1645:              
1646:              	/* Cannot block if the scheduler is suspended. */
1647:              	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1648:              	{
1649:              		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
1650:              	}
1651:              	#endif
1652:              
1653:              
1654:              	/*lint -save -e904  This function relaxes the coding standard somewhat to
1655:              	allow return statements within the function itself.  This is done in the
1656:              	interest of execution time efficiency. */
1657:              	for( ;; )
1658:              	{
1659:              		taskENTER_CRITICAL();
001868  0225F4     CALL vPortEnterCritical
00186A  000000     NOP
1660:              		{
1661:              			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00186C  900868     MOV [W8+28], W0
1662:              
1663:              			/* Is there data in the queue now?  To be running the calling task
1664:              			must be the highest priority task wanting to access the queue. */
1665:              			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00186E  E00000     CP0 W0
001870  320014     BRA Z, .L95
1666:              			{
1667:              				/* Remember the read position so it can be reset after the data
1668:              				is read from the queue as this function is only peeking the
1669:              				data, not removing it. */
1670:              				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
001872  9004B8     MOV [W8+6], W9
1671:              
1672:              				prvCopyDataFromQueue( pxQueue, pvBuffer );
001874  78008B     MOV W11, W1
001876  780008     MOV W8, W0
001878  07FDA8     RCALL _prvCopyDataFromQueue, .LFE15, .LFB16
1673:              				traceQUEUE_PEEK( pxQueue );
1674:              
1675:              				/* The data is not being removed, so reset the read pointer. */
1676:              				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
00187A  980439     MOV W9, [W8+6]
1677:              
1678:              				/* The data is being left in the queue, so see if there are
1679:              				any other tasks waiting for the data. */
1680:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00187C  900818     MOV [W8+18], W0
00187E  E00000     CP0 W0
001880  320008     BRA Z, .L96
1681:              				{
1682:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001882  440072     ADD W8, #0x12, W0
001884  020B28     CALL xTaskRemoveFromEventList
001886  000000     NOP
001888  E00000     CP0 W0
00188A  320003     BRA Z, .L96
1683:              					{
1684:              						/* The task waiting has a higher priority than this task. */
1685:              						queueYIELD_IF_USING_PREEMPTION();
00188C  02286C     CALL .Letext0, .LFE2, _vPortYield
00188E  000000     NOP
001890  000000     NOP
1686:              					}
1687:              					else
1688:              					{
1689:              						mtCOVERAGE_TEST_MARKER();
1690:              					}
1691:              				}
1692:              				else
1693:              				{
1694:              					mtCOVERAGE_TEST_MARKER();
1695:              				}
1696:              
1697:              				taskEXIT_CRITICAL();
001892  022604     CALL vPortExitCritical
001894  000000     NOP
1698:              				return pdPASS;
001896  200010     MOV #0x1, W0
001898  370045     BRA .L97
1699:              			}
1700:              			else
1701:              			{
1702:              				if( xTicksToWait == ( TickType_t ) 0 )
00189A  97B83F     MOV [W15-10], W0
00189C  E00000     CP0 W0
00189E  3A0004     BRA NZ, .L98
1703:              				{
1704:              					/* The queue was empty and no block time is specified (or
1705:              					the block time has expired) so leave now. */
1706:              					taskEXIT_CRITICAL();
0018A0  022604     CALL vPortExitCritical
0018A2  000000     NOP
1707:              					traceQUEUE_PEEK_FAILED( pxQueue );
1708:              					return errQUEUE_EMPTY;
0018A4  EB0000     CLR W0
0018A6  37003E     BRA .L97
1709:              				}
1710:              				else if( xEntryTimeSet == pdFALSE )
0018A8  E00009     CP0 W9
0018AA  3A0004     BRA NZ, .L99, .LBE9
1711:              				{
1712:              					/* The queue was empty and a block time was specified so
1713:              					configure the timeout structure ready to enter the blocked
1714:              					state. */
1715:              					vTaskInternalSetTimeOutState( &xTimeOut );
0018AC  57806E     SUB W15, #0xE, W0
0018AE  020BC6     CALL vTaskInternalSetTimeOutState
0018B0  000000     NOP
1716:              					xEntryTimeSet = pdTRUE;
0018B2  200019     MOV #0x1, W9
1717:              				}
1718:              				else
1719:              				{
1720:              					/* Entry time was already set. */
1721:              					mtCOVERAGE_TEST_MARKER();
1722:              				}
1723:              			}
1724:              		}
1725:              		taskEXIT_CRITICAL();
0018B4  022604     CALL vPortExitCritical
0018B6  000000     NOP
1726:              
1727:              		/* Interrupts and other tasks can send to and receive from the queue
1728:              		now the critical section has been exited. */
1729:              
1730:              		vTaskSuspendAll();
0018B8  020A86     CALL vTaskSuspendAll
0018BA  000000     NOP
1731:              		prvLockQueue( pxQueue );
0018BC  0225F4     CALL vPortEnterCritical
0018BE  000000     NOP
0018C0  906028     MOV.B [W8+34], W0
0018C2  404FE1     ADD.B W0, #0x1, [W15]
0018C4  3A0002     BRA NZ, .L100
0018C6  EB4000     CLR.B W0
0018C8  986420     MOV.B W0, [W8+34]
0018CA  906038     MOV.B [W8+35], W0
0018CC  404FE1     ADD.B W0, #0x1, [W15]
0018CE  3A0002     BRA NZ, .L101
0018D0  EB4000     CLR.B W0
0018D2  986430     MOV.B W0, [W8+35]
0018D4  022604     CALL vPortExitCritical
0018D6  000000     NOP
1732:              
1733:              		/* Update the timeout state to see if it has expired yet. */
1734:              		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
0018D8  5780EA     SUB W15, #0xA, W1
0018DA  57806E     SUB W15, #0xE, W0
0018DC  020BD0     CALL xTaskCheckForTimeOut
0018DE  000000     NOP
0018E0  E00000     CP0 W0
0018E2  3A0017     BRA NZ, .L102
1735:              		{
1736:              			/* Timeout has not expired yet, check to see if there is data in the
1737:              			queue now, and if not enter the Blocked state to wait for data. */
1738:              			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
0018E4  780008     MOV W8, W0
0018E6  07FD92     RCALL _prvIsQueueEmpty, .LFE20, .LFB18
0018E8  E00000     CP0 W0
0018EA  32000E     BRA Z, .L103
1739:              			{
1740:              				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1741:              				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
001866  440572     ADD W8, #0x12, W10
0018EC  97B8BF     MOV [W15-10], W1
0018EE  78000A     MOV W10, W0
0018F0  0212F0     CALL vTaskPlaceOnEventList
0018F2  000000     NOP
1742:              				prvUnlockQueue( pxQueue );
0018F4  780008     MOV W8, W0
0018F6  07FD97     RCALL _prvUnlockQueue, .LFE18, .LFB17
1743:              				if( xTaskResumeAll() == pdFALSE )
0018F8  020E4C     CALL xTaskResumeAll
0018FA  000000     NOP
0018FC  E00000     CP0 W0
0018FE  3AFFB4     BRA NZ, .L107
1744:              				{
1745:              					portYIELD_WITHIN_API();
001900  02286C     CALL .Letext0, .LFE2, _vPortYield
001902  000000     NOP
001904  000000     NOP
001906  37FFB0     BRA .L107
1746:              				}
1747:              				else
1748:              				{
1749:              					mtCOVERAGE_TEST_MARKER();
1750:              				}
1751:              			}
1752:              			else
1753:              			{
1754:              				/* There is data in the queue now, so don't enter the blocked
1755:              				state, instead return to try and obtain the data. */
1756:              				prvUnlockQueue( pxQueue );
001908  780008     MOV W8, W0
00190A  07FD8D     RCALL _prvUnlockQueue, .LFE18, .LFB17
1757:              				( void ) xTaskResumeAll();
00190C  020E4C     CALL xTaskResumeAll
00190E  000000     NOP
001910  37FFAB     BRA .L107
1758:              			}
1759:              		}
1760:              		else
1761:              		{
1762:              			/* The timeout has expired.  If there is still no data in the queue
1763:              			exit, otherwise go back and try to read the data again. */
1764:              			prvUnlockQueue( pxQueue );
001912  780008     MOV W8, W0
001914  07FD88     RCALL _prvUnlockQueue, .LFE18, .LFB17
1765:              			( void ) xTaskResumeAll();
001916  020E4C     CALL xTaskResumeAll
001918  000000     NOP
1766:              
1767:              			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
00191A  780008     MOV W8, W0
00191C  07FD77     RCALL _prvIsQueueEmpty, .LFE20, .LFB18
00191E  E00000     CP0 W0
001920  32FFA3     BRA Z, .L107
1768:              			{
1769:              				traceQUEUE_PEEK_FAILED( pxQueue );
1770:              				return errQUEUE_EMPTY;
001922  EB0000     CLR W0
1771:              			}
1772:              			else
1773:              			{
1774:              				mtCOVERAGE_TEST_MARKER();
1775:              			}
1776:              		}
1777:              	} /*lint -restore */
1778:              }
001924  BE054F     MOV.D [--W15], W10
001926  BE044F     MOV.D [--W15], W8
001928  FA8000     ULNK
00192A  060000     RETURN
1779:              /*-----------------------------------------------------------*/
1780:              
1781:              BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
1782:              {
00192C  BE9F88     MOV.D W8, [W15++]
00192E  BE9F8A     MOV.D W10, [W15++]
001930  780400     MOV W0, W8
001932  780582     MOV W2, W11
1783:              BaseType_t xReturn;
1784:              UBaseType_t uxSavedInterruptStatus;
1785:              Queue_t * const pxQueue = xQueue;
1786:              
1787:              	configASSERT( pxQueue );
1788:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1789:              
1790:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1791:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1792:              	above the maximum system call priority are kept permanently enabled, even
1793:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1794:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1795:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1796:              	failure if a FreeRTOS API function is called from an interrupt that has been
1797:              	assigned a priority above the configured maximum system call priority.
1798:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1799:              	that have been assigned a priority at or (logically) below the maximum
1800:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1801:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1802:              	More information (albeit Cortex-M specific) is provided on the following
1803:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1804:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1805:              
1806:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1807:              	{
1808:              		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
001934  900CE8     MOV [W8+28], W9
1809:              
1810:              		/* Cannot block in an ISR, so check there is data available. */
1811:              		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
001938  E00009     CP0 W9
00193A  320019     BRA Z, .L109, .LBE10, .LBE11
1812:              		{
1813:              			const int8_t cRxLock = pxQueue->cRxLock;
00193C  906528     MOV.B [W8+34], W10
1814:              
1815:              			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1816:              
1817:              			prvCopyDataFromQueue( pxQueue, pvBuffer );
00193E  780008     MOV W8, W0
001940  07FD44     RCALL _prvCopyDataFromQueue, .LFE15, .LFB16
1818:              			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
001942  E90489     DEC W9, W9
001944  980C69     MOV W9, [W8+28]
1819:              
1820:              			/* If the queue is locked the event list will not be modified.
1821:              			Instead update the lock count so the task that unlocks the queue
1822:              			will know that an ISR has removed data while the queue was
1823:              			locked. */
1824:              			if( cRxLock == queueUNLOCKED )
001946  454FE1     ADD.B W10, #0x1, [W15]
001948  3A000F     BRA NZ, .L110
1825:              			{
1826:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00194A  9000C8     MOV [W8+8], W1
00194E  E00001     CP0 W1
001950  32000E     BRA Z, .L109, .LBE10, .LBE11
1827:              				{
1828:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
001952  440068     ADD W8, #0x8, W0
001954  020B28     CALL xTaskRemoveFromEventList
001956  000000     NOP
001958  780080     MOV W0, W1
00195C  E00001     CP0 W1
00195E  320007     BRA Z, .L109, .LBE10, .LBE11
1829:              					{
1830:              						/* The task waiting has a higher priority than us so
1831:              						force a context switch. */
1832:              						if( pxHigherPriorityTaskWoken != NULL )
001960  E0000B     CP0 W11
001962  320005     BRA Z, .L109, .LBE10, .LBE11
1833:              						{
1834:              							*pxHigherPriorityTaskWoken = pdTRUE;
001964  780D80     MOV W0, [W11]
001966  370003     BRA .L109, .LBE10, .LBE11
1835:              						}
1836:              						else
1837:              						{
1838:              							mtCOVERAGE_TEST_MARKER();
1839:              						}
1840:              					}
1841:              					else
1842:              					{
1843:              						mtCOVERAGE_TEST_MARKER();
1844:              					}
1845:              				}
1846:              				else
1847:              				{
1848:              					mtCOVERAGE_TEST_MARKER();
1849:              				}
1850:              			}
1851:              			else
1852:              			{
1853:              				/* Increment the lock count so the task that unlocks the queue
1854:              				knows that data was removed while it was locked. */
1855:              				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
001968  E8450A     INC.B W10, W10
00196A  98642A     MOV.B W10, [W8+34]
1856:              			}
1857:              
1858:              			xReturn = pdPASS;
00194C  200010     MOV #0x1, W0
00195A  200010     MOV #0x1, W0
00196C  200010     MOV #0x1, W0
1859:              		}
1860:              		else
1861:              		{
1862:              			xReturn = pdFAIL;
001936  EB0000     CLR W0
1863:              			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1864:              		}
1865:              	}
1866:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1867:              
1868:              	return xReturn;
1869:              }
00196E  BE054F     MOV.D [--W15], W10
001970  BE044F     MOV.D [--W15], W8
001972  060000     RETURN
1870:              /*-----------------------------------------------------------*/
1871:              
1872:              BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1873:              {
001974  BE9F88     MOV.D W8, [W15++]
001976  780400     MOV W0, W8
1874:              BaseType_t xReturn;
1875:              UBaseType_t uxSavedInterruptStatus;
1876:              int8_t *pcOriginalReadPosition;
1877:              Queue_t * const pxQueue = xQueue;
1878:              
1879:              	configASSERT( pxQueue );
1880:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1881:              	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1882:              
1883:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1884:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1885:              	above the maximum system call priority are kept permanently enabled, even
1886:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1887:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1888:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1889:              	failure if a FreeRTOS API function is called from an interrupt that has been
1890:              	assigned a priority above the configured maximum system call priority.
1891:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1892:              	that have been assigned a priority at or (logically) below the maximum
1893:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1894:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1895:              	More information (albeit Cortex-M specific) is provided on the following
1896:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1897:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1898:              
1899:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1900:              	{
1901:              		/* Cannot block in an ISR, so check there is data available. */
1902:              		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
001978  900968     MOV [W8+28], W2
00197C  E00002     CP0 W2
00197E  320005     BRA Z, .L116
1903:              		{
1904:              			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1905:              
1906:              			/* Remember the read position so it can be reset as nothing is
1907:              			actually being removed from the queue. */
1908:              			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
001980  9004B8     MOV [W8+6], W9
1909:              			prvCopyDataFromQueue( pxQueue, pvBuffer );
001982  780008     MOV W8, W0
001984  07FD22     RCALL _prvCopyDataFromQueue, .LFE15, .LFB16
1910:              			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
001986  980439     MOV W9, [W8+6]
1911:              
1912:              			xReturn = pdPASS;
001988  200010     MOV #0x1, W0
1913:              		}
1914:              		else
1915:              		{
1916:              			xReturn = pdFAIL;
00197A  EB0000     CLR W0
1917:              			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1918:              		}
1919:              	}
1920:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1921:              
1922:              	return xReturn;
1923:              }
00198A  BE044F     MOV.D [--W15], W8
00198C  060000     RETURN
1924:              /*-----------------------------------------------------------*/
1925:              
1926:              UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1927:              {
00198E  781F88     MOV W8, [W15++]
001990  780400     MOV W0, W8
1928:              UBaseType_t uxReturn;
1929:              
1930:              	configASSERT( xQueue );
1931:              
1932:              	taskENTER_CRITICAL();
001992  0225F4     CALL vPortEnterCritical
001994  000000     NOP
1933:              	{
1934:              		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
001996  900C68     MOV [W8+28], W8
1935:              	}
1936:              	taskEXIT_CRITICAL();
001998  022604     CALL vPortExitCritical
00199A  000000     NOP
1937:              
1938:              	return uxReturn;
1939:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00199C  780008     MOV W8, W0
00199E  78044F     MOV [--W15], W8
0019A0  060000     RETURN
1940:              /*-----------------------------------------------------------*/
1941:              
1942:              UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1943:              {
0019A2  BE9F88     MOV.D W8, [W15++]
0019A4  780480     MOV W0, W9
1944:              UBaseType_t uxReturn;
1945:              Queue_t * const pxQueue = xQueue;
1946:              
1947:              	configASSERT( pxQueue );
1948:              
1949:              	taskENTER_CRITICAL();
0019A6  0225F4     CALL vPortEnterCritical
0019A8  000000     NOP
1950:              	{
1951:              		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
0019AA  900869     MOV [W9+28], W0
0019AC  900C79     MOV [W9+30], W8
0019AE  540400     SUB W8, W0, W8
1952:              	}
1953:              	taskEXIT_CRITICAL();
0019B0  022604     CALL vPortExitCritical
0019B2  000000     NOP
1954:              
1955:              	return uxReturn;
1956:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0019B4  780008     MOV W8, W0
0019B6  BE044F     MOV.D [--W15], W8
0019B8  060000     RETURN
1957:              /*-----------------------------------------------------------*/
1958:              
1959:              UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1960:              {
1961:              UBaseType_t uxReturn;
1962:              Queue_t * const pxQueue = xQueue;
1963:              
1964:              	configASSERT( pxQueue );
1965:              	uxReturn = pxQueue->uxMessagesWaiting;
0019BA  900860     MOV [W0+28], W0
1966:              
1967:              	return uxReturn;
1968:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0019BC  060000     RETURN
1969:              /*-----------------------------------------------------------*/
1970:              
1971:              void vQueueDelete( QueueHandle_t xQueue )
1972:              {
1973:              Queue_t * const pxQueue = xQueue;
1974:              
1975:              	configASSERT( pxQueue );
1976:              	traceQUEUE_DELETE( pxQueue );
1977:              
1978:              	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1979:              	{
1980:              		vQueueUnregisterQueue( pxQueue );
1981:              	}
1982:              	#endif
1983:              
1984:              	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1985:              	{
1986:              		/* The queue can only have been allocated dynamically - free it
1987:              		again. */
1988:              		vPortFree( pxQueue );
0019BE  0228FA     CALL vPortFree
0019C0  000000     NOP
1989:              	}
1990:              	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1991:              	{
1992:              		/* The queue could have been allocated statically or dynamically, so
1993:              		check before attempting to free the memory. */
1994:              		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1995:              		{
1996:              			vPortFree( pxQueue );
1997:              		}
1998:              		else
1999:              		{
2000:              			mtCOVERAGE_TEST_MARKER();
2001:              		}
2002:              	}
2003:              	#else
2004:              	{
2005:              		/* The queue must have been statically allocated, so is not going to be
2006:              		deleted.  Avoid compiler warnings about the unused parameter. */
2007:              		( void ) pxQueue;
2008:              	}
2009:              	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2010:              }
0019C2  060000     RETURN
2011:              /*-----------------------------------------------------------*/
2012:              
2013:              #if ( configUSE_TRACE_FACILITY == 1 )
2014:              
2015:              	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2016:              	{
2017:              		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2018:              	}
2019:              
2020:              #endif /* configUSE_TRACE_FACILITY */
2021:              /*-----------------------------------------------------------*/
2022:              
2023:              #if ( configUSE_TRACE_FACILITY == 1 )
2024:              
2025:              	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
2026:              	{
2027:              		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2028:              	}
2029:              
2030:              #endif /* configUSE_TRACE_FACILITY */
2031:              /*-----------------------------------------------------------*/
2032:              
2033:              #if ( configUSE_TRACE_FACILITY == 1 )
2034:              
2035:              	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2036:              	{
2037:              		return ( ( Queue_t * ) xQueue )->ucQueueType;
2038:              	}
2039:              
2040:              #endif /* configUSE_TRACE_FACILITY */
2041:              /*-----------------------------------------------------------*/
2042:              
2043:              #if( configUSE_MUTEXES == 1 )
2044:              
2045:              	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2046:              	{
2047:              	UBaseType_t uxHighestPriorityOfWaitingTasks;
2048:              
2049:              		/* If a task waiting for a mutex causes the mutex holder to inherit a
2050:              		priority, but the waiting task times out, then the holder should
2051:              		disinherit the priority - but only down to the highest priority of any
2052:              		other tasks that are waiting for the same mutex.  For this purpose,
2053:              		return the priority of the highest priority task that is waiting for the
2054:              		mutex. */
2055:              		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
2056:              		{
2057:              			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
2058:              		}
2059:              		else
2060:              		{
2061:              			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2062:              		}
2063:              
2064:              		return uxHighestPriorityOfWaitingTasks;
2065:              	}
2066:              
2067:              #endif /* configUSE_MUTEXES */
2068:              /*-----------------------------------------------------------*/
2069:              
2070:              static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
2071:              {
00136C  BE9F88     MOV.D W8, [W15++]
00136E  781F8A     MOV W10, [W15++]
001370  780400     MOV W0, W8
001372  780502     MOV W2, W10
2072:              BaseType_t xReturn = pdFALSE;
2073:              UBaseType_t uxMessagesWaiting;
2074:              
2075:              	/* This function is called from a critical section. */
2076:              
2077:              	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
001374  900CE8     MOV [W8+28], W9
2078:              
2079:              	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
001376  901108     MOV [W8+32], W2
001378  E00002     CP0 W2
00137A  320021     BRA Z, .L2
2080:              	{
2081:              		#if ( configUSE_MUTEXES == 1 )
2082:              		{
2083:              			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2084:              			{
2085:              				/* The mutex is no longer being held. */
2086:              				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2087:              				pxQueue->u.xSemaphore.xMutexHolder = NULL;
2088:              			}
2089:              			else
2090:              			{
2091:              				mtCOVERAGE_TEST_MARKER();
2092:              			}
2093:              		}
2094:              		#endif /* configUSE_MUTEXES */
2095:              	}
2096:              	else if( xPosition == queueSEND_TO_BACK )
00137C  E0000A     CP0 W10
00137E  3A000D     BRA NZ, .L3
2097:              	{
2098:              		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
001380  900018     MOV [W8+2], W0
001382  0207CC     CALL _memcpy
001384  000000     NOP
2099:              		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
001386  900098     MOV [W8+2], W1
001388  901008     MOV [W8+32], W0
00138A  408000     ADD W1, W0, W0
00138C  980410     MOV W0, [W8+2]
2100:              		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00138E  9000A8     MOV [W8+4], W1
001390  500F81     SUB W0, W1, [W15]
001392  390015     BRA NC, .L2
2101:              		{
2102:              			pxQueue->pcWriteTo = pxQueue->pcHead;
001394  780018     MOV [W8], W0
001396  980410     MOV W0, [W8+2]
001398  370012     BRA .L2
2103:              		}
2104:              		else
2105:              		{
2106:              			mtCOVERAGE_TEST_MARKER();
2107:              		}
2108:              	}
2109:              	else
2110:              	{
2111:              		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
00139A  900038     MOV [W8+6], W0
00139C  0207CC     CALL _memcpy
00139E  000000     NOP
2112:              		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
0013A0  901088     MOV [W8+32], W1
0013A2  EA0081     NEG W1, W1
0013A4  900038     MOV [W8+6], W0
0013A6  400001     ADD W0, W1, W0
0013A8  980430     MOV W0, [W8+6]
2113:              		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
0013AA  500F98     SUB W0, [W8], [W15]
0013AC  310003     BRA C, .L4
2114:              		{
2115:              			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
0013AE  900028     MOV [W8+4], W0
0013B0  400081     ADD W0, W1, W1
0013B2  980431     MOV W1, [W8+6]
2116:              		}
2117:              		else
2118:              		{
2119:              			mtCOVERAGE_TEST_MARKER();
2120:              		}
2121:              
2122:              		if( xPosition == queueOVERWRITE )
0013B4  550FE2     SUB W10, #0x2, [W15]
0013B6  3A0003     BRA NZ, .L2
2123:              		{
2124:              			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
0013B8  E00009     CP0 W9
0013BA  320001     BRA Z, .L2
2125:              			{
2126:              				/* An item is not being added but overwritten, so subtract
2127:              				one from the recorded number of items in the queue so when
2128:              				one is added again below the number of recorded items remains
2129:              				correct. */
2130:              				--uxMessagesWaiting;
0013BC  E90489     DEC W9, W9
2131:              			}
2132:              			else
2133:              			{
2134:              				mtCOVERAGE_TEST_MARKER();
2135:              			}
2136:              		}
2137:              		else
2138:              		{
2139:              			mtCOVERAGE_TEST_MARKER();
2140:              		}
2141:              	}
2142:              
2143:              	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
0013BE  E80489     INC W9, W9
0013C0  980C69     MOV W9, [W8+28]
2144:              
2145:              	return xReturn;
2146:              }
0013C2  EB0000     CLR W0
0013C4  78054F     MOV [--W15], W10
0013C6  BE044F     MOV.D [--W15], W8
0013C8  060000     RETURN
2147:              /*-----------------------------------------------------------*/
2148:              
2149:              static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2150:              {
0013CA  780181     MOV W1, W3
2151:              	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
0013CC  901100     MOV [W0+32], W2
0013CE  E00002     CP0 W2
0013D0  32000C     BRA Z, .L5
2152:              	{
2153:              		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
0013D2  9000B0     MOV [W0+6], W1
0013D4  408082     ADD W1, W2, W1
0013D6  980031     MOV W1, [W0+6]
2154:              		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
0013D8  900220     MOV [W0+4], W4
0013DA  508F84     SUB W1, W4, [W15]
0013DC  390002     BRA NC, .L7
2155:              		{
2156:              			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
0013DE  780090     MOV [W0], W1
0013E0  980031     MOV W1, [W0+6]
2157:              		}
2158:              		else
2159:              		{
2160:              			mtCOVERAGE_TEST_MARKER();
2161:              		}
2162:              		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
0013E2  9000B0     MOV [W0+6], W1
0013E4  780003     MOV W3, W0
0013E6  0207CC     CALL _memcpy
0013E8  000000     NOP
2163:              	}
2164:              }
0013EA  060000     RETURN
2165:              /*-----------------------------------------------------------*/
2166:              
2167:              static void prvUnlockQueue( Queue_t * const pxQueue )
2168:              {
001426  BE9F88     MOV.D W8, [W15++]
001428  781F8A     MOV W10, [W15++]
00142A  780480     MOV W0, W9
2169:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2170:              
2171:              	/* The lock counts contains the number of extra data items placed or
2172:              	removed from the queue while the queue was locked.  When a queue is
2173:              	locked items can be added or removed, but the event lists cannot be
2174:              	updated. */
2175:              	taskENTER_CRITICAL();
00142C  0225F4     CALL vPortEnterCritical
00142E  000000     NOP
2176:              	{
2177:              		int8_t cTxLock = pxQueue->cTxLock;
001430  906439     MOV.B [W9+35], W8
2178:              
2179:              		/* See if data was added to the queue while it was locked. */
2180:              		while( cTxLock > queueLOCKED_UNMODIFIED )
001432  E00408     CP0.B W8
001434  340013     BRA LE, .L11
001458  A94042     BCLR SR, #2
00145A  3CFFF1     BRA GT, .L14
2181:              		{
2182:              			/* Data was posted while the queue was locked.  Are any tasks
2183:              			blocked waiting for data to become available? */
2184:              			#if ( configUSE_QUEUE_SETS == 1 )
2185:              			{
2186:              				if( pxQueue->pxQueueSetContainer != NULL )
2187:              				{
2188:              					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
2189:              					{
2190:              						/* The queue is a member of a queue set, and posting to
2191:              						the queue set caused a higher priority task to unblock.
2192:              						A context switch is required. */
2193:              						vTaskMissedYield();
2194:              					}
2195:              					else
2196:              					{
2197:              						mtCOVERAGE_TEST_MARKER();
2198:              					}
2199:              				}
2200:              				else
2201:              				{
2202:              					/* Tasks that are removed from the event list will get
2203:              					added to the pending ready list as the scheduler is still
2204:              					suspended. */
2205:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2206:              					{
2207:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2208:              						{
2209:              							/* The task waiting has a higher priority so record that a
2210:              							context	switch is required. */
2211:              							vTaskMissedYield();
2212:              						}
2213:              						else
2214:              						{
2215:              							mtCOVERAGE_TEST_MARKER();
2216:              						}
2217:              					}
2218:              					else
2219:              					{
2220:              						break;
2221:              					}
2222:              				}
2223:              			}
2224:              			#else /* configUSE_QUEUE_SETS */
2225:              			{
2226:              				/* Tasks that are removed from the event list will get added to
2227:              				the pending ready list as the scheduler is still suspended. */
2228:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001436  900819     MOV [W9+18], W0
001438  E00000     CP0 W0
00143A  3A0005     BRA NZ, .L12
00143C  37000F     BRA .L11
00143E  900819     MOV [W9+18], W0
001440  E00000     CP0 W0
001442  3A0002     BRA NZ, .L19
001444  37000B     BRA .L11
2229:              				{
2230:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001446  448572     ADD W9, #0x12, W10
001448  78000A     MOV W10, W0
00144A  020B28     CALL xTaskRemoveFromEventList
00144C  000000     NOP
00144E  E00000     CP0 W0
001450  320002     BRA Z, .L13
2231:              					{
2232:              						/* The task waiting has a higher priority so record that
2233:              						a context switch is required. */
2234:              						vTaskMissedYield();
001452  020C16     CALL vTaskMissedYield
001454  000000     NOP
2235:              					}
2236:              					else
2237:              					{
2238:              						mtCOVERAGE_TEST_MARKER();
2239:              					}
2240:              				}
2241:              				else
2242:              				{
2243:              					break;
2244:              				}
2245:              			}
2246:              			#endif /* configUSE_QUEUE_SETS */
2247:              
2248:              			--cTxLock;
001456  E94408     DEC.B W8, W8
2249:              		}
2250:              
2251:              		pxQueue->cTxLock = queueUNLOCKED;
00145C  EBC000     SETM.B W0
00145E  9864B0     MOV.B W0, [W9+35]
2252:              	}
2253:              	taskEXIT_CRITICAL();
001460  022604     CALL vPortExitCritical
001462  000000     NOP
2254:              
2255:              	/* Do the same for the Rx lock. */
2256:              	taskENTER_CRITICAL();
001464  0225F4     CALL vPortEnterCritical
001466  000000     NOP
2257:              	{
2258:              		int8_t cRxLock = pxQueue->cRxLock;
001468  906429     MOV.B [W9+34], W8
2259:              
2260:              		while( cRxLock > queueLOCKED_UNMODIFIED )
00146A  E00408     CP0.B W8
00146C  340013     BRA LE, .L15
001490  A94042     BCLR SR, #2
001492  3CFFF1     BRA GT, .L18
2261:              		{
2262:              			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00146E  900049     MOV [W9+8], W0
001470  E00000     CP0 W0
001472  3A0005     BRA NZ, .L16
001474  37000F     BRA .L15
001476  900049     MOV [W9+8], W0
001478  E00000     CP0 W0
00147A  3A0002     BRA NZ, .L20
00147C  37000B     BRA .L15
2263:              			{
2264:              				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00147E  448568     ADD W9, #0x8, W10
001480  78000A     MOV W10, W0
001482  020B28     CALL xTaskRemoveFromEventList
001484  000000     NOP
001486  E00000     CP0 W0
001488  320002     BRA Z, .L17
2265:              				{
2266:              					vTaskMissedYield();
00148A  020C16     CALL vTaskMissedYield
00148C  000000     NOP
2267:              				}
2268:              				else
2269:              				{
2270:              					mtCOVERAGE_TEST_MARKER();
2271:              				}
2272:              
2273:              				--cRxLock;
00148E  E94408     DEC.B W8, W8
2274:              			}
2275:              			else
2276:              			{
2277:              				break;
2278:              			}
2279:              		}
2280:              
2281:              		pxQueue->cRxLock = queueUNLOCKED;
001494  EBC000     SETM.B W0
001496  9864A0     MOV.B W0, [W9+34]
2282:              	}
2283:              	taskEXIT_CRITICAL();
001498  022604     CALL vPortExitCritical
00149A  000000     NOP
2284:              }
00149C  78054F     MOV [--W15], W10
00149E  BE044F     MOV.D [--W15], W8
0014A0  060000     RETURN
2285:              /*-----------------------------------------------------------*/
2286:              
2287:              static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2288:              {
00140C  781F88     MOV W8, [W15++]
00140E  780400     MOV W0, W8
2289:              BaseType_t xReturn;
2290:              
2291:              	taskENTER_CRITICAL();
001410  0225F4     CALL vPortEnterCritical
001412  000000     NOP
2292:              	{
2293:              		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
001414  900C68     MOV [W8+28], W8
2294:              		{
2295:              			xReturn = pdTRUE;
00141A  A7F008     BTSC W8, #15
00141C  EA0408     NEG W8, W8
00141E  E90008     DEC W8, W0
001420  DE004F     LSR W0, #15, W0
2296:              		}
2297:              		else
2298:              		{
2299:              			xReturn = pdFALSE;
2300:              		}
2301:              	}
2302:              	taskEXIT_CRITICAL();
001416  022604     CALL vPortExitCritical
001418  000000     NOP
2303:              
2304:              	return xReturn;
2305:              }
001422  78044F     MOV [--W15], W8
001424  060000     RETURN
2306:              /*-----------------------------------------------------------*/
2307:              
2308:              BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2309:              {
2310:              BaseType_t xReturn;
2311:              Queue_t * const pxQueue = xQueue;
2312:              
2313:              	configASSERT( pxQueue );
2314:              	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
0019C4  900860     MOV [W0+28], W0
2315:              	{
2316:              		xReturn = pdTRUE;
0019C6  A7F000     BTSC W0, #15
0019C8  EA0000     NEG W0, W0
0019CA  E90000     DEC W0, W0
0019CC  DE004F     LSR W0, #15, W0
2317:              	}
2318:              	else
2319:              	{
2320:              		xReturn = pdFALSE;
2321:              	}
2322:              
2323:              	return xReturn;
2324:              } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
0019CE  060000     RETURN
2325:              /*-----------------------------------------------------------*/
2326:              
2327:              static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2328:              {
0013EC  781F88     MOV W8, [W15++]
0013EE  780400     MOV W0, W8
2329:              BaseType_t xReturn;
2330:              
2331:              	taskENTER_CRITICAL();
0013F0  0225F4     CALL vPortEnterCritical
0013F2  000000     NOP
2332:              	{
2333:              		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
0013F4  9008E8     MOV [W8+28], W1
2334:              		{
2335:              			xReturn = pdTRUE;
0013F6  900878     MOV [W8+30], W0
0013F8  688400     XOR W1, W0, W8
0013FA  A7F008     BTSC W8, #15
0013FC  EA0408     NEG W8, W8
0013FE  E90408     DEC W8, W8
001400  DE444F     LSR W8, #15, W8
2336:              		}
2337:              		else
2338:              		{
2339:              			xReturn = pdFALSE;
2340:              		}
2341:              	}
2342:              	taskEXIT_CRITICAL();
001402  022604     CALL vPortExitCritical
001404  000000     NOP
2343:              
2344:              	return xReturn;
2345:              }
001406  780008     MOV W8, W0
001408  78044F     MOV [--W15], W8
00140A  060000     RETURN
2346:              /*-----------------------------------------------------------*/
2347:              
2348:              BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2349:              {
2350:              BaseType_t xReturn;
2351:              Queue_t * const pxQueue = xQueue;
2352:              
2353:              	configASSERT( pxQueue );
2354:              	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
0019D0  9008E0     MOV [W0+28], W1
2355:              	{
2356:              		xReturn = pdTRUE;
0019D2  900870     MOV [W0+30], W0
0019D4  688000     XOR W1, W0, W0
0019D6  A7F000     BTSC W0, #15
0019D8  EA0000     NEG W0, W0
0019DA  E90000     DEC W0, W0
0019DC  DE004F     LSR W0, #15, W0
2357:              	}
2358:              	else
2359:              	{
2360:              		xReturn = pdFALSE;
2361:              	}
2362:              
2363:              	return xReturn;
2364:              } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
0019DE  060000     RETURN
2365:              /*-----------------------------------------------------------*/
2366:              
2367:              #if ( configUSE_CO_ROUTINES == 1 )
2368:              
2369:              	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
2370:              	{
0019E0  BE9F88     MOV.D W8, [W15++]
0019E2  781F8A     MOV W10, [W15++]
0019E4  780400     MOV W0, W8
0019E6  780501     MOV W1, W10
0019E8  780482     MOV W2, W9
2371:              	BaseType_t xReturn;
2372:              	Queue_t * const pxQueue = xQueue;
2373:              
2374:              		/* If the queue is already full we may have to block.  A critical section
2375:              		is required to prevent an interrupt removing something from the queue
2376:              		between the check to see if the queue is full and blocking on the queue. */
2377:              		portDISABLE_INTERRUPTS();
0019EA  2FF1F0     MOV #0xFF1F, W0
0019EC  B60042     AND SR, WREG
0019EE  A05000     BSET W0, #5
0019F0  880210     MOV W0, SR
0019F2  000000     NOP
0019F4  000000     NOP
2378:              		{
2379:              			if( prvIsQueueFull( pxQueue ) != pdFALSE )
0019F6  780008     MOV W8, W0
0019F8  07FCF9     RCALL _prvIsQueueFull, .LFE16, .LFB20
0019FA  E00000     CP0 W0
0019FC  320010     BRA Z, .L125
2380:              			{
2381:              				/* The queue is full - do we want to block or just leave without
2382:              				posting? */
2383:              				if( xTicksToWait > ( TickType_t ) 0 )
0019FE  E00009     CP0 W9
001A00  320009     BRA Z, .L126
2384:              				{
2385:              					/* As this is called from a coroutine we cannot block directly, but
2386:              					return indicating that we need to block. */
2387:              					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
001A02  4400E8     ADD W8, #0x8, W1
001A04  780009     MOV W9, W0
001A06  021ECC     CALL vCoRoutineAddToDelayedList
001A08  000000     NOP
2388:              					portENABLE_INTERRUPTS();
001A0A  2FF1F0     MOV #0xFF1F, W0
001A0C  B62042     AND SR
001A0E  000000     NOP
2389:              					return errQUEUE_BLOCKED;
001A10  2FFFC0     MOV #0xFFFC, W0
001A12  370026     BRA .L127
2390:              				}
2391:              				else
2392:              				{
2393:              					portENABLE_INTERRUPTS();
001A14  2FF1F0     MOV #0xFF1F, W0
001A16  B62042     AND SR
001A18  000000     NOP
2394:              					return errQUEUE_FULL;
001A1A  EB0000     CLR W0
001A1C  370021     BRA .L127
2395:              				}
2396:              			}
2397:              		}
2398:              		portENABLE_INTERRUPTS();
001A1E  2FF1F0     MOV #0xFF1F, W0
001A20  B62042     AND SR
001A22  000000     NOP
2399:              
2400:              		portDISABLE_INTERRUPTS();
001A24  B60042     AND SR, WREG
001A26  A05000     BSET W0, #5
001A28  880210     MOV W0, SR
001A2A  000000     NOP
001A2C  000000     NOP
2401:              		{
2402:              			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
001A2E  900968     MOV [W8+28], W2
001A30  9008F8     MOV [W8+30], W1
001A34  510F81     SUB W2, W1, [W15]
001A36  310010     BRA C, .L128
2403:              			{
2404:              				/* There is room in the queue, copy the data into the queue. */
2405:              				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
001A38  EB0100     CLR W2
001A3A  78008A     MOV W10, W1
001A3C  780008     MOV W8, W0
001A3E  07FC96     RCALL .Letext0, .LFE4, _prvCopyDataToQueue, .Ltext0, .LFB15
2406:              				xReturn = pdPASS;
001A42  200010     MOV #0x1, W0
001A56  200010     MOV #0x1, W0
2407:              
2408:              				/* Were any co-routines waiting for data to become available? */
2409:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001A40  900898     MOV [W8+18], W1
001A44  E00001     CP0 W1
001A46  320008     BRA Z, .L128
2410:              				{
2411:              					/* In this instance the co-routine could be placed directly
2412:              					into the ready list as we are within a critical section.
2413:              					Instead the same pending ready list mechanism is used as if
2414:              					the event were caused from within an interrupt. */
2415:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001A48  440072     ADD W8, #0x12, W0
001A4A  0220D2     CALL xCoRoutineRemoveFromEventList
001A4C  000000     NOP
001A4E  780080     MOV W0, W1
001A52  E00001     CP0 W1
001A54  3A0001     BRA NZ, .L128
2416:              					{
2417:              						/* The co-routine waiting has a higher priority so record
2418:              						that a yield might be appropriate. */
2419:              						xReturn = errQUEUE_YIELD;
001A50  2FFFB0     MOV #0xFFFB, W0
2420:              					}
2421:              					else
2422:              					{
2423:              						mtCOVERAGE_TEST_MARKER();
2424:              					}
2425:              				}
2426:              				else
2427:              				{
2428:              					mtCOVERAGE_TEST_MARKER();
2429:              				}
2430:              			}
2431:              			else
2432:              			{
2433:              				xReturn = errQUEUE_FULL;
001A32  EB0000     CLR W0
2434:              			}
2435:              		}
2436:              		portENABLE_INTERRUPTS();
001A58  2FF1F1     MOV #0xFF1F, W1
001A5A  200422     MOV #0x42, W2
001A5C  608912     AND W1, [W2], [W2]
001A5E  000000     NOP
2437:              
2438:              		return xReturn;
2439:              	}
001A60  78054F     MOV [--W15], W10
001A62  BE044F     MOV.D [--W15], W8
001A64  060000     RETURN
2440:              
2441:              #endif /* configUSE_CO_ROUTINES */
2442:              /*-----------------------------------------------------------*/
2443:              
2444:              #if ( configUSE_CO_ROUTINES == 1 )
2445:              
2446:              	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2447:              	{
001A66  781F88     MOV W8, [W15++]
001A68  780400     MOV W0, W8
001A6A  780181     MOV W1, W3
2448:              	BaseType_t xReturn;
2449:              	Queue_t * const pxQueue = xQueue;
2450:              
2451:              		/* If the queue is already empty we may have to block.  A critical section
2452:              		is required to prevent an interrupt adding something to the queue
2453:              		between the check to see if the queue is empty and blocking on the queue. */
2454:              		portDISABLE_INTERRUPTS();
001A6C  2FF1F0     MOV #0xFF1F, W0
001A6E  B60042     AND SR, WREG
001A70  A05000     BSET W0, #5
001A72  880210     MOV W0, SR
001A74  000000     NOP
001A76  000000     NOP
2455:              		{
2456:              			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
001A78  900868     MOV [W8+28], W0
001A7A  E00000     CP0 W0
001A7C  3A0010     BRA NZ, .L133
2457:              			{
2458:              				/* There are no messages in the queue, do we want to block or just
2459:              				leave with nothing? */
2460:              				if( xTicksToWait > ( TickType_t ) 0 )
001A7E  E00002     CP0 W2
001A80  320009     BRA Z, .L134
2461:              				{
2462:              					/* As this is a co-routine we cannot block directly, but return
2463:              					indicating that we need to block. */
2464:              					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
001A82  4400F2     ADD W8, #0x12, W1
001A84  780002     MOV W2, W0
001A86  021ECC     CALL vCoRoutineAddToDelayedList
001A88  000000     NOP
2465:              					portENABLE_INTERRUPTS();
001A8A  2FF1F0     MOV #0xFF1F, W0
001A8C  B62042     AND SR
001A8E  000000     NOP
2466:              					return errQUEUE_BLOCKED;
001A90  2FFFC0     MOV #0xFFFC, W0
001A92  370031     BRA .L135
2467:              				}
2468:              				else
2469:              				{
2470:              					portENABLE_INTERRUPTS();
001A94  2FF1F0     MOV #0xFF1F, W0
001A96  B62042     AND SR
001A98  000000     NOP
2471:              					return errQUEUE_FULL;
001A9A  EB0000     CLR W0
001A9C  37002C     BRA .L135
2472:              				}
2473:              			}
2474:              			else
2475:              			{
2476:              				mtCOVERAGE_TEST_MARKER();
2477:              			}
2478:              		}
2479:              		portENABLE_INTERRUPTS();
001A9E  2FF1F0     MOV #0xFF1F, W0
001AA0  B62042     AND SR
001AA2  000000     NOP
2480:              
2481:              		portDISABLE_INTERRUPTS();
001AA4  B60042     AND SR, WREG
001AA6  A05000     BSET W0, #5
001AA8  880210     MOV W0, SR
001AAA  000000     NOP
001AAC  000000     NOP
2482:              		{
2483:              			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
001AAE  9008E8     MOV [W8+28], W1
001AB2  E00001     CP0 W1
001AB4  32001C     BRA Z, .L136
2484:              			{
2485:              				/* Data is available from the queue. */
2486:              				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
001AB6  901108     MOV [W8+32], W2
001AB8  900038     MOV [W8+6], W0
001ABA  400002     ADD W0, W2, W0
001ABC  980430     MOV W0, [W8+6]
2487:              				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
001ABE  9000A8     MOV [W8+4], W1
001AC0  500F81     SUB W0, W1, [W15]
001AC2  390002     BRA NC, .L137
2488:              				{
2489:              					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
001AC4  780018     MOV [W8], W0
001AC6  980430     MOV W0, [W8+6]
2490:              				}
2491:              				else
2492:              				{
2493:              					mtCOVERAGE_TEST_MARKER();
2494:              				}
2495:              				--( pxQueue->uxMessagesWaiting );
001AC8  900868     MOV [W8+28], W0
001ACA  E90000     DEC W0, W0
001ACC  980C60     MOV W0, [W8+28]
2496:              				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
001ACE  9000B8     MOV [W8+6], W1
001AD0  780003     MOV W3, W0
001AD2  0207CC     CALL _memcpy
001AD4  000000     NOP
2497:              
2498:              				xReturn = pdPASS;
001AD8  200010     MOV #0x1, W0
001AEC  200010     MOV #0x1, W0
2499:              
2500:              				/* Were any co-routines waiting for space to become available? */
2501:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
001AD6  9000C8     MOV [W8+8], W1
001ADA  E00001     CP0 W1
001ADC  320008     BRA Z, .L136
2502:              				{
2503:              					/* In this instance the co-routine could be placed directly
2504:              					into the ready list as we are within a critical section.
2505:              					Instead the same pending ready list mechanism is used as if
2506:              					the event were caused from within an interrupt. */
2507:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
001ADE  440068     ADD W8, #0x8, W0
001AE0  0220D2     CALL xCoRoutineRemoveFromEventList
001AE2  000000     NOP
001AE4  780080     MOV W0, W1
001AE8  E00001     CP0 W1
001AEA  3A0001     BRA NZ, .L136
2508:              					{
2509:              						xReturn = errQUEUE_YIELD;
001AE6  2FFFB0     MOV #0xFFFB, W0
2510:              					}
2511:              					else
2512:              					{
2513:              						mtCOVERAGE_TEST_MARKER();
2514:              					}
2515:              				}
2516:              				else
2517:              				{
2518:              					mtCOVERAGE_TEST_MARKER();
2519:              				}
2520:              			}
2521:              			else
2522:              			{
2523:              				xReturn = pdFAIL;
001AB0  EB0000     CLR W0
2524:              			}
2525:              		}
2526:              		portENABLE_INTERRUPTS();
001AEE  2FF1F1     MOV #0xFF1F, W1
001AF0  200422     MOV #0x42, W2
001AF2  608912     AND W1, [W2], [W2]
001AF4  000000     NOP
2527:              
2528:              		return xReturn;
2529:              	}
001AF6  78044F     MOV [--W15], W8
001AF8  060000     RETURN
2530:              
2531:              #endif /* configUSE_CO_ROUTINES */
2532:              /*-----------------------------------------------------------*/
2533:              
2534:              #if ( configUSE_CO_ROUTINES == 1 )
2535:              
2536:              	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
001B1E  780480     MOV W0, W9
001B20  A7F009     BTSC W9, #15
001B22  EA0489     NEG W9, W9
001B24  EA0489     NEG W9, W9
2537:              	{
001AFA  BE9F88     MOV.D W8, [W15++]
001AFC  780400     MOV W0, W8
001AFE  780482     MOV W2, W9
2538:              	Queue_t * const pxQueue = xQueue;
2539:              
2540:              		/* Cannot block within an ISR so if there is no space on the queue then
2541:              		exit without doing anything. */
2542:              		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
001B00  900968     MOV [W8+28], W2
001B02  900878     MOV [W8+30], W0
001B04  510F80     SUB W2, W0, [W15]
001B06  310010     BRA C, .L142
2543:              		{
2544:              			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
001B08  EB0100     CLR W2
001B0A  780008     MOV W8, W0
001B0C  07FC2F     RCALL .Letext0, .LFE4, _prvCopyDataToQueue, .Ltext0, .LFB15
2545:              
2546:              			/* We only want to wake one co-routine per ISR, so check that a
2547:              			co-routine has not already been woken. */
2548:              			if( xCoRoutinePreviouslyWoken == pdFALSE )
001B0E  E00009     CP0 W9
001B10  3A000B     BRA NZ, .L142
2549:              			{
2550:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001B12  900818     MOV [W8+18], W0
001B14  E00000     CP0 W0
001B16  320008     BRA Z, .L142
2551:              				{
2552:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001B18  440072     ADD W8, #0x12, W0
001B1A  0220D2     CALL xCoRoutineRemoveFromEventList
001B1C  000000     NOP
2553:              					{
2554:              						return pdTRUE;
001B26  DE4CCF     LSR W9, #15, W9
2555:              					}
2556:              					else
2557:              					{
2558:              						mtCOVERAGE_TEST_MARKER();
2559:              					}
2560:              				}
2561:              				else
2562:              				{
2563:              					mtCOVERAGE_TEST_MARKER();
2564:              				}
2565:              			}
2566:              			else
2567:              			{
2568:              				mtCOVERAGE_TEST_MARKER();
2569:              			}
2570:              		}
2571:              		else
2572:              		{
2573:              			mtCOVERAGE_TEST_MARKER();
2574:              		}
2575:              
2576:              		return xCoRoutinePreviouslyWoken;
2577:              	}
001B28  780009     MOV W9, W0
001B2A  BE044F     MOV.D [--W15], W8
001B2C  060000     RETURN
2578:              
2579:              #endif /* configUSE_CO_ROUTINES */
2580:              /*-----------------------------------------------------------*/
2581:              
2582:              #if ( configUSE_CO_ROUTINES == 1 )
2583:              
2584:              	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
2585:              	{
001B2E  BE9F88     MOV.D W8, [W15++]
001B30  780400     MOV W0, W8
001B32  780181     MOV W1, W3
001B34  780482     MOV W2, W9
2586:              	BaseType_t xReturn;
2587:              	Queue_t * const pxQueue = xQueue;
2588:              
2589:              		/* We cannot block from an ISR, so check there is data available. If
2590:              		not then just leave without doing anything. */
2591:              		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
001B36  9008E8     MOV [W8+28], W1
001B3A  E00001     CP0 W1
001B3C  32001E     BRA Z, .L144
2592:              		{
2593:              			/* Copy the data from the queue. */
2594:              			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
001B3E  901108     MOV [W8+32], W2
001B40  900038     MOV [W8+6], W0
001B42  400002     ADD W0, W2, W0
001B44  980430     MOV W0, [W8+6]
2595:              			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
001B46  9000A8     MOV [W8+4], W1
001B48  500F81     SUB W0, W1, [W15]
001B4A  390002     BRA NC, .L145
2596:              			{
2597:              				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
001B4C  780018     MOV [W8], W0
001B4E  980430     MOV W0, [W8+6]
2598:              			}
2599:              			else
2600:              			{
2601:              				mtCOVERAGE_TEST_MARKER();
2602:              			}
2603:              			--( pxQueue->uxMessagesWaiting );
001B50  900868     MOV [W8+28], W0
001B52  E90000     DEC W0, W0
001B54  980C60     MOV W0, [W8+28]
2604:              			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
001B56  9000B8     MOV [W8+6], W1
001B58  780003     MOV W3, W0
001B5A  0207CC     CALL _memcpy
001B5C  000000     NOP
2605:              
2606:              			if( ( *pxCoRoutineWoken ) == pdFALSE )
001B60  E00019     CP0 [W9]
001B62  3A000B     BRA NZ, .L144
2607:              			{
2608:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
001B64  9000C8     MOV [W8+8], W1
001B66  E00001     CP0 W1
001B68  320008     BRA Z, .L144
2609:              				{
2610:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
001B6A  440068     ADD W8, #0x8, W0
001B6C  0220D2     CALL xCoRoutineRemoveFromEventList
001B6E  000000     NOP
001B70  780080     MOV W0, W1
001B74  E00001     CP0 W1
001B76  320001     BRA Z, .L144
2611:              					{
2612:              						*pxCoRoutineWoken = pdTRUE;
001B78  780C80     MOV W0, [W9]
2613:              					}
2614:              					else
2615:              					{
2616:              						mtCOVERAGE_TEST_MARKER();
2617:              					}
2618:              				}
2619:              				else
2620:              				{
2621:              					mtCOVERAGE_TEST_MARKER();
2622:              				}
2623:              			}
2624:              			else
2625:              			{
2626:              				mtCOVERAGE_TEST_MARKER();
2627:              			}
2628:              
2629:              			xReturn = pdPASS;
001B5E  200010     MOV #0x1, W0
001B72  200010     MOV #0x1, W0
2630:              		}
2631:              		else
2632:              		{
2633:              			xReturn = pdFAIL;
001B38  EB0000     CLR W0
2634:              		}
2635:              
2636:              		return xReturn;
2637:              	}
001B7A  BE044F     MOV.D [--W15], W8
001B7C  060000     RETURN
2638:              
2639:              #endif /* configUSE_CO_ROUTINES */
2640:              /*-----------------------------------------------------------*/
2641:              
2642:              #if ( configQUEUE_REGISTRY_SIZE > 0 )
2643:              
2644:              	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2645:              	{
2646:              	UBaseType_t ux;
2647:              
2648:              		/* See if there is an empty space in the registry.  A NULL name denotes
2649:              		a free slot. */
2650:              		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2651:              		{
2652:              			if( xQueueRegistry[ ux ].pcQueueName == NULL )
2653:              			{
2654:              				/* Store the information on this queue. */
2655:              				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
2656:              				xQueueRegistry[ ux ].xHandle = xQueue;
2657:              
2658:              				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2659:              				break;
2660:              			}
2661:              			else
2662:              			{
2663:              				mtCOVERAGE_TEST_MARKER();
2664:              			}
2665:              		}
2666:              	}
2667:              
2668:              #endif /* configQUEUE_REGISTRY_SIZE */
2669:              /*-----------------------------------------------------------*/
2670:              
2671:              #if ( configQUEUE_REGISTRY_SIZE > 0 )
2672:              
2673:              	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2674:              	{
2675:              	UBaseType_t ux;
2676:              	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2677:              
2678:              		/* Note there is nothing here to protect against another task adding or
2679:              		removing entries from the registry while it is being searched. */
2680:              		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2681:              		{
2682:              			if( xQueueRegistry[ ux ].xHandle == xQueue )
2683:              			{
2684:              				pcReturn = xQueueRegistry[ ux ].pcQueueName;
2685:              				break;
2686:              			}
2687:              			else
2688:              			{
2689:              				mtCOVERAGE_TEST_MARKER();
2690:              			}
2691:              		}
2692:              
2693:              		return pcReturn;
2694:              	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
2695:              
2696:              #endif /* configQUEUE_REGISTRY_SIZE */
2697:              /*-----------------------------------------------------------*/
2698:              
2699:              #if ( configQUEUE_REGISTRY_SIZE > 0 )
2700:              
2701:              	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2702:              	{
2703:              	UBaseType_t ux;
2704:              
2705:              		/* See if the handle of the queue being unregistered in actually in the
2706:              		registry. */
2707:              		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2708:              		{
2709:              			if( xQueueRegistry[ ux ].xHandle == xQueue )
2710:              			{
2711:              				/* Set the name to NULL to show that this slot if free again. */
2712:              				xQueueRegistry[ ux ].pcQueueName = NULL;
2713:              
2714:              				/* Set the handle to NULL to ensure the same queue handle cannot
2715:              				appear in the registry twice if it is added, removed, then
2716:              				added again. */
2717:              				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
2718:              				break;
2719:              			}
2720:              			else
2721:              			{
2722:              				mtCOVERAGE_TEST_MARKER();
2723:              			}
2724:              		}
2725:              
2726:              	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2727:              
2728:              #endif /* configQUEUE_REGISTRY_SIZE */
2729:              /*-----------------------------------------------------------*/
2730:              
2731:              #if ( configUSE_TIMERS == 1 )
2732:              
2733:              	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
2734:              	{
2735:              	Queue_t * const pxQueue = xQueue;
2736:              
2737:              		/* This function should not be called by application code hence the
2738:              		'Restricted' in its name.  It is not part of the public API.  It is
2739:              		designed for use by kernel code, and has special calling requirements.
2740:              		It can result in vListInsert() being called on a list that can only
2741:              		possibly ever have one item in it, so the list will be fast, but even
2742:              		so it should be called with the scheduler locked and not from a critical
2743:              		section. */
2744:              
2745:              		/* Only do anything if there are no messages in the queue.  This function
2746:              		will not actually cause the task to block, just place it on a blocked
2747:              		list.  It will not block until the scheduler is unlocked - at which
2748:              		time a yield will be performed.  If an item is added to the queue while
2749:              		the queue is locked, and the calling task blocks on the queue, then the
2750:              		calling task will be immediately unblocked when the queue is unlocked. */
2751:              		prvLockQueue( pxQueue );
2752:              		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
2753:              		{
2754:              			/* There is nothing in the queue, block for the specified period. */
2755:              			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
2756:              		}
2757:              		else
2758:              		{
2759:              			mtCOVERAGE_TEST_MARKER();
2760:              		}
2761:              		prvUnlockQueue( pxQueue );
2762:              	}
2763:              
2764:              #endif /* configUSE_TIMERS */
2765:              /*-----------------------------------------------------------*/
2766:              
2767:              #if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2768:              
2769:              	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
2770:              	{
2771:              	QueueSetHandle_t pxQueue;
2772:              
2773:              		pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
2774:              
2775:              		return pxQueue;
2776:              	}
2777:              
2778:              #endif /* configUSE_QUEUE_SETS */
2779:              /*-----------------------------------------------------------*/
2780:              
2781:              #if ( configUSE_QUEUE_SETS == 1 )
2782:              
2783:              	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2784:              	{
2785:              	BaseType_t xReturn;
2786:              
2787:              		taskENTER_CRITICAL();
2788:              		{
2789:              			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
2790:              			{
2791:              				/* Cannot add a queue/semaphore to more than one queue set. */
2792:              				xReturn = pdFAIL;
2793:              			}
2794:              			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
2795:              			{
2796:              				/* Cannot add a queue/semaphore to a queue set if there are already
2797:              				items in the queue/semaphore. */
2798:              				xReturn = pdFAIL;
2799:              			}
2800:              			else
2801:              			{
2802:              				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
2803:              				xReturn = pdPASS;
2804:              			}
2805:              		}
2806:              		taskEXIT_CRITICAL();
2807:              
2808:              		return xReturn;
2809:              	}
2810:              
2811:              #endif /* configUSE_QUEUE_SETS */
2812:              /*-----------------------------------------------------------*/
2813:              
2814:              #if ( configUSE_QUEUE_SETS == 1 )
2815:              
2816:              	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2817:              	{
2818:              	BaseType_t xReturn;
2819:              	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
2820:              
2821:              		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
2822:              		{
2823:              			/* The queue was not a member of the set. */
2824:              			xReturn = pdFAIL;
2825:              		}
2826:              		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
2827:              		{
2828:              			/* It is dangerous to remove a queue from a set when the queue is
2829:              			not empty because the queue set will still hold pending events for
2830:              			the queue. */
2831:              			xReturn = pdFAIL;
2832:              		}
2833:              		else
2834:              		{
2835:              			taskENTER_CRITICAL();
2836:              			{
2837:              				/* The queue is no longer contained in the set. */
2838:              				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
2839:              			}
2840:              			taskEXIT_CRITICAL();
2841:              			xReturn = pdPASS;
2842:              		}
2843:              
2844:              		return xReturn;
2845:              	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
2846:              
2847:              #endif /* configUSE_QUEUE_SETS */
2848:              /*-----------------------------------------------------------*/
2849:              
2850:              #if ( configUSE_QUEUE_SETS == 1 )
2851:              
2852:              	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
2853:              	{
2854:              	QueueSetMemberHandle_t xReturn = NULL;
2855:              
2856:              		( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */
2857:              		return xReturn;
2858:              	}
2859:              
2860:              #endif /* configUSE_QUEUE_SETS */
2861:              /*-----------------------------------------------------------*/
2862:              
2863:              #if ( configUSE_QUEUE_SETS == 1 )
2864:              
2865:              	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
2866:              	{
2867:              	QueueSetMemberHandle_t xReturn = NULL;
2868:              
2869:              		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
2870:              		return xReturn;
2871:              	}
2872:              
2873:              #endif /* configUSE_QUEUE_SETS */
2874:              /*-----------------------------------------------------------*/
2875:              
2876:              #if ( configUSE_QUEUE_SETS == 1 )
2877:              
2878:              	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
2879:              	{
2880:              	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
2881:              	BaseType_t xReturn = pdFALSE;
2882:              
2883:              		/* This function must be called form a critical section. */
2884:              
2885:              		configASSERT( pxQueueSetContainer );
2886:              		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
2887:              
2888:              		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
2889:              		{
2890:              			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
2891:              
2892:              			traceQUEUE_SEND( pxQueueSetContainer );
2893:              
2894:              			/* The data copied is the handle of the queue that contains data. */
2895:              			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
2896:              
2897:              			if( cTxLock == queueUNLOCKED )
2898:              			{
2899:              				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
2900:              				{
2901:              					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
2902:              					{
2903:              						/* The task waiting has a higher priority. */
2904:              						xReturn = pdTRUE;
2905:              					}
2906:              					else
2907:              					{
2908:              						mtCOVERAGE_TEST_MARKER();
2909:              					}
2910:              				}
2911:              				else
2912:              				{
2913:              					mtCOVERAGE_TEST_MARKER();
2914:              				}
2915:              			}
2916:              			else
2917:              			{
2918:              				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
2919:              			}
2920:              		}
2921:              		else
2922:              		{
2923:              			mtCOVERAGE_TEST_MARKER();
2924:              		}
2925:              
2926:              		return xReturn;
2927:              	}
2928:              
2929:              #endif /* configUSE_QUEUE_SETS */
2930:              
2931:              
2932:              
2933:              
2934:              
2935:              
2936:              
2937:              
2938:              
2939:              
2940:              
2941:              
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Source/portable/MemMang/heap_1.c  -----------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                
29:                /*
30:                 * The simplest possible implementation of pvPortMalloc().  Note that this
31:                 * implementation does NOT allow allocated memory to be freed again.
32:                 *
33:                 * See heap_2.c, heap_3.c and heap_4.c for alternative implementations, and the
34:                 * memory management pages of http://www.FreeRTOS.org for more information.
35:                 */
36:                #include <stdlib.h>
37:                
38:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
39:                all the API functions to use the MPU wrappers.  That should only be done when
40:                task.h is included from an application file. */
41:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
42:                
43:                #include "FreeRTOS.h"
44:                #include "task.h"
45:                
46:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
47:                
48:                #if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
49:                #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
50:                #endif
51:                
52:                /* A few bytes might be lost to byte aligning the heap start address. */
53:                #define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
54:                
55:                /* Allocate the memory for the heap. */
56:                #if( configAPPLICATION_ALLOCATED_HEAP == 1 )
57:                /* The application writer has already defined the array used for the RTOS
58:                heap - probably so it can be placed in a special segment or address. */
59:                extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
60:                #else
61:                static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
62:                #endif /* configAPPLICATION_ALLOCATED_HEAP */
63:                
64:                /* Index into the ucHeap array. */
65:                static size_t xNextFreeByte = (size_t) 0;
66:                
67:                /*-----------------------------------------------------------*/
68:                
69:                void *pvPortMalloc(size_t xWantedSize) {
0028C0  BE9F88     MOV.D W8, [W15++]
0028C2  780400     MOV W0, W8
70:                    void *pvReturn = NULL;
0028DE  EB0480     CLR W9
71:                    static uint8_t *pucAlignedHeap = NULL;
72:                
73:                    /* Ensure that blocks are always aligned to the required number of bytes. */
74:                #if( portBYTE_ALIGNMENT != 1 )
75:                    {
76:                        if (xWantedSize & portBYTE_ALIGNMENT_MASK) {
0028C4  A30808     BTST.Z W8, #0
0028C6  320002     BRA Z, .L2
77:                            /* Byte alignment required. */
78:                            xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
0028C8  A10008     BCLR W8, #0
0028CA  E88408     INC2 W8, W8
79:                        }
80:                    }
81:                #endif
82:                
83:                    vTaskSuspendAll();
0028CC  020A86     CALL vTaskSuspendAll
0028CE  000000     NOP
84:                    {
85:                        if (pucAlignedHeap == NULL) {
0028D0  E208A0     CP0 .Ltext0, .LFB1, _prvInitialiseNewTask
0028D2  3A0003     BRA NZ, .L3
86:                            /* Ensure the heap starts on a correctly aligned boundary. */
87:                            pucAlignedHeap = (uint8_t *) (((portPOINTER_SIZE_TYPE) & ucHeap[ portBYTE_ALIGNMENT ]) & (~((portPOINTER_SIZE_TYPE) portBYTE_ALIGNMENT_MASK)));
0028D4  208AE0     MOV #0x8AE, W0
0028D6  A10000     BCLR W0, #0
0028D8  884500     MOV W0, .Ltext0, .LFB1, _prvInitialiseNewTask
88:                        }
89:                
90:                        /* Check there is enough room left for the allocation. */
91:                        if (((xNextFreeByte + xWantedSize) < configADJUSTED_HEAP_SIZE) &&
0028DA  8044F0     MOV xNextFreeByte, W0
0028DC  440400     ADD W8, W0, W8
0028E0  213FD1     MOV #0x13FD, W1
0028E2  540F81     SUB W8, W1, [W15]
0028E4  3E0005     BRA GTU, .L4
0028E6  500F88     SUB W0, W8, [W15]
0028E8  310003     BRA C, .L4
92:                                ((xNextFreeByte + xWantedSize) > xNextFreeByte))/* Check for overflow. */ {
93:                            /* Return the next free byte then increment the index past this
94:                            block. */
95:                            pvReturn = pucAlignedHeap + xNextFreeByte;
0028EA  B408A0     ADD .Ltext0, .LFB1, _prvInitialiseNewTask, WREG
0028EC  780480     MOV W0, W9
96:                            xNextFreeByte += xWantedSize;
0028EE  8844F8     MOV W8, xNextFreeByte
97:                        }
98:                
99:                        traceMALLOC(pvReturn, xWantedSize);
100:                   }
101:                   (void) xTaskResumeAll();
0028F0  020E4C     CALL xTaskResumeAll
0028F2  000000     NOP
102:               
103:               #if( configUSE_MALLOC_FAILED_HOOK == 1 )
104:                   {
105:                       if (pvReturn == NULL) {
106:               
107:                           extern void vApplicationMallocFailedHook(void);
108:                           vApplicationMallocFailedHook();
109:                       }
110:                   }
111:               #endif
112:               
113:                   return pvReturn;
114:               }
0028F4  780009     MOV W9, W0
0028F6  BE044F     MOV.D [--W15], W8
0028F8  060000     RETURN
115:               
116:               /*-----------------------------------------------------------*/
117:               
118:               void vPortFree(void *pv) {
119:                   /* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and
120:                   heap_4.c for alternative implementations, and the memory management pages of
121:                   http://www.FreeRTOS.org for more information. */
122:                   (
123:               
124:                           void) pv;
125:               
126:                   /* Force an assert as it is invalid to call this function. */
127:                   configASSERT(pv == NULL);
128:               }
0028FA  060000     RETURN
129:               
130:               /*-----------------------------------------------------------*/
131:               
132:               void vPortInitialiseBlocks(void) {
133:               
134:                   /* Only required when static memory is not cleared. */
135:                   xNextFreeByte = (size_t) 0;
0028FC  EF289E     CLR xNextFreeByte
136:               }
0028FE  060000     RETURN
137:               
138:               /*-----------------------------------------------------------*/
139:               
140:               size_t xPortGetFreeHeapSize(void) {
141:                   return ( configADJUSTED_HEAP_SIZE - xNextFreeByte);
002900  8044F0     MOV xNextFreeByte, W0
002902  213FE1     MOV #0x13FE, W1
002904  508000     SUB W1, W0, W0
142:               }
002906  060000     RETURN
143:               
144:               
145:               
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Source/portable/MPLAB/PIC24_dsPIC/portasm_PIC24.S  ------
                                                  1:     /*
                                                  2:      * FreeRTOS Kernel V10.1.1
                                                  3:      * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
                                                  4:      *
                                                  5:      * Permission is hereby granted, free of charge, to any person obtaining a copy of
                                                  6:      * this software and associated documentation files (the "Software"), to deal in
                                                  7:      * the Software without restriction, including without limitation the rights to
                                                  8:      * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
                                                  9:      * the Software, and to permit persons to whom the Software is furnished to do so,
                                                  10:     * subject to the following conditions:
                                                  11:     *
                                                  12:     * The above copyright notice and this permission notice shall be included in all
                                                  13:     * copies or substantial portions of the Software.
                                                  14:     *
                                                  15:     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                                                  16:     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
                                                  17:     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
                                                  18:     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
                                                  19:     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
                                                  20:     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                                                  21:     *
                                                  22:     * http://www.FreeRTOS.org
                                                  23:     * http://aws.amazon.com/freertos
                                                  24:     *
                                                  25:     * 1 tab == 4 spaces!
                                                  26:     */
                                                  27:    
                                                  28:    #if defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ )
                                                  29:    
                                                  30:            .global _vPortYield
                                                  31:    		.extern _vTaskSwitchContext
                                                  32:    		.extern uxCriticalNesting
                                                  33:    
                                                  34:    _vPortYield:
                                                  35:    
00286C  F80042     PUSH SR                        36:    		PUSH	SR						/* Save the SR used by the task.... */
00286E  781F80     MOV W0, [W15++]                37:    		PUSH	W0						/* ....then disable interrupts. */
002870  200200     MOV #0x20, W0                  38:    		MOV		#32, W0
002872  880210     MOV W0, SR                     39:    		MOV		W0, SR
002874  781F81     MOV W1, [W15++]                40:    		PUSH	W1						/* Save registers to the stack. */
002876  BE9F82     MOV.D W2, [W15++]              41:    		PUSH.D	W2
002878  BE9F84     MOV.D W4, [W15++]              42:    		PUSH.D	W4
00287A  BE9F86     MOV.D W6, [W15++]              43:    		PUSH.D	W6
00287C  BE9F88     MOV.D W8, [W15++]              44:    		PUSH.D 	W8
00287E  BE9F8A     MOV.D W10, [W15++]             45:    		PUSH.D 	W10
002880  BE9F8C     MOV.D W12, [W15++]             46:    		PUSH.D	W12
002882  781F8E     MOV W14, [W15++]               47:    		PUSH	W14
002884  F80036     PUSH RCOUNT                    48:    		PUSH	RCOUNT
002886  F80054     PUSH TBLPAG                    49:    		PUSH	TBLPAG
                                                  50:    
002888  F80044     PUSH CORCON                    51:    		PUSH	CORCON
                                                  52:    		#ifdef __HAS_EDS__
00288A  F80032     PUSH DSRPAG                    53:    			PUSH	DSRPAG
00288C  F80034     PUSH DSWPAG                    54:    			PUSH	DSWPAG
                                                  55:    		#else
                                                  56:    			PUSH	PSVPAG
                                                  57:    		#endif /* __HAS_EDS__ */
00288E  804140     MOV 0x828, W0                  58:    		MOV		_uxCriticalNesting, W0		/* Save the critical nesting counter for the task. */
002890  781F80     MOV W0, [W15++]                59:    		PUSH	W0
002892  804280     MOV 0x850, W0                  60:    		MOV		_pxCurrentTCB, W0			/* Save the new top of stack into the TCB. */
002894  78080F     MOV W15, [W0]                  61:    		MOV		W15, [W0]
                                                  62:    
002896  020AAE     CALL 0xAAE                     63:    		call 	_vTaskSwitchContext
                                                  64:    
00289A  804280     MOV 0x850, W0                  65:    		MOV		_pxCurrentTCB, W0			/* Restore the stack pointer for the task. */
00289C  780790     MOV [W0], W15                  66:    		MOV		[W0], W15
00289E  78004F     MOV [--W15], W0                67:    		POP		W0							/* Restore the critical nesting counter for the task. */
0028A0  884140     MOV W0, 0x828                  68:    		MOV		W0, _uxCriticalNesting
                                                  69:    		#ifdef __HAS_EDS__
0028A2  F90034     POP DSWPAG                     70:    			POP		DSWPAG
0028A4  F90032     POP DSRPAG                     71:    			POP		DSRPAG
                                                  72:    		#else
                                                  73:    			POP		PSVPAG
                                                  74:    		#endif /* __HAS_EDS__ */
0028A6  F90044     POP CORCON                     75:    		POP		CORCON
0028A8  F90054     POP TBLPAG                     76:    		POP		TBLPAG
0028AA  F90036     POP RCOUNT                     77:    		POP		RCOUNT						/* Restore the registers from the stack. */
0028AC  78074F     MOV [--W15], W14               78:    		POP		W14
0028AE  BE064F     MOV.D [--W15], W12             79:    		POP.D	W12
0028B0  BE054F     MOV.D [--W15], W10             80:    		POP.D	W10
0028B2  BE044F     MOV.D [--W15], W8              81:    		POP.D	W8
0028B4  BE034F     MOV.D [--W15], W6              82:    		POP.D	W6
0028B6  BE024F     MOV.D [--W15], W4              83:    		POP.D	W4
0028B8  BE014F     MOV.D [--W15], W2              84:    		POP.D	W2
0028BA  BE004F     MOV.D [--W15], W0              85:    		POP.D	W0
0028BC  F90042     POP SR                         86:    		POP		SR
                                                  87:    
0028BE  060000     RETURN                         88:            return
                                                  89:    
                                                  90:            .end
                                                  91:    		
                                                  92:    #endif /* defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ ) */
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Source/portable/MPLAB/PIC24_dsPIC/port.c  ---------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                /*
29:                	Changes from V4.2.1
30:                
31:                	+ Introduced the configKERNEL_INTERRUPT_PRIORITY definition.
32:                */
33:                
34:                /*-----------------------------------------------------------
35:                 * Implementation of functions defined in portable.h for the PIC24 port.
36:                 *----------------------------------------------------------*/
37:                
38:                /* Scheduler include files. */
39:                #include "FreeRTOS.h"
40:                #include "task.h"
41:                
42:                /* Hardware specifics. */
43:                #define portBIT_SET 1
44:                #define portTIMER_PRESCALE 8
45:                #define portINITIAL_SR	0
46:                
47:                /* Defined for backward compatability with project created prior to
48:                FreeRTOS.org V4.3.0. */
49:                #ifndef configKERNEL_INTERRUPT_PRIORITY
50:                	#define configKERNEL_INTERRUPT_PRIORITY 1
51:                #endif
52:                
53:                /* Use _T1Interrupt as the interrupt handler name if the application writer has
54:                not provided their own. */
55:                #ifndef configTICK_INTERRUPT_HANDLER
56:                	#define configTICK_INTERRUPT_HANDLER _T1Interrupt
57:                #endif /* configTICK_INTERRUPT_HANDLER */
58:                
59:                /* The program counter is only 23 bits. */
60:                #define portUNUSED_PR_BITS	0x7f
61:                
62:                /* Records the nesting depth of calls to portENTER_CRITICAL(). */
63:                UBaseType_t uxCriticalNesting = 0xef;
64:                
65:                #if configKERNEL_INTERRUPT_PRIORITY != 1
66:                	#error If configKERNEL_INTERRUPT_PRIORITY is not 1 then the #32 in the following macros needs changing to equal the portINTERRUPT_BITS value, which is ( configKERNEL_INTERRUPT_PRIORITY << 5 )
67:                #endif
68:                
69:                #if defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ )
70:                
71:                    #ifdef __HAS_EDS__
72:                		#define portRESTORE_CONTEXT()																						\
73:                					asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */		\
74:                							"MOV	[W0], W15				\n"																\
75:                							"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
76:                							"MOV	W0, _uxCriticalNesting	\n"																\
77:                							"POP	DSWPAG					\n"																\
78:                							"POP    DSRPAG					\n"																\
79:                							"POP	CORCON					\n"																\
80:                							"POP	TBLPAG					\n"																\
81:                							"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
82:                							"POP	W14						\n"																\
83:                							"POP.D	W12						\n"																\
84:                							"POP.D	W10						\n"																\
85:                							"POP.D	W8						\n"																\
86:                							"POP.D	W6						\n"																\
87:                							"POP.D	W4						\n"																\
88:                							"POP.D	W2						\n"																\
89:                							"POP.D	W0						\n"																\
90:                							"POP	SR						  " );
91:                	#else /* __HAS_EDS__ */
92:                		#define portRESTORE_CONTEXT()																						\
93:                			asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */				\
94:                							"MOV	[W0], W15				\n"																\
95:                							"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
96:                							"MOV	W0, _uxCriticalNesting	\n"																\
97:                							"POP	PSVPAG					\n"																\
98:                							"POP	CORCON					\n"																\
99:                							"POP	TBLPAG					\n"																\
100:               							"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
101:               							"POP	W14						\n"																\
102:               							"POP.D	W12						\n"																\
103:               							"POP.D	W10						\n"																\
104:               							"POP.D	W8						\n"																\
105:               							"POP.D	W6						\n"																\
106:               							"POP.D	W4						\n"																\
107:               							"POP.D	W2						\n"																\
108:               							"POP.D	W0						\n"																\
109:               							"POP	SR						  " );
110:               		#endif /* __HAS_EDS__ */
111:               #endif /* MPLAB_PIC24_PORT */
112:               
113:               #if defined( __dsPIC30F__ ) || defined( __dsPIC33F__ )
114:               
115:               	#define portRESTORE_CONTEXT()																						\
116:               		asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */				\
117:               						"MOV	[W0], W15				\n"																\
118:               						"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
119:               						"MOV	W0, _uxCriticalNesting	\n"																\
120:               						"POP	PSVPAG					\n"																\
121:               						"POP	CORCON					\n"																\
122:               						"POP	DOENDH					\n"																\
123:               						"POP	DOENDL					\n"																\
124:               						"POP	DOSTARTH				\n"																\
125:               						"POP	DOSTARTL				\n"																\
126:               						"POP	DCOUNT					\n"																\
127:               						"POP	ACCBU					\n"																\
128:               						"POP	ACCBH					\n"																\
129:               						"POP	ACCBL					\n"																\
130:               						"POP	ACCAU					\n"																\
131:               						"POP	ACCAH					\n"																\
132:               						"POP	ACCAL					\n"																\
133:               						"POP	TBLPAG					\n"																\
134:               						"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
135:               						"POP	W14						\n"																\
136:               						"POP.D	W12						\n"																\
137:               						"POP.D	W10						\n"																\
138:               						"POP.D	W8						\n"																\
139:               						"POP.D	W6						\n"																\
140:               						"POP.D	W4						\n"																\
141:               						"POP.D	W2						\n"																\
142:               						"POP.D	W0						\n"																\
143:               						"POP	SR						  " );
144:               
145:               #endif /* MPLAB_DSPIC_PORT */
146:               
147:               #ifndef portRESTORE_CONTEXT
148:               	#error Unrecognised device selected
149:               
150:               	/* Note:  dsPIC parts with EDS are not supported as there is no easy way to
151:               	recover the hardware stacked copies for DOCOUNT, DOHIGH, DOLOW. */
152:               #endif
153:               
154:               /*
155:                * Setup the timer used to generate the tick interrupt.
156:                */
157:               void vApplicationSetupTickTimerInterrupt( void );
158:               
159:               /*
160:                * See header file for description.
161:                */
162:               StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
002588  B00280     ADD #0x28, W0
163:               {
00256C  FA0020     LNK #0x20
164:               uint16_t usCode;
165:               UBaseType_t i;
166:               
167:               const StackType_t xInitialStack[] =
00256E  2FFE03     MOV #0xFFE0, W3
002570  478183     ADD W15, W3, W3
002572  288184     MOV #0x8818, W4
002574  09000F     REPEAT #0xF
002576  7819B4     MOV [W4++], [W3++]
168:               {
169:               	0x1111,	/* W1 */
170:               	0x2222, /* W2 */
171:               	0x3333, /* W3 */
172:               	0x4444, /* W4 */
173:               	0x5555, /* W5 */
174:               	0x6666, /* W6 */
175:               	0x7777, /* W7 */
176:               	0x8888, /* W8 */
177:               	0x9999, /* W9 */
178:               	0xaaaa, /* W10 */
179:               	0xbbbb, /* W11 */
180:               	0xcccc, /* W12 */
181:               	0xdddd, /* W13 */
182:               	0xeeee, /* W14 */
183:               	0xcdce, /* RCOUNT */
184:               	0xabac, /* TBLPAG */
185:               
186:               	/* dsPIC specific registers. */
187:               	#ifdef MPLAB_DSPIC_PORT
188:               		0x0202, /* ACCAL */
189:               		0x0303, /* ACCAH */
190:               		0x0404, /* ACCAU */
191:               		0x0505, /* ACCBL */
192:               		0x0606, /* ACCBH */
193:               		0x0707, /* ACCBU */
194:               		0x0808, /* DCOUNT */
195:               		0x090a, /* DOSTARTL */
196:               		0x1010, /* DOSTARTH */
197:               		0x1110, /* DOENDL */
198:               		0x1212, /* DOENDH */
199:               	#endif
200:               };
201:               
202:               	/* Setup the stack as if a yield had occurred.
203:               
204:               	Save the low bytes of the program counter. */
205:               	usCode = ( uint16_t ) pxCode;
206:               	*pxTopOfStack = ( StackType_t ) usCode;
002578  780180     MOV W0, W3
00257A  781981     MOV W1, [W3++]
207:               	pxTopOfStack++;
208:               
209:               	/* Save the high byte of the program counter.  This will always be zero
210:               	here as it is passed in a 16bit pointer.  If the address is greater than
211:               	16 bits then the pointer will point to a jump table. */
212:               	*pxTopOfStack = ( StackType_t ) 0;
00257C  EB0080     CLR W1
00257E  781981     MOV W1, [W3++]
213:               	pxTopOfStack++;
214:               
215:               	/* Status register with interrupts enabled. */
216:               	*pxTopOfStack = portINITIAL_SR;
002580  781981     MOV W1, [W3++]
217:               	pxTopOfStack++;
218:               
219:               	/* Parameters are passed in W0. */
220:               	*pxTopOfStack = ( StackType_t ) pvParameters;
002582  781982     MOV W2, [W3++]
221:               	pxTopOfStack++;
002584  2FFDE2     MOV #0xFFDE, W2
002586  41010F     ADD W2, W15, W2
00258A  780083     MOV W3, W1
222:               
223:               	for( i = 0; i < ( sizeof( xInitialStack ) / sizeof( StackType_t ) ); i++ )
00258E  508F80     SUB W1, W0, [W15]
002590  3AFFFD     BRA NZ, .L2
224:               	{
225:               		*pxTopOfStack = xInitialStack[ i ];
00258C  7818D2     MOV [++W2], [W1++]
226:               		pxTopOfStack++;
227:               	}
228:               
229:               	*pxTopOfStack = CORCON;
002592  200200     MOV #0x20, W0
002594  400003     ADD W0, W3, W0
002596  800221     MOV CORCON, W1
002598  781801     MOV W1, [W0++]
230:               	pxTopOfStack++;
231:               
232:               	#if defined(__HAS_EDS__)
233:               		*pxTopOfStack = DSRPAG;
00259A  800193     MOV DSRPAG, W3
00259C  781803     MOV W3, [W0++]
234:               		pxTopOfStack++;
235:               		*pxTopOfStack = DSWPAG;
00259E  8001A4     MOV DSWPAG, W4
0025A0  781804     MOV W4, [W0++]
236:               		pxTopOfStack++;
237:               	#else /* __HAS_EDS__ */
238:               		*pxTopOfStack = PSVPAG;
239:               		pxTopOfStack++;
240:               	#endif /* __HAS_EDS__ */
241:               
242:               	/* Finally the critical nesting depth. */
243:               	*pxTopOfStack = 0x00;
0025A2  EB1800     CLR [W0++]
244:               	pxTopOfStack++;
245:               
246:               	return pxTopOfStack;
247:               }
0025A4  FA8000     ULNK
0025A6  060000     RETURN
248:               /*-----------------------------------------------------------*/
249:               
250:               BaseType_t xPortStartScheduler( void )
251:               {
252:               	/* Setup a timer for the tick ISR. */
253:               	vApplicationSetupTickTimerInterrupt();
0025C6  0225AA     CALL vApplicationSetupTickTimerInterrupt
0025C8  000000     NOP
254:               
255:               	/* Restore the context of the first task to run. */
256:               	portRESTORE_CONTEXT();
0025CA  804280     MOV pxCurrentTCB, W0
0025CC  780790     MOV [W0], W15
0025CE  78004F     MOV [--W15], W0
0025D0  884140     MOV W0, 0x828
0025D2  F90034     POP DSWPAG
0025D4  F90032     POP DSRPAG
0025D6  F90044     POP CORCON
0025D8  F90054     POP TBLPAG
0025DA  F90036     POP RCOUNT
0025DC  78074F     MOV [--W15], W14
0025DE  BE064F     MOV.D [--W15], W12
0025E0  BE054F     MOV.D [--W15], W10
0025E2  BE044F     MOV.D [--W15], W8
0025E4  BE034F     MOV.D [--W15], W6
0025E6  BE024F     MOV.D [--W15], W4
0025E8  BE014F     MOV.D [--W15], W2
0025EA  BE004F     MOV.D [--W15], W0
0025EC  F90042     POP SR
257:               
258:               	/* Simulate the end of the yield function. */
259:               	asm volatile ( "return" );
0025EE  060000     RETURN
260:               
261:               	/* Should not reach here. */
262:               	return pdTRUE;
263:               }
0025F0  200010     MOV #0x1, W0
0025F2  060000     RETURN
264:               /*-----------------------------------------------------------*/
265:               
266:               void vPortEndScheduler( void )
267:               {
268:               	/* Not implemented in ports where there is nothing to return to.
269:               	Artificially force an assert. */
270:               	configASSERT( uxCriticalNesting == 1000UL );
271:               }
0025A8  060000     RETURN
272:               /*-----------------------------------------------------------*/
273:               
274:               /*
275:                * Setup a timer for a regular tick.
276:                */
277:               __attribute__(( weak )) void vApplicationSetupTickTimerInterrupt( void )
278:               {
279:               const uint32_t ulCompareMatch = ( ( configCPU_CLOCK_HZ / portTIMER_PRESCALE ) / configTICK_RATE_HZ ) - 1;
280:               
281:               	/* Prescale of 8. */
282:               	T1CON = 0;
0025AA  EF2104     CLR T1CON
283:               	TMR1 = 0;
0025AC  EF2100     CLR TMR1
284:               
285:               	PR1 = ( uint16_t ) ulCompareMatch;
0025AE  207CF0     MOV #0x7CF, W0
0025B0  880810     MOV W0, PR1
286:               
287:               	/* Setup timer 1 interrupt priority. */
288:               	IPC0bits.T1IP = configKERNEL_INTERRUPT_PRIORITY;
0025B2  28FFF0     MOV #0x8FFF, W0
0025B4  B600A4     AND IPC0, WREG
0025B6  A0C000     BSET W0, #12
0025B8  880520     MOV W0, IPC0
289:               
290:               	/* Clear the interrupt as a starting condition. */
291:               	IFS0bits.T1IF = 0;
0025BA  A96084     BCLR IFS0, #3
292:               
293:               	/* Enable the interrupt. */
294:               	IEC0bits.T1IE = 1;
0025BC  A86094     BSET IEC0, #3
295:               
296:               	/* Setup the prescale value. */
297:               	T1CONbits.TCKPS0 = 1;
0025BE  A88104     BSET T1CON, #4
298:               	T1CONbits.TCKPS1 = 0;
0025C0  A9A104     BCLR T1CON, #5
299:               
300:               	/* Start the timer. */
301:               	T1CONbits.TON = 1;
0025C2  A8E105     BSET 0x105, #7
302:               }
0025C4  060000     RETURN
303:               /*-----------------------------------------------------------*/
304:               
305:               void vPortEnterCritical( void )
306:               {
307:               	portDISABLE_INTERRUPTS();
0025F4  2FF1F0     MOV #0xFF1F, W0
0025F6  B60042     AND SR, WREG
0025F8  A05000     BSET W0, #5
0025FA  880210     MOV W0, SR
0025FC  000000     NOP
0025FE  000000     NOP
308:               	uxCriticalNesting++;
002600  EC2828     INC 0x828
309:               }
002602  060000     RETURN
310:               /*-----------------------------------------------------------*/
311:               
312:               void vPortExitCritical( void )
313:               {
314:               	configASSERT( uxCriticalNesting );
315:               	uxCriticalNesting--;
002604  ED0828     DEC 0x828, WREG
002606  884140     MOV W0, 0x828
316:               	if( uxCriticalNesting == 0 )
002608  3A0003     BRA NZ, .L8
317:               	{
318:               		portENABLE_INTERRUPTS();
00260A  2FF1F0     MOV #0xFF1F, W0
00260C  B62042     AND SR
00260E  000000     NOP
319:               	}
320:               }
002610  060000     RETURN
321:               /*-----------------------------------------------------------*/
322:               
323:               void __attribute__((__interrupt__, auto_psv)) configTICK_INTERRUPT_HANDLER( void )
324:               {
000330  F80036     PUSH RCOUNT
000332  BE9F80     MOV.D W0, [W15++]
000334  BE9F82     MOV.D W2, [W15++]
000336  BE9F84     MOV.D W4, [W15++]
000338  BE9F86     MOV.D W6, [W15++]
00033A  F80032     PUSH DSRPAG
00033C  F80034     PUSH DSWPAG
00033E  200010     MOV #0x1, W0
000340  8801A0     MOV W0, DSWPAG
000342  202000     MOV #0x200, W0
000344  880190     MOV W0, DSRPAG
325:               	/* Clear the timer interrupt. */
326:               	IFS0bits.T1IF = 0;
000346  A96084     BCLR IFS0, #3
327:               
328:               	if( xTaskIncrementTick() != pdFALSE )
000348  020DA8     CALL xTaskIncrementTick
00034A  000000     NOP
00034C  E00000     CP0 W0
00034E  320003     BRA Z, .L10
329:               	{
330:               		portYIELD();
000350  02286C     CALL .Letext0, .LFE2, _vPortYield
000352  000000     NOP
000354  000000     NOP
331:               	}
332:               }
000356  F90034     POP DSWPAG
000358  F90032     POP DSRPAG
00035A  BE034F     MOV.D [--W15], W6
00035C  BE024F     MOV.D [--W15], W4
00035E  BE014F     MOV.D [--W15], W2
000360  BE004F     MOV.D [--W15], W0
000362  F90036     POP RCOUNT
000364  064000     RETFIE
333:               
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Source/list.c  ------------------------------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                
29:                #include <stdlib.h>
30:                #include "FreeRTOS.h"
31:                #include "list.h"
32:                
33:                /*-----------------------------------------------------------
34:                 * PUBLIC LIST API documented in list.h
35:                 *----------------------------------------------------------*/
36:                
37:                void vListInitialise( List_t * const pxList )
38:                {
39:                	/* The list structure contains a list item which is used to mark the
40:                	end of the list.  To initialise the list the list end is inserted
41:                	as the only list entry. */
42:                	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
002738  4000E4     ADD W0, #0x4, W1
00273A  980011     MOV W1, [W0+2]
43:                
44:                	/* The list end value is the highest possible value in the list to
45:                	ensure it remains at the end of the list. */
46:                	pxList->xListEnd.xItemValue = portMAX_DELAY;
00273C  EB8100     SETM W2
00273E  980022     MOV W2, [W0+4]
47:                
48:                	/* The list end next and previous pointers point to itself so we know
49:                	when the list is empty. */
50:                	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
002740  980031     MOV W1, [W0+6]
51:                	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
002742  980041     MOV W1, [W0+8]
52:                
53:                	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
002744  EB0800     CLR [W0]
54:                
55:                	/* Write known values into the list if
56:                	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
57:                	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
58:                	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
59:                }
002746  060000     RETURN
60:                /*-----------------------------------------------------------*/
61:                
62:                void vListInitialiseItem( ListItem_t * const pxItem )
63:                {
64:                	/* Make sure the list item is not recorded as being on a list. */
65:                	pxItem->pxContainer = NULL;
002748  EB0080     CLR W1
00274A  980041     MOV W1, [W0+8]
66:                
67:                	/* Write known values into the list item if
68:                	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
69:                	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
70:                	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
71:                }
00274C  060000     RETURN
72:                /*-----------------------------------------------------------*/
73:                
74:                void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
75:                {
76:                ListItem_t * const pxIndex = pxList->pxIndex;
00274E  900110     MOV [W0+2], W2
77:                
78:                	/* Only effective when configASSERT() is also defined, these tests may catch
79:                	the list data structures being overwritten in memory.  They will not catch
80:                	data errors caused by incorrect configuration or use of FreeRTOS. */
81:                	listTEST_LIST_INTEGRITY( pxList );
82:                	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
83:                
84:                	/* Insert a new list item into pxList, but rather than sort the list,
85:                	makes the new list item the last item to be removed by a call to
86:                	listGET_OWNER_OF_NEXT_ENTRY(). */
87:                	pxNewListItem->pxNext = pxIndex;
002750  980092     MOV W2, [W1+2]
88:                	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
002752  9001A2     MOV [W2+4], W3
002754  9800A3     MOV W3, [W1+4]
89:                
90:                	/* Only used during decision coverage testing. */
91:                	mtCOVERAGE_TEST_DELAY();
92:                
93:                	pxIndex->pxPrevious->pxNext = pxNewListItem;
002756  9001A2     MOV [W2+4], W3
002758  980191     MOV W1, [W3+2]
94:                	pxIndex->pxPrevious = pxNewListItem;
00275A  980121     MOV W1, [W2+4]
95:                
96:                	/* Remember which list the item is in. */
97:                	pxNewListItem->pxContainer = pxList;
00275C  9800C0     MOV W0, [W1+8]
98:                
99:                	( pxList->uxNumberOfItems )++;
00275E  E80810     INC [W0], [W0]
100:               }
002760  060000     RETURN
101:               /*-----------------------------------------------------------*/
102:               
103:               void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
104:               {
105:               ListItem_t *pxIterator;
106:               const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
002762  780211     MOV [W1], W4
107:               
108:               	/* Only effective when configASSERT() is also defined, these tests may catch
109:               	the list data structures being overwritten in memory.  They will not catch
110:               	data errors caused by incorrect configuration or use of FreeRTOS. */
111:               	listTEST_LIST_INTEGRITY( pxList );
112:               	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
113:               
114:               	/* Insert the new list item into the list, sorted in xItemValue order.
115:               
116:               	If the list already contains a list item with the same item value then the
117:               	new list item should be placed after it.  This ensures that TCBs which are
118:               	stored in ready lists (all of which have the same xItemValue value) get a
119:               	share of the CPU.  However, if the xItemValue is the same as the back marker
120:               	the iteration loop below will not end.  Therefore the value is checked
121:               	first, and the algorithm slightly modified if necessary. */
122:               	if( xValueOfInsertion == portMAX_DELAY )
002764  420FE1     ADD W4, #0x1, [W15]
002766  3A0002     BRA NZ, .L5
123:               	{
124:               		pxIterator = pxList->xListEnd.pxPrevious;
002768  9001C0     MOV [W0+8], W3
00276A  370006     BRA .L6
125:               	}
126:               	else
127:               	{
128:               		/* *** NOTE ***********************************************************
129:               		If you find your application is crashing here then likely causes are
130:               		listed below.  In addition see https://www.freertos.org/FAQHelp.html for
131:               		more tips, and ensure configASSERT() is defined!
132:               		https://www.freertos.org/a00110.html#configASSERT
133:               
134:               			1) Stack overflow -
135:               			   see https://www.freertos.org/Stacks-and-stack-overflow-checking.html
136:               			2) Incorrect interrupt priority assignment, especially on Cortex-M
137:               			   parts where numerically high priority values denote low actual
138:               			   interrupt priorities, which can seem counter intuitive.  See
139:               			   https://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
140:               			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
141:               			   https://www.freertos.org/a00110.html
142:               			3) Calling an API function from within a critical section or when
143:               			   the scheduler is suspended, or calling an API function that does
144:               			   not end in "FromISR" from an interrupt.
145:               			4) Using a queue or semaphore before it has been initialised or
146:               			   before the scheduler has been started (are interrupts firing
147:               			   before vTaskStartScheduler() has been called?).
148:               		**********************************************************************/
149:               
150:               		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
00276C  4001E4     ADD W0, #0x4, W3
00276E  370001     BRA .L7
002770  780182     MOV W2, W3
002772  900113     MOV [W3+2], W2
002774  520F92     SUB W4, [W2], [W15]
002776  31FFFC     BRA C, .L8
151:               		{
152:               			/* There is nothing to do here, just iterating to the wanted
153:               			insertion position. */
154:               		}
155:               	}
156:               
157:               	pxNewListItem->pxNext = pxIterator->pxNext;
002778  900113     MOV [W3+2], W2
00277A  980092     MOV W2, [W1+2]
158:               	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
00277C  980121     MOV W1, [W2+4]
159:               	pxNewListItem->pxPrevious = pxIterator;
00277E  9800A3     MOV W3, [W1+4]
160:               	pxIterator->pxNext = pxNewListItem;
002780  980191     MOV W1, [W3+2]
161:               
162:               	/* Remember which list the item is in.  This allows fast removal of the
163:               	item later. */
164:               	pxNewListItem->pxContainer = pxList;
002782  9800C0     MOV W0, [W1+8]
165:               
166:               	( pxList->uxNumberOfItems )++;
002784  E80810     INC [W0], [W0]
167:               }
002786  060000     RETURN
168:               /*-----------------------------------------------------------*/
169:               
170:               UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
171:               {
172:               /* The list item knows which list it is in.  Obtain the list from the list
173:               item. */
174:               List_t * const pxList = pxItemToRemove->pxContainer;
002788  9000C0     MOV [W0+8], W1
175:               
176:               	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
00278A  900110     MOV [W0+2], W2
00278C  9001A0     MOV [W0+4], W3
00278E  980123     MOV W3, [W2+4]
177:               	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
002790  900120     MOV [W0+4], W2
002792  900190     MOV [W0+2], W3
002794  980113     MOV W3, [W2+2]
178:               
179:               	/* Only used during decision coverage testing. */
180:               	mtCOVERAGE_TEST_DELAY();
181:               
182:               	/* Make sure the index is left pointing to a valid item. */
183:               	if( pxList->pxIndex == pxItemToRemove )
002796  900111     MOV [W1+2], W2
002798  510F80     SUB W2, W0, [W15]
00279A  3A0002     BRA NZ, .L10
184:               	{
185:               		pxList->pxIndex = pxItemToRemove->pxPrevious;
00279C  900122     MOV [W2+4], W2
00279E  980092     MOV W2, [W1+2]
186:               	}
187:               	else
188:               	{
189:               		mtCOVERAGE_TEST_MARKER();
190:               	}
191:               
192:               	pxItemToRemove->pxContainer = NULL;
0027A0  EB0100     CLR W2
0027A2  980042     MOV W2, [W0+8]
193:               	( pxList->uxNumberOfItems )--;
0027A4  E90891     DEC [W1], [W1]
194:               
195:               	return pxList->uxNumberOfItems;
0027A6  780011     MOV [W1], W0
196:               }
0027A8  060000     RETURN
197:               /*-----------------------------------------------------------*/
198:               
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Source/croutine.c  --------------------------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                #include "FreeRTOS.h"
29:                #include "task.h"
30:                #include "croutine.h"
31:                
32:                /* Remove the whole file is co-routines are not being used. */
33:                #if( configUSE_CO_ROUTINES != 0 )
34:                
35:                /*
36:                 * Some kernel aware debuggers require data to be viewed to be global, rather
37:                 * than file scope.
38:                 */
39:                #ifdef portREMOVE_STATIC_QUALIFIER
40:                	#define static
41:                #endif
42:                
43:                
44:                /* Lists for ready and blocked co-routines. --------------------*/
45:                static List_t pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ];	/*< Prioritised ready co-routines. */
46:                static List_t xDelayedCoRoutineList1;									/*< Delayed co-routines. */
47:                static List_t xDelayedCoRoutineList2;									/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. */
48:                static List_t * pxDelayedCoRoutineList;									/*< Points to the delayed co-routine list currently being used. */
49:                static List_t * pxOverflowDelayedCoRoutineList;							/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. */
50:                static List_t xPendingReadyCoRoutineList;								/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. */
51:                
52:                /* Other file private variables. --------------------------------*/
53:                CRCB_t * pxCurrentCoRoutine = NULL;
54:                static UBaseType_t uxTopCoRoutineReadyPriority = 0;
55:                static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;
56:                
57:                /* The initial state of the co-routine when it is created. */
58:                #define corINITIAL_STATE	( 0 )
59:                
60:                /*
61:                 * Place the co-routine represented by pxCRCB into the appropriate ready queue
62:                 * for the priority.  It is inserted at the end of the list.
63:                 *
64:                 * This macro accesses the co-routine ready lists and therefore must not be
65:                 * used from within an ISR.
66:                 */
67:                #define prvAddCoRoutineToReadyQueue( pxCRCB )																		\
68:                {																													\
69:                	if( pxCRCB->uxPriority > uxTopCoRoutineReadyPriority )															\
70:                	{																												\
71:                		uxTopCoRoutineReadyPriority = pxCRCB->uxPriority;															\
72:                	}																												\
73:                	vListInsertEnd( ( List_t * ) &( pxReadyCoRoutineLists[ pxCRCB->uxPriority ] ), &( pxCRCB->xGenericListItem ) );	\
74:                }
75:                
76:                /*
77:                 * Utility to ready all the lists used by the scheduler.  This is called
78:                 * automatically upon the creation of the first co-routine.
79:                 */
80:                static void prvInitialiseCoRoutineLists( void );
81:                
82:                /*
83:                 * Co-routines that are readied by an interrupt cannot be placed directly into
84:                 * the ready lists (there is no mutual exclusion).  Instead they are placed in
85:                 * in the pending ready list in order that they can later be moved to the ready
86:                 * list by the co-routine scheduler.
87:                 */
88:                static void prvCheckPendingReadyList( void );
89:                
90:                /*
91:                 * Macro that looks at the list of co-routines that are currently delayed to
92:                 * see if any require waking.
93:                 *
94:                 * Co-routines are stored in the queue in the order of their wake time -
95:                 * meaning once one co-routine has been found whose timer has not expired
96:                 * we need not look any further down the list.
97:                 */
98:                static void prvCheckDelayedList( void );
99:                
100:               /*-----------------------------------------------------------*/
101:               
102:               BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
103:               {
002070  BE9F88     MOV.D W8, [W15++]
002072  BE9F8A     MOV.D W10, [W15++]
002074  780580     MOV W0, W11
002076  780501     MOV W1, W10
002078  780482     MOV W2, W9
104:               BaseType_t xReturn;
105:               CRCB_t *pxCoRoutine;
106:               
107:               	/* Allocate the memory that will store the co-routine control block. */
108:               	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
00207A  2001C0     MOV #0x1C, W0
00207C  0228C0     CALL pvPortMalloc
00207E  000000     NOP
002080  780400     MOV W0, W8
109:               	if( pxCoRoutine )
002084  E00008     CP0 W8
002086  320022     BRA Z, .L36
110:               	{
111:               		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
112:               		be created and the co-routine data structures need initialising. */
113:               		if( pxCurrentCoRoutine == NULL )
002088  E2087E     CP0 pxCurrentCoRoutine
00208A  3A0002     BRA NZ, .L37
114:               		{
115:               			pxCurrentCoRoutine = pxCoRoutine;
116:               			prvInitialiseCoRoutineLists();
00208C  8843F8     MOV W8, pxCurrentCoRoutine
00208E  07FFDC     RCALL prvInitialiseCoRoutineLists
002090  E0000A     CP0 W10
002092  320001     BRA Z, .L38
002094  20001A     MOV #0x1, W10
117:               		}
118:               
119:               		/* Check the priority is within limits. */
120:               		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
121:               		{
122:               			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
123:               		}
124:               
125:               		/* Fill out the co-routine control block from the function parameters. */
126:               		pxCoRoutine->uxState = corINITIAL_STATE;
002096  EB0000     CLR W0
002098  980C50     MOV W0, [W8+26]
127:               		pxCoRoutine->uxPriority = uxPriority;
00209A  980C3A     MOV W10, [W8+22]
128:               		pxCoRoutine->uxIndex = uxIndex;
00209C  980C49     MOV W9, [W8+24]
129:               		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
00209E  780488     MOV W8, W9
0020A0  781C8B     MOV W11, [W9++]
130:               
131:               		/* Initialise all the other co-routine control block parameters. */
132:               		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
0020A2  780009     MOV W9, W0
0020A4  022748     CALL vListInitialiseItem
0020A6  000000     NOP
133:               		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
0020A8  44006C     ADD W8, #0xC, W0
0020AA  022748     CALL vListInitialiseItem
0020AC  000000     NOP
134:               
135:               		/* Set the co-routine control block as a link back from the ListItem_t.
136:               		This is so we can get back to the containing CRCB from a generic item
137:               		in a list. */
138:               		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
0020AE  980448     MOV W8, [W8+8]
139:               		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
0020B0  980C18     MOV W8, [W8+18]
140:               
141:               		/* Event lists are always in priority order. */
142:               		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
0020B2  150562     SUBR W10, #0x2, W10
0020B4  98046A     MOV W10, [W8+12]
143:               
144:               		/* Now the co-routine has been initialised it can be added to the ready
145:               		list at the correct priority. */
146:               		prvAddCoRoutineToReadyQueue( pxCoRoutine );
0020B6  900838     MOV [W8+22], W0
0020B8  E30880     CP uxTopCoRoutineReadyPriority
0020BA  310001     BRA C, .L39
0020BC  884400     MOV W0, uxTopCoRoutineReadyPriority
0020BE  B9006A     MUL.SU W0, #10, W0
0020C0  21D062     MOV #0x1D06, W2
0020C2  410000     ADD W2, W0, W0
0020C4  780089     MOV W9, W1
0020C6  02274E     CALL vListInsertEnd
0020C8  000000     NOP
147:               
148:               		xReturn = pdPASS;
0020CA  200010     MOV #0x1, W0
149:               	}
150:               	else
151:               	{
152:               		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
002082  EB8000     SETM W0
153:               	}
154:               
155:               	return xReturn;
156:               }
0020CC  BE054F     MOV.D [--W15], W10
0020CE  BE044F     MOV.D [--W15], W8
0020D0  060000     RETURN
157:               /*-----------------------------------------------------------*/
158:               
159:               void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
160:               {
001ECC  BE9F88     MOV.D W8, [W15++]
001ECE  780401     MOV W1, W8
161:               TickType_t xTimeToWake;
162:               
163:               	/* Calculate the time to wake - this may overflow but this is
164:               	not a problem. */
165:               	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
001ED0  804419     MOV xCoRoutineTickCount, W9
001ED2  400489     ADD W0, W9, W9
166:               
167:               	/* We must remove ourselves from the ready list before adding
168:               	ourselves to the blocked list as the same list item is used for
169:               	both lists. */
170:               	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
001ED4  EC887E     INC2 pxCurrentCoRoutine, WREG
001ED6  022788     CALL uxListRemove
001ED8  000000     NOP
171:               
172:               	/* The list item will be inserted in wake time order. */
173:               	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
001EDA  8043F1     MOV pxCurrentCoRoutine, W1
001EDC  980099     MOV W9, [W1+2]
174:               
175:               	if( xTimeToWake < xCoRoutineTickCount )
001EDE  804410     MOV xCoRoutineTickCount, W0
001EE0  500F89     SUB W0, W9, [W15]
001EE2  360005     BRA LEU, .L2
176:               	{
177:               		/* Wake time has overflowed.  Place this item in the
178:               		overflow list. */
179:               		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
001EE4  E88081     INC2 W1, W1
001EE6  804450     MOV pxOverflowDelayedCoRoutineList, W0
001EE8  022762     CALL vListInsert
001EEA  000000     NOP
001EEC  370004     BRA .L3
180:               	}
181:               	else
182:               	{
183:               		/* The wake time has not overflowed, so we can use the
184:               		current block list. */
185:               		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
001EEE  E88081     INC2 W1, W1
001EF0  804440     MOV pxDelayedCoRoutineList, W0
001EF2  022762     CALL vListInsert
001EF4  000000     NOP
186:               	}
187:               
188:               	if( pxEventList )
001EF6  E00008     CP0 W8
001EF8  320005     BRA Z, .L1
189:               	{
190:               		/* Also add the co-routine to an event list.  If this is done then the
191:               		function must be called with interrupts disabled. */
192:               		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
001EFA  8043F1     MOV pxCurrentCoRoutine, W1
001EFC  4080EC     ADD W1, #0xC, W1
001EFE  780008     MOV W8, W0
001F00  022762     CALL vListInsert
001F02  000000     NOP
193:               	}
194:               }
001F04  BE044F     MOV.D [--W15], W8
001F06  060000     RETURN
195:               /*-----------------------------------------------------------*/
196:               
197:               static void prvCheckPendingReadyList( void )
198:               {
001F08  BE9F88     MOV.D W8, [W15++]
001F0A  BE9F8A     MOV.D W10, [W15++]
199:               	/* Are there any co-routines waiting to get moved to the ready list?  These
200:               	are co-routines that have been readied by an ISR.  The ISR cannot access
201:               	the	ready lists itself. */
202:               	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
001F0C  80E970     MOV xPendingReadyCoRoutineList, W0
001F0E  E00000     CP0 W0
001F10  320020     BRA Z, .L5
001F14  21D2EB     MOV #0x1D2E, W11
001F4E  E0001B     CP0 [W11]
001F50  3AFFE2     BRA NZ, .L9
203:               	{
204:               		CRCB_t *pxUnblockedCRCB;
205:               
206:               		/* The pending ready list can be accessed by an ISR. */
207:               		portDISABLE_INTERRUPTS();
001F16  2FF1F9     MOV #0xFF1F, W9
001F18  800211     MOV SR, W1
001F1A  648001     AND W9, W1, W0
001F1C  A05000     BSET W0, #5
001F1E  880210     MOV W0, SR
001F20  000000     NOP
001F22  000000     NOP
208:               		{
209:               			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
001F24  80E9A0     MOV .L49, W0
001F26  900430     MOV [W0+6], W8
210:               			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
001F28  44006C     ADD W8, #0xC, W0
001F2A  022788     CALL uxListRemove
001F2C  000000     NOP
211:               		}
212:               		portENABLE_INTERRUPTS();
001F2E  200420     MOV #0x42, W0
001F30  648810     AND W9, [W0], [W0]
001F32  000000     NOP
213:               
214:               		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
001F34  E88488     INC2 W8, W9
001F36  780009     MOV W9, W0
001F38  022788     CALL uxListRemove
001F3A  000000     NOP
215:               		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
001F12  21D06A     MOV #0x1D06, W10
001F3C  900838     MOV [W8+22], W0
001F3E  E30880     CP uxTopCoRoutineReadyPriority
001F40  310001     BRA C, .L7
001F42  884400     MOV W0, uxTopCoRoutineReadyPriority
001F44  B9006A     MUL.SU W0, #10, W0
001F46  450000     ADD W10, W0, W0
001F48  780089     MOV W9, W1
001F4A  02274E     CALL vListInsertEnd
001F4C  000000     NOP
216:               	}
217:               }
001F52  BE054F     MOV.D [--W15], W10
001F54  BE044F     MOV.D [--W15], W8
001F56  060000     RETURN
218:               /*-----------------------------------------------------------*/
219:               
220:               static void prvCheckDelayedList( void )
221:               {
001F58  BE9F88     MOV.D W8, [W15++]
001F5A  BE9F8A     MOV.D W10, [W15++]
222:               CRCB_t *pxCRCB;
223:               
224:               	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
001F5C  020A8A     CALL xTaskGetTickCount
001F5E  000000     NOP
001F60  804421     MOV xLastTickCount, W1
001F62  500001     SUB W0, W1, W0
001F64  884430     MOV W0, xPassedTicks
225:               	while( xPassedTicks )
001F6A  370037     BRA .L22
001FDA  804431     MOV xPassedTicks, W1
001FDC  E00001     CP0 W1
001FDE  3AFFC6     BRA NZ, .L19
226:               	{
227:               		xCoRoutineTickCount++;
001F6C  EC0882     INC xCoRoutineTickCount, WREG
001F6E  884410     MOV W0, xCoRoutineTickCount
228:               		xPassedTicks--;
001F70  E90081     DEC W1, W1
001F72  884431     MOV W1, xPassedTicks
229:               
230:               		/* If the tick count has overflowed we need to swap the ready lists. */
231:               		if( xCoRoutineTickCount == 0 )
001F74  E00000     CP0 W0
001F76  3A0004     BRA NZ, .L13, .LBE4
232:               		{
233:               			List_t * pxTemp;
234:               
235:               			/* Tick count has overflowed so we need to swap the delay lists.  If there are
236:               			any items in pxDelayedCoRoutineList here then there is an error! */
237:               			pxTemp = pxDelayedCoRoutineList;
001F78  804441     MOV pxDelayedCoRoutineList, W1
238:               			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
001F7A  F8088A     PUSH pxOverflowDelayedCoRoutineList
001F7C  F90888     POP pxDelayedCoRoutineList
239:               			pxOverflowDelayedCoRoutineList = pxTemp;
001F7E  884451     MOV W1, pxOverflowDelayedCoRoutineList
240:               		}
241:               
242:               		/* See if this tick has made a timeout expire. */
243:               		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
001F80  804441     MOV pxDelayedCoRoutineList, W1
001F82  E00011     CP0 [W1]
001F84  32002A     BRA Z, .L22
001FD4  804440     MOV pxDelayedCoRoutineList, W0
001FD6  E00010     CP0 [W0]
001FD8  3AFFDC     BRA NZ, .L18
244:               		{
245:               			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
001F86  9000B1     MOV [W1+6], W1
001F88  900431     MOV [W1+6], W8
001F92  900030     MOV [W0+6], W0
001F94  900430     MOV [W0+6], W8
246:               
247:               			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
001F8A  900098     MOV [W8+2], W1
001F8C  500F81     SUB W0, W1, [W15]
001F8E  310006     BRA C, .L24
001F90  370024     BRA .L22
001F96  900018     MOV [W8+2], W0
001F98  E30882     CP xCoRoutineTickCount
001F9A  39001F     BRA NC, .L22
248:               			{
249:               				/* Timeout not yet expired. */
250:               				break;
251:               			}
252:               
253:               			portDISABLE_INTERRUPTS();
001F66  2FF1FA     MOV #0xFF1F, W10
001F9C  800211     MOV SR, W1
001F9E  650001     AND W10, W1, W0
001FA0  A05000     BSET W0, #5
001FA2  880210     MOV W0, SR
001FA4  000000     NOP
001FA6  000000     NOP
254:               			{
255:               				/* The event could have occurred just before this critical
256:               				section.  If this is the case then the generic list item will
257:               				have been moved to the pending ready list and the following
258:               				line is still valid.  Also the pvContainer parameter will have
259:               				been set to NULL so the following lines are also valid. */
260:               				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
001FA8  E88488     INC2 W8, W9
001FAA  780009     MOV W9, W0
001FAC  022788     CALL uxListRemove
001FAE  000000     NOP
261:               
262:               				/* Is the co-routine waiting on an event also? */
263:               				if( pxCRCB->xEventListItem.pxContainer )
001FB0  900828     MOV [W8+20], W0
001FB2  E00000     CP0 W0
001FB4  320003     BRA Z, .L16
264:               				{
265:               					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
001FB6  44006C     ADD W8, #0xC, W0
001FB8  022788     CALL uxListRemove
001FBA  000000     NOP
266:               				}
267:               			}
268:               			portENABLE_INTERRUPTS();
001FBC  200420     MOV #0x42, W0
001FBE  650810     AND W10, [W0], [W0]
001FC0  000000     NOP
269:               
270:               			prvAddCoRoutineToReadyQueue( pxCRCB );
001F68  21D06B     MOV #0x1D06, W11
001FC2  900838     MOV [W8+22], W0
001FC4  E30880     CP uxTopCoRoutineReadyPriority
001FC6  310001     BRA C, .L17
001FC8  884400     MOV W0, uxTopCoRoutineReadyPriority
001FCA  B9006A     MUL.SU W0, #10, W0
001FCC  458000     ADD W11, W0, W0
001FCE  780089     MOV W9, W1
001FD0  02274E     CALL vListInsertEnd
001FD2  000000     NOP
271:               		}
272:               	}
273:               
274:               	xLastTickCount = xCoRoutineTickCount;
001FE0  F80882     PUSH xCoRoutineTickCount
001FE2  F90884     POP xLastTickCount
275:               }
001FE4  BE054F     MOV.D [--W15], W10
001FE6  BE044F     MOV.D [--W15], W8
276:               /*-----------------------------------------------------------*/
277:               
278:               void vCoRoutineSchedule( void )
279:               {
280:               	/* See if any co-routines readied by events need moving to the ready lists. */
281:               	prvCheckPendingReadyList();
001FE8  060000     RETURN
282:               
283:               	/* See if any delayed co-routines have timed out. */
284:               	prvCheckDelayedList();
001FEA  07FF8E     RCALL prvCheckPendingReadyList
001FEC  07FFB5     RCALL prvCheckDelayedList
285:               
286:               	/* Find the highest priority queue that contains ready co-routines. */
287:               	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
001FEE  804400     MOV uxTopCoRoutineReadyPriority, W0
001FF0  B9016A     MUL.SU W0, #10, W2
001FF2  21D061     MOV #0x1D06, W1
001FF4  7900E1     MOV [W1+W2], W1
001FF6  E00001     CP0 W1
001FF8  3A000E     BRA NZ, .L26, .LBB5
001FFA  21D064     MOV #0x1D06, W4
00200C  B9016A     MUL.SU W0, #10, W2
00200E  7900E4     MOV [W4+W2], W1
002010  E00001     CP0 W1
002012  32FFF7     BRA Z, .L29
002014  884400     MOV W0, uxTopCoRoutineReadyPriority
288:               	{
289:               		if( uxTopCoRoutineReadyPriority == 0 )
001FFC  E00000     CP0 W0
001FFE  3A0005     BRA NZ, .L31
002000  370022     BRA .L25
002002  E00000     CP0 W0
002004  3A0002     BRA NZ, .L31
002006  884400     MOV W0, uxTopCoRoutineReadyPriority
002008  37001E     BRA .L25
290:               		{
291:               			/* No more co-routines to check. */
292:               			return;
293:               		}
294:               		--uxTopCoRoutineReadyPriority;
00200A  E90000     DEC W0, W0
295:               	}
296:               
297:               	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
298:               	 of the	same priority get an equal share of the processor time. */
299:               	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
002016  B9016A     MUL.SU W0, #10, W2
002018  E88182     INC2 W2, W3
00201A  21D061     MOV #0x1D06, W1
00201C  7981E1     MOV [W1+W3], W3
00201E  900193     MOV [W3+2], W3
002020  408202     ADD W1, W2, W4
002022  980213     MOV W3, [W4+2]
002024  410164     ADD W2, #0x4, W2
002026  410081     ADD W2, W1, W1
002028  518F81     SUB W3, W1, [W15]
00202A  3A0004     BRA NZ, .L30
00202C  B9026A     MUL.SU W0, #10, W4
00202E  21D081     MOV #0x1D08, W1
002030  900193     MOV [W3+2], W3
002032  7A3083     MOV W3, [W1+W4]
002034  B9006A     MUL.SU W0, #10, W0
002036  E88000     INC2 W0, W0
002038  21D061     MOV #0x1D06, W1
00203A  780061     MOV [W1+W0], W0
00203C  900030     MOV [W0+6], W0
00203E  8843F0     MOV W0, pxCurrentCoRoutine
300:               
301:               	/* Call the co-routine. */
302:               	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
002040  9008C0     MOV [W0+24], W1
002042  780110     MOV [W0], W2
002044  010002     CALL W2
303:               
304:               	return;
305:               }
002046  060000     RETURN
306:               /*-----------------------------------------------------------*/
307:               
308:               static void prvInitialiseCoRoutineLists( void )
309:               {
310:               UBaseType_t uxPriority;
311:               
312:               	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
313:               	{
314:               		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
002048  21D060     MOV #0x1D06, W0
00204A  022738     CALL vListInitialise
00204C  000000     NOP
00204E  21D100     MOV #0x1D10, W0
002050  022738     CALL vListInitialise
002052  000000     NOP
315:               	}
316:               
317:               	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
002054  21D1A0     MOV #0x1D1A, W0
002056  022738     CALL vListInitialise
002058  000000     NOP
318:               	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
00205A  21D240     MOV #0x1D24, W0
00205C  022738     CALL vListInitialise
00205E  000000     NOP
319:               	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
002060  21D2E0     MOV #0x1D2E, W0
002062  022738     CALL vListInitialise
002064  000000     NOP
320:               
321:               	/* Start with pxDelayedCoRoutineList using list1 and the
322:               	pxOverflowDelayedCoRoutineList using list2. */
323:               	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
002066  21D1A0     MOV #0x1D1A, W0
002068  884440     MOV W0, pxDelayedCoRoutineList
324:               	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
00206A  21D240     MOV #0x1D24, W0
00206C  884450     MOV W0, pxOverflowDelayedCoRoutineList
325:               }
00206E  060000     RETURN
326:               /*-----------------------------------------------------------*/
327:               
328:               BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
329:               {
0020D2  BE9F88     MOV.D W8, [W15++]
330:               CRCB_t *pxUnblockedCRCB;
331:               BaseType_t xReturn;
332:               
333:               	/* This function is called from within an interrupt.  It can only access
334:               	event lists and the pending ready list.  This function assumes that a
335:               	check has already been made to ensure pxEventList is not empty. */
336:               	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
0020D4  900030     MOV [W0+6], W0
0020D6  9004B0     MOV [W0+6], W9
337:               	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
0020D8  44846C     ADD W9, #0xC, W8
0020DA  780008     MOV W8, W0
0020DC  022788     CALL uxListRemove
0020DE  000000     NOP
338:               	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
0020E0  780088     MOV W8, W1
0020E2  21D2E0     MOV #0x1D2E, W0
0020E4  02274E     CALL vListInsertEnd
0020E6  000000     NOP
339:               
340:               	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
341:               	{
342:               		xReturn = pdTRUE;
0020E8  200010     MOV #0x1, W0
0020EA  900939     MOV [W9+22], W2
0020EC  8043F1     MOV pxCurrentCoRoutine, W1
0020EE  9008B1     MOV [W1+22], W1
0020F0  510F81     SUB W2, W1, [W15]
0020F2  310001     BRA C, .L42
0020F4  EB0000     CLR W0
343:               	}
344:               	else
345:               	{
346:               		xReturn = pdFALSE;
347:               	}
348:               
349:               	return xReturn;
350:               }
0020F6  BE044F     MOV.D [--W15], W8
0020F8  060000     RETURN
351:               
352:               #endif /* configUSE_CO_ROUTINES == 0 */
353:               
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Demo/PIC24_MPLAB/timertest.c  ---------------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                /* High speed timer test as described in main.c. */
29:                
30:                
31:                /* Scheduler includes. */
32:                #include "FreeRTOS.h"
33:                
34:                /* Demo includes. */
35:                #include "partest.h"
36:                
37:                /* The number of interrupts to pass before we start looking at the jitter. */
38:                #define timerSETTLE_TIME			5
39:                
40:                /* The maximum value the 16bit timer can contain. */
41:                #define timerMAX_COUNT				0xffff
42:                
43:                /*-----------------------------------------------------------*/
44:                
45:                /*
46:                 * Measure the time between this interrupt and the previous interrupt to 
47:                 * calculate the timing jitter.  Remember the maximum value the jitter has
48:                 * ever been calculated to be.
49:                 */
50:                static void prvCalculateAndStoreJitter( void );
51:                
52:                /*-----------------------------------------------------------*/
53:                
54:                /* The maximum time (in processor clocks) between two consecutive timer
55:                interrupts so far. */
56:                unsigned short usMaxJitter = 0;
57:                
58:                /*-----------------------------------------------------------*/
59:                
60:                void vSetupTimerTest( unsigned short usFrequencyHz )
61:                {
002926  780100     MOV W0, W2
62:                	/* T2 is used to generate interrupts.  T3 is used to provide an accurate
63:                	time measurement. */
64:                	T2CON = 0;
002928  EF2110     CLR T2CON
65:                	T3CON = 0;
00292A  EF2112     CLR T3CON
66:                	TMR2 = 0;
00292C  EF2106     CLR TMR2
67:                	TMR3 = 0;
00292E  EF210A     CLR TMR3
68:                
69:                	/* Timer 2 is going to interrupt at usFrequencyHz Hz. */
70:                	PR2 = ( unsigned short ) ( configCPU_CLOCK_HZ / ( unsigned long ) usFrequencyHz );
002930  EB0180     CLR W3
002932  224000     MOV #0x2400, W0
002934  200F41     MOV #0xF4, W1
002936  02071C     CALL ___udivsi3
002938  000000     NOP
00293A  880860     MOV W0, PR2
71:                
72:                	/* Timer 4 is going to free run from minimum to maximum value. */
73:                	PR3 = ( unsigned short ) timerMAX_COUNT;
00293C  EFA10E     SETM PR3
74:                
75:                	/* Setup timer 2 interrupt priority to be above the kernel priority so 
76:                	the timer jitter is not effected by the kernel activity. */
77:                	IPC1bits.T2IP = configKERNEL_INTERRUPT_PRIORITY + 1;
00293E  28FFF0     MOV #0x8FFF, W0
002940  B600A6     AND IPC1, WREG
002942  A0D000     BSET W0, #13
002944  880530     MOV W0, IPC1
78:                
79:                	/* Clear the interrupt as a starting condition. */
80:                	IFS0bits.T2IF = 0;
002946  A9E084     BCLR IFS0, #7
81:                
82:                	/* Enable the interrupt. */
83:                	IEC0bits.T2IE = 1;
002948  A8E094     BSET IEC0, #7
84:                
85:                	/* Start both timers. */
86:                	T2CONbits.TON = 1;
00294A  A8E111     BSET 0x111, #7
87:                	T3CONbits.TON = 1;
00294C  A8E113     BSET 0x113, #7
88:                }
00294E  060000     RETURN
89:                /*-----------------------------------------------------------*/
90:                
91:                static void prvCalculateAndStoreJitter( void )
92:                {
93:                static unsigned short usLastCount = 0, usSettleCount = 0;
94:                unsigned short usThisCount, usDifference;
95:                
96:                	/* Capture the timer value as we enter the interrupt. */
97:                	usThisCount = TMR3;
002908  800850     MOV TMR3, W0
98:                
99:                	if( usSettleCount >= timerSETTLE_TIME )
00290A  804471     MOV usSettleCount, W1
00290C  508FE4     SUB W1, #0x4, [W15]
00290E  360007     BRA LEU, .L2
100:               	{
101:               		/* What is the difference between the timer value in this interrupt
102:               		and the value from the last interrupt. */
103:               		usDifference = usThisCount - usLastCount;
002910  804481     MOV usLastCount, W1
002912  500081     SUB W0, W1, W1
104:               
105:               		/* Store the difference in the timer values if it is larger than the
106:               		currently stored largest value.  The difference over and above the 
107:               		expected difference will give the 'jitter' in the processing of these
108:               		interrupts. */
109:               		if( usDifference > usMaxJitter )
002914  804462     MOV usMaxJitter, W2
002916  510F81     SUB W2, W1, [W15]
002918  310004     BRA C, .L3
110:               		{
111:               			usMaxJitter = usDifference;
00291A  884461     MOV W1, usMaxJitter
00291C  370002     BRA .L3
112:               		}
113:               	}
114:               	else
115:               	{
116:               		/* Don't bother storing any values for the first couple of 
117:               		interrupts. */
118:               		usSettleCount++;
00291E  E80081     INC W1, W1
002920  884471     MOV W1, usSettleCount
119:               	}
120:               
121:               	/* Remember what the timer value was this time through, so we can calculate
122:               	the difference the next time through. */
123:               	usLastCount = usThisCount;
002922  884480     MOV W0, usLastCount
124:               }
002924  060000     RETURN
125:               /*-----------------------------------------------------------*/
126:               
127:               void __attribute__((__interrupt__, auto_psv)) _T2Interrupt( void )
128:               {
000366  F80036     PUSH RCOUNT
000368  BE9F80     MOV.D W0, [W15++]
00036A  BE9F82     MOV.D W2, [W15++]
00036C  BE9F84     MOV.D W4, [W15++]
00036E  BE9F86     MOV.D W6, [W15++]
000370  F80032     PUSH DSRPAG
000372  F80034     PUSH DSWPAG
000374  200010     MOV #0x1, W0
000376  8801A0     MOV W0, DSWPAG
000378  202000     MOV #0x200, W0
00037A  880190     MOV W0, DSRPAG
129:               	/* Work out the time between this and the previous interrupt. */
130:               	prvCalculateAndStoreJitter();
00037C  022908     CALL .Letext0, .LFE3, _prvCalculateAndStoreJitter, .Ltext0, .LFB1
00037E  000000     NOP
131:               
132:               	/* Clear the timer interrupt. */
133:               	IFS0bits.T2IF = 0;
000380  A9E084     BCLR IFS0, #7
134:               }
000382  F90034     POP DSWPAG
000384  F90032     POP DSRPAG
000386  BE034F     MOV.D [--W15], W6
000388  BE024F     MOV.D [--W15], W4
00038A  BE014F     MOV.D [--W15], W2
00038C  BE004F     MOV.D [--W15], W0
00038E  F90036     POP RCOUNT
000390  064000     RETFIE
135:               
136:               
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Demo/PIC24_MPLAB/serial/serial.c  -----------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                
29:                /* BASIC INTERRUPT DRIVEN SERIAL PORT DRIVER. 
30:                
31:                NOTE:  This driver is primarily to test the scheduler functionality.  It does
32:                not effectively use the buffers or DMA and is therefore not intended to be
33:                an example of an efficient driver. */
34:                
35:                /* Standard include file. */
36:                #include <stdlib.h>
37:                
38:                /* Scheduler include files. */
39:                #include "FreeRTOS.h"
40:                #include "queue.h"
41:                #include "task.h"
42:                
43:                /* Demo app include files. */
44:                #include "serial.h"
45:                
46:                /* Hardware setup. */
47:                #define serOUTPUT						0
48:                #define serINPUT						1
49:                #define serLOW_SPEED					0
50:                #define serONE_STOP_BIT					0
51:                #define serEIGHT_DATA_BITS_NO_PARITY	0
52:                #define serNORMAL_IDLE_STATE			0
53:                #define serAUTO_BAUD_OFF				0
54:                #define serLOOPBACK_OFF					0
55:                #define serWAKE_UP_DISABLE				0
56:                #define serNO_HARDWARE_FLOW_CONTROL		0
57:                #define serSTANDARD_IO					0
58:                #define serNO_IRDA						0
59:                #define serCONTINUE_IN_IDLE_MODE		0
60:                #define serUART_ENABLED					1
61:                #define serINTERRUPT_ON_SINGLE_CHAR		0
62:                #define serTX_ENABLE					1
63:                #define serINTERRUPT_ENABLE				1
64:                #define serINTERRUPT_DISABLE			0
65:                #define serCLEAR_FLAG					0
66:                #define serSET_FLAG						1
67:                
68:                
69:                /* The queues used to communicate between tasks and ISR's. */
70:                static QueueHandle_t xRxedChars; 
71:                static QueueHandle_t xCharsForTx; 
72:                
73:                static portBASE_TYPE xTxHasEnded;
74:                /*-----------------------------------------------------------*/
75:                
76:                xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
77:                {
002490  BE9F88     MOV.D W8, [W15++]
002492  781F8A     MOV W10, [W15++]
002494  BE0400     MOV.D W0, W8
002496  780502     MOV W2, W10
78:                char cChar;
79:                
80:                	/* Create the queues used by the com test task. */
81:                	xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
002498  EB4100     CLR.B W2
00249A  200011     MOV #0x1, W1
00249C  78000A     MOV W10, W0
00249E  021512     CALL xQueueGenericCreate
0024A0  000000     NOP
0024A2  8844E0     MOV W0, xRxedChars
82:                	xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
0024A4  EB4100     CLR.B W2
0024A6  200011     MOV #0x1, W1
0024A8  78000A     MOV W10, W0
0024AA  021512     CALL xQueueGenericCreate
0024AC  000000     NOP
0024AE  8844C0     MOV W0, xCharsForTx
83:                
84:                	/* Setup the UART. */
85:                	U2MODEbits.BRGH		= serLOW_SPEED;
0024B0  A96230     BCLR U2MODE, #3
86:                	U2MODEbits.STSEL	= serONE_STOP_BIT;
0024B2  A90230     BCLR U2MODE, #0
87:                	U2MODEbits.PDSEL	= serEIGHT_DATA_BITS_NO_PARITY;
0024B4  2FFF90     MOV #0xFFF9, W0
0024B6  B62230     AND U2MODE
88:                	U2MODEbits.RXINV	= serNORMAL_IDLE_STATE;
0024B8  A98230     BCLR U2MODE, #4
89:                	U2MODEbits.ABAUD	= serAUTO_BAUD_OFF;
0024BA  A9A230     BCLR U2MODE, #5
90:                	U2MODEbits.LPBACK	= serLOOPBACK_OFF;
0024BC  A9C230     BCLR U2MODE, #6
91:                	U2MODEbits.WAKE		= serWAKE_UP_DISABLE;
0024BE  A9E230     BCLR U2MODE, #7
92:                	U2MODEbits.UEN		= serNO_HARDWARE_FLOW_CONTROL;
0024C0  2FCFF0     MOV #0xFCFF, W0
0024C2  B62230     AND U2MODE
93:                	U2MODEbits.IREN		= serNO_IRDA;
0024C4  A98231     BCLR 0x231, #4
94:                	U2MODEbits.USIDL	= serCONTINUE_IN_IDLE_MODE;
0024C6  A9A231     BCLR 0x231, #5
95:                	U2MODEbits.UARTEN	= serUART_ENABLED;
0024C8  A8E231     BSET 0x231, #7
96:                
97:                	U2BRG = (unsigned short)(( (float)configCPU_CLOCK_HZ / ( (float)16 * (float)ulWantedBaud ) ) - (float)0.5);
0024CA  BE0008     MOV.D W8, W0
0024CC  02060A     CALL ___floatunsisf
0024CE  000000     NOP
0024D0  200002     MOV #0x0, W2
0024D2  241803     MOV #0x4180, W3
0024D4  0206B4     CALL ___mulsf3
0024D6  000000     NOP
0024D8  BE0100     MOV.D W0, W2
0024DA  224000     MOV #0x2400, W0
0024DC  24B741     MOV #0x4B74, W1
0024DE  020532     CALL ___divsf3
0024E0  000000     NOP
0024E2  200002     MOV #0x0, W2
0024E4  23F003     MOV #0x3F00, W3
0024E6  020476     CALL ___subsf3
0024E8  000000     NOP
0024EA  0205D4     CALL ___fixunssfsi
0024EC  000000     NOP
0024EE  8811C0     MOV W0, U2BRG
98:                
99:                	U2STAbits.URXISEL	= serINTERRUPT_ON_SINGLE_CHAR;
0024F0  2FF3F0     MOV #0xFF3F, W0
0024F2  B62232     AND U2STA
100:               	U2STAbits.UTXEN		= serTX_ENABLE;
0024F4  A84233     BSET 0x233, #2
101:               	U2STAbits.UTXINV	= serNORMAL_IDLE_STATE;
0024F6  A9C233     BCLR 0x233, #6
102:               	U2STAbits.UTXISEL0	= serINTERRUPT_ON_SINGLE_CHAR;
0024F8  A9A233     BCLR 0x233, #5
103:               	U2STAbits.UTXISEL1	= serINTERRUPT_ON_SINGLE_CHAR;
0024FA  A9E233     BCLR 0x233, #7
104:               
105:               	/* It is assumed that this function is called prior to the scheduler being
106:               	started.  Therefore interrupts must not be allowed to occur yet as they
107:               	may attempt to perform a context switch. */
108:               	portDISABLE_INTERRUPTS();
0024FC  2FF1F0     MOV #0xFF1F, W0
0024FE  B60042     AND SR, WREG
002500  A05000     BSET W0, #5
002502  880210     MOV W0, SR
002504  000000     NOP
002506  000000     NOP
109:               
110:               	IFS1bits.U2RXIF = serCLEAR_FLAG;
002508  A9C087     BCLR 0x87, #6
111:               	IFS1bits.U2TXIF = serCLEAR_FLAG;
00250A  A9E087     BCLR 0x87, #7
112:               	IPC7bits.U2RXIP = configKERNEL_INTERRUPT_PRIORITY;
00250C  2F8FF0     MOV #0xF8FF, W0
00250E  B600B2     AND IPC7, WREG
002510  A08000     BSET W0, #8
002512  880590     MOV W0, IPC7
113:               	IPC7bits.U2TXIP = configKERNEL_INTERRUPT_PRIORITY;
002514  28FFF0     MOV #0x8FFF, W0
002516  B600B2     AND IPC7, WREG
002518  A0C000     BSET W0, #12
00251A  880590     MOV W0, IPC7
114:               	IEC1bits.U2TXIE = serINTERRUPT_ENABLE;
00251C  A8E097     BSET 0x97, #7
115:               	IEC1bits.U2RXIE = serINTERRUPT_ENABLE;
00251E  A8C097     BSET 0x97, #6
116:               
117:               	/* Clear the Rx buffer. */
118:               	while( U2STAbits.URXDA == serSET_FLAG )
002520  AB0232     BTST U2STA, #0
002522  320003     BRA Z, .L2
002526  AB0232     BTST U2STA, #0
002528  3AFFFD     BRA NZ, .L4
119:               	{
120:               		cChar = U2RXREG;
002524  8011B0     MOV U2RXREG, W0
121:               	}
122:               
123:               	xTxHasEnded = pdTRUE;
00252A  200010     MOV #0x1, W0
00252C  8844D0     MOV W0, xTxHasEnded
124:               
125:               	return NULL;
126:               }
00252E  EB0000     CLR W0
002530  78054F     MOV [--W15], W10
002532  BE044F     MOV.D [--W15], W8
002534  060000     RETURN
127:               /*-----------------------------------------------------------*/
128:               
129:               signed portBASE_TYPE xSerialGetChar( xComPortHandle pxPort, signed char *pcRxedChar, TickType_t xBlockTime )
130:               {
131:               	/* Only one port is supported. */
132:               	( void ) pxPort;
133:               
134:               	/* Get the next character from the buffer.  Return false if no characters
135:               	are available or arrive before xBlockTime expires. */
136:               	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
002536  8044E0     MOV xRxedChars, W0
002538  0216B4     CALL xQueueReceive
00253A  000000     NOP
137:               	{
138:               		return pdTRUE;
00253C  A7F000     BTSC W0, #15
00253E  EA0000     NEG W0, W0
002540  EA0000     NEG W0, W0
002542  DE004F     LSR W0, #15, W0
139:               	}
140:               	else
141:               	{
142:               		return pdFALSE;
143:               	}
144:               }
002544  060000     RETURN
145:               /*-----------------------------------------------------------*/
146:               
147:               signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
148:               {
002546  FA0002     LNK #0x2
002548  9FFFE1     MOV.B W1, [W15-2]
149:               	/* Only one port is supported. */
150:               	( void ) pxPort;
151:               
152:               	/* Return false if after the block time there is no room on the Tx queue. */
153:               	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
00254A  EB0180     CLR W3
00254C  E9808F     DEC2 W15, W1
00254E  8044C0     MOV xCharsForTx, W0
002550  021546     CALL xQueueGenericSend
002552  000000     NOP
002554  780080     MOV W0, W1
002558  508FE1     SUB W1, #0x1, [W15]
00255A  3A0005     BRA NZ, .L8
154:               	{
155:               		return pdFAIL;
002556  EB0000     CLR W0
156:               	}
157:               
158:               	/* A critical section should not be required as xTxHasEnded will not be
159:               	written to by the ISR if it is already 0 (is this correct?). */
160:               	if( xTxHasEnded )
00255E  E2089A     CP0 xTxHasEnded
002560  320002     BRA Z, .L8
161:               	{
162:               		xTxHasEnded = pdFALSE;
002562  EF289A     CLR xTxHasEnded
163:               		IFS1bits.U2TXIF = serSET_FLAG;
002564  A8E087     BSET 0x87, #7
164:               	}
165:               
166:               	return pdPASS;
00255C  200010     MOV #0x1, W0
167:               }
002566  FA8000     ULNK
002568  060000     RETURN
168:               /*-----------------------------------------------------------*/
169:               
170:               void vSerialClose( xComPortHandle xPort )
171:               {
172:               	/* Note implemented. */
173:               	( void ) xPort;
174:               }
00256A  060000     RETURN
175:               /*-----------------------------------------------------------*/
176:               
177:               void __attribute__((__interrupt__, auto_psv)) _U2RXInterrupt( void )
178:               {
0003B4  F80036     PUSH RCOUNT
0003B6  BE9F80     MOV.D W0, [W15++]
0003B8  BE9F82     MOV.D W2, [W15++]
0003BA  BE9F84     MOV.D W4, [W15++]
0003BC  BE9F86     MOV.D W6, [W15++]
0003BE  781F88     MOV W8, [W15++]
0003C0  F80032     PUSH DSRPAG
0003C2  F80034     PUSH DSWPAG
0003C4  200010     MOV #0x1, W0
0003C6  8801A0     MOV W0, DSWPAG
0003C8  202000     MOV #0x200, W0
0003CA  880190     MOV W0, DSRPAG
0003CC  FA0004     LNK #0x4
179:               char cChar;
180:               portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
0003CE  EB0000     CLR W0
0003D0  9FBFF0     MOV W0, [W15-2]
181:               
182:               	/* Get the character and post it on the queue of Rxed characters.
183:               	If the post causes a task to wake force a context switch as the woken task
184:               	may have a higher priority than the task we have interrupted. */
185:               	IFS1bits.U2RXIF = serCLEAR_FLAG;
0003D2  A9C087     BCLR 0x87, #6
186:               	while( U2STAbits.URXDA )
0003D4  AB0232     BTST U2STA, #0
0003D6  32000B     BRA Z, .L13
0003EA  AB0232     BTST U2STA, #0
0003EC  3AFFF6     BRA NZ, .L16
187:               	{
188:               		cChar = U2RXREG;
0003DA  8011B0     MOV U2RXREG, W0
0003DC  9FFFC0     MOV.B W0, [W15-4]
189:               		xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
0003D8  EB0400     CLR W8
0003DE  780188     MOV W8, W3
0003E0  E9810F     DEC2 W15, W2
0003E2  5780E4     SUB W15, #0x4, W1
0003E4  8044E0     MOV xRxedChars, W0
0003E6  021628     CALL xQueueGenericSendFromISR
0003E8  000000     NOP
190:               	}
191:               
192:               	if( xHigherPriorityTaskWoken != pdFALSE )
0003EE  97B87F     MOV [W15-2], W0
0003F0  E00000     CP0 W0
0003F2  320003     BRA Z, .L12
193:               	{
194:               		taskYIELD();
0003F4  02286C     CALL .Letext0, .LFE2, _vPortYield
0003F6  000000     NOP
0003F8  000000     NOP
195:               	}
196:               }
0003FA  FA8000     ULNK
0003FC  F90034     POP DSWPAG
0003FE  F90032     POP DSRPAG
000400  78044F     MOV [--W15], W8
000402  BE034F     MOV.D [--W15], W6
000404  BE024F     MOV.D [--W15], W4
000406  BE014F     MOV.D [--W15], W2
000408  BE004F     MOV.D [--W15], W0
00040A  F90036     POP RCOUNT
00040C  064000     RETFIE
197:               /*-----------------------------------------------------------*/
198:               
199:               void __attribute__((__interrupt__, auto_psv)) _U2TXInterrupt( void )
200:               {
00040E  F80036     PUSH RCOUNT
000410  BE9F80     MOV.D W0, [W15++]
000412  BE9F82     MOV.D W2, [W15++]
000414  BE9F84     MOV.D W4, [W15++]
000416  BE9F86     MOV.D W6, [W15++]
000418  781F88     MOV W8, [W15++]
00041A  F80032     PUSH DSRPAG
00041C  F80034     PUSH DSWPAG
00041E  200010     MOV #0x1, W0
000420  8801A0     MOV W0, DSWPAG
000422  202000     MOV #0x200, W0
000424  880190     MOV W0, DSRPAG
000426  FA0004     LNK #0x4
201:               signed char cChar;
202:               portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
000428  EB0000     CLR W0
00042A  9FBFF0     MOV W0, [W15-2]
203:               
204:               	/* If the transmit buffer is full we cannot get the next character.
205:               	Another interrupt will occur the next time there is space so this does
206:               	not matter. */
207:               	IFS1bits.U2TXIF = serCLEAR_FLAG;
00042C  A9E087     BCLR 0x87, #7
208:               	while( !( U2STAbits.UTXBF ) )
00042E  AB2233     BTST 0x233, #1
000430  3A0011     BRA NZ, .L19
000432  202008     MOV #0x200, W8
000448  801191     MOV U2STA, W1
00044A  640001     AND W8, W1, W0
00044C  32FFF3     BRA Z, .L23
00044E  370002     BRA .L19
209:               	{
210:               		if( xQueueReceiveFromISR( xCharsForTx, &cChar, &xHigherPriorityTaskWoken ) == pdTRUE )
000434  E9810F     DEC2 W15, W2
000436  5780E4     SUB W15, #0x4, W1
000438  8044C0     MOV xCharsForTx, W0
00043A  02192C     CALL xQueueReceiveFromISR
00043C  000000     NOP
00043E  500FE1     SUB W0, #0x1, [W15]
000440  3A0007     BRA NZ, .L20
211:               		{
212:               			/* Send the next character queued for Tx. */
213:               			U2TXREG = cChar;
000442  97F8CF     MOV.B [W15-4], W1
000444  FB0001     SE W1, W0
000446  8811A0     MOV W0, U2TXREG
214:               		}
215:               		else
216:               		{
217:               			/* Queue empty, nothing to send. */
218:               			xTxHasEnded = pdTRUE;
000450  200010     MOV #0x1, W0
000452  8844D0     MOV W0, xTxHasEnded
219:               			break;
220:               		}
221:               	}
222:               
223:               	if( xHigherPriorityTaskWoken != pdFALSE )
000454  97B87F     MOV [W15-2], W0
000456  E00000     CP0 W0
000458  320003     BRA Z, .L18
224:               	{
225:               		taskYIELD();
00045A  02286C     CALL .Letext0, .LFE2, _vPortYield
00045C  000000     NOP
00045E  000000     NOP
226:               	}
227:               }
000460  FA8000     ULNK
000462  F90034     POP DSWPAG
000464  F90032     POP DSRPAG
000466  78044F     MOV [--W15], W8
000468  BE034F     MOV.D [--W15], W6
00046A  BE024F     MOV.D [--W15], W4
00046C  BE014F     MOV.D [--W15], W2
00046E  BE004F     MOV.D [--W15], W0
000470  F90036     POP RCOUNT
000472  064000     RETFIE
228:               
229:               
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Demo/PIC24_MPLAB/main.c  --------------------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                /*
29:                 * Creates all the demo application tasks, then starts the scheduler.  The WEB
30:                 * documentation provides more details of the standard demo application tasks.
31:                 * In addition to the standard demo tasks, the following tasks and tests are
32:                 * defined and/or created within this file:
33:                 *
34:                 * "Fast Interrupt Test" - A high frequency periodic interrupt is generated
35:                 * using a free running timer to demonstrate the use of the 
36:                 * configKERNEL_INTERRUPT_PRIORITY configuration constant.  The interrupt 
37:                 * service routine measures the number of processor clocks that occur between
38:                 * each interrupt - and in so doing measures the jitter in the interrupt 
39:                 * timing.  The maximum measured jitter time is latched in the usMaxJitter 
40:                 * variable, and displayed on the LCD by the 'Check' as described below.  
41:                 * The fast interrupt is configured and handled in the timer_test.c source 
42:                 * file.
43:                 *
44:                 * "LCD" task - the LCD task is a 'gatekeeper' task.  It is the only task that
45:                 * is permitted to access the LCD directly.  Other tasks wishing to write a
46:                 * message to the LCD send the message on a queue to the LCD task instead of 
47:                 * accessing the LCD themselves.  The LCD task just blocks on the queue waiting 
48:                 * for messages - waking and displaying the messages as they arrive.  The LCD
49:                 * task is defined in lcd.c.  
50:                 * 
51:                 * "Check" task -  This only executes every three seconds but has the highest 
52:                 * priority so is guaranteed to get processor time.  Its main function is to 
53:                 * check that all the standard demo tasks are still operational.  Should any
54:                 * unexpected behaviour within a demo task be discovered the 'check' task will
55:                 * write "FAIL #n" to the LCD (via the LCD task).  If all the demo tasks are 
56:                 * executing with their expected behaviour then the check task writes the max
57:                 * jitter time to the LCD (again via the LCD task), as described above.
58:                 */
59:                
60:                // PIC24FJ64GA306 Configuration Bit Settings
61:                
62:                // 'C' source line config statements
63:                
64:                // CONFIG4
65:                #pragma config DSWDTPS = DSWDTPS1F      // Deep Sleep Watchdog Timer Postscale Select bits (1:68719476736 (25.7 Days))
66:                #pragma config DSWDTOSC = LPRC          // DSWDT Reference Clock Select (DSWDT uses LPRC as reference clock)
67:                #pragma config DSBOREN = ON             // Deep Sleep BOR Enable bit (DSBOR Enabled)
68:                #pragma config DSWDTEN = ON             // Deep Sleep Watchdog Timer Enable (DSWDT Enabled)
69:                #pragma config DSSWEN = ON              // DSEN Bit Enable (Deep Sleep is controlled by the register bit DSEN)
70:                
71:                // CONFIG3
72:                #pragma config WPFP = WPFP63            // Write Protection Flash Page Segment Boundary (Page 52 (0xFC00))
73:                #pragma config VBTBOR = ON              // VBAT BOR enable bit (VBAT BOR enabled)
74:                #pragma config SOSCSEL = ON             // SOSC Selection bits (SOSC circuit selected)
75:                #pragma config WDTWIN = PS25_0          // Watch Dog Timer Window Width (Watch Dog Timer Window Width is 25 percent)
76:                #pragma config BOREN = ON               // Brown-out Reset Enable (Brown-out Reset Enable)
77:                #pragma config WPDIS = WPDIS            // Segment Write Protection Disable (Disabled)
78:                #pragma config WPCFG = WPCFGDIS         // Write Protect Configuration Page Select (Disabled)
79:                #pragma config WPEND = WPENDMEM         // Segment Write Protection End Page Select (Write Protect from WPFP to the last page of memory)
80:                
81:                // CONFIG2
82:                #pragma config POSCMD = NONE            // Primary Oscillator Select (Primary Oscillator Disabled)
83:                #pragma config BOREN1 = EN              // BOR Override bit (BOR Enabled [When BOREN=1])
84:                #pragma config IOL1WAY = ON             // IOLOCK One-Way Set Enable bit (Once set, the IOLOCK bit cannot be cleared)
85:                #pragma config OSCIOFCN = OFF           // OSCO Pin Configuration (OSCO/CLKO/RC15 functions as CLKO (FOSC/2))
86:                #pragma config FCKSM = CSDCMD           // Clock Switching and Fail-Safe Clock Monitor Configuration bits (Clock switching and Fail-Safe Clock Monitor are disabled)
87:                #pragma config FNOSC = FRCDIV           // Initial Oscillator Select (Fast RC Oscillator with Postscaler (FRCDIV))
88:                #pragma config ALTVREF = DLT_AV_DLT_CV  // Alternate VREF/CVREF Pins Selection bit (Voltage reference input, ADC =RA9/RA10 Comparator =RA9,RA10)
89:                #pragma config IESO = ON                // Internal External Switchover (Enabled)
90:                
91:                // CONFIG1
92:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler Select (1:32,768)
93:                #pragma config FWPSA = PR128            // WDT Prescaler Ratio Select (1:128)
94:                #pragma config FWDTEN = WDT_HW          // Watchdog Timer Enable (WDT enabled in hardware)
95:                #pragma config WINDIS = OFF             // Windowed WDT Disable (Standard Watchdog Timer)
96:                #pragma config ICS = PGx2               // Emulator Pin Placement Select bits (Emulator functions are shared with PGEC2/PGED2)
97:                #pragma config LPCFG = OFF              // Low power regulator control (Disabled)
98:                #pragma config GWRP = OFF               // General Segment Write Protect (Disabled)
99:                #pragma config GCP = OFF                // General Segment Code Protect (Code protection is disabled)
100:               #pragma config JTAGEN = ON              // JTAG Port Enable (Enabled)
101:               
102:               // #pragma config statements should precede project file includes.
103:               // Use project enums instead of #define for ON and OFF.
104:               
105:               #include <xc.h>
106:               /* Standard includes. */
107:               #include <stdio.h>
108:               
109:               /* Scheduler includes. */
110:               #include "FreeRTOS.h"
111:               #include "task.h"
112:               #include "queue.h"
113:               #include "croutine.h"
114:               
115:               /* Demo application includes. */
116:               #include "BlockQ.h"
117:               #include "crflash.h"
118:               #include "blocktim.h"
119:               #include "integer.h"
120:               #include "comtest2.h"
121:               #include "partest.h"
122:               #include "lcd.h"
123:               #include "timertest.h"
124:               
125:               /* Demo task priorities. */
126:               #define mainBLOCK_Q_PRIORITY				( tskIDLE_PRIORITY + 2 )
127:               #define mainCHECK_TASK_PRIORITY				( tskIDLE_PRIORITY + 3 )
128:               #define mainCOM_TEST_PRIORITY				( 2 )
129:               
130:               /* The check task may require a bit more stack as it calls sprintf(). */
131:               #define mainCHECK_TAKS_STACK_SIZE			( configMINIMAL_STACK_SIZE * 2 )
132:               
133:               /* The execution period of the check task. */
134:               #define mainCHECK_TASK_PERIOD				( ( TickType_t ) 3000 / portTICK_PERIOD_MS )
135:               
136:               /* The number of flash co-routines to create. */
137:               #define mainNUM_FLASH_COROUTINES			( 5 )
138:               
139:               /* Baud rate used by the comtest tasks. */
140:               #define mainCOM_TEST_BAUD_RATE				( 19200 )
141:               
142:               /* The LED used by the comtest tasks.  mainCOM_TEST_LED + 1 is also used.
143:               See the comtest.c file for more information. */
144:               #define mainCOM_TEST_LED					( 6 )
145:               
146:               /* The frequency at which the "fast interrupt test" interrupt will occur. */
147:               #define mainTEST_INTERRUPT_FREQUENCY		( 20000 )
148:               
149:               /* The number of processor clocks we expect to occur between each "fast
150:               interrupt test" interrupt. */
151:               #define mainEXPECTED_CLOCKS_BETWEEN_INTERRUPTS ( configCPU_CLOCK_HZ / mainTEST_INTERRUPT_FREQUENCY )
152:               
153:               /* The number of nano seconds between each processor clock. */
154:               #define mainNS_PER_CLOCK ( ( unsigned short ) ( ( 1.0 / ( double ) configCPU_CLOCK_HZ ) * 1000000000.0 ) )
155:               
156:               /* Dimension the buffer used to hold the value of the maximum jitter time when
157:               it is converted to a string. */
158:               #define mainMAX_STRING_LENGTH				( 20 )
159:               #define START_STK_SIZE 512
160:               #define START_TASK_PRIO   64
161:               #define TASK1_STK_SIZE 512
162:               #define TASK1_TASK_PRIO   65
163:               #define TASK2_STK_SIZE 512
164:               #define TASK2_TASK_PRIO   66
165:               /*-----------------------------------------------------------*/
166:               
167:               /*
168:                * The check task as described at the top of this file.
169:                */
170:               static void vCheckTask(void *pvParameters);
171:               
172:               /*
173:                * Setup the processor ready for the demo.
174:                */
175:               static void prvSetupHardware(void);
176:               
177:               /* Prototypes for the standard FreeRTOS callback/hook functions implemented
178:               within this file. */
179:               void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName);
180:               void start_task(void *pvParameters);
181:               TaskHandle_t StartTask_Handle;
182:               TaskHandle_t Task1Task_Handle;
183:               TaskHandle_t Task2Task_Handle;
184:               /*-----------------------------------------------------------*/
185:               
186:               /* The queue used to send messages to the LCD task. */
187:               //static QueueHandle_t xLCDQueue;
188:               
189:               /*-----------------------------------------------------------*/
190:               
191:               /*
192:                * Create the demo tasks then start the scheduler.
193:                */
194:               int main(void) {
195:                   /* Configure any hardware required for this demo. */
196:                   prvSetupHardware();
00263E  060000     RETURN
197:               
198:                   /* Create the standard demo tasks. */
199:                   //    vStartBlockingQueueTasks(mainBLOCK_Q_PRIORITY);
200:                   //    vStartIntegerMathTasks(tskIDLE_PRIORITY);
201:                   //    vStartFlashCoRoutines(mainNUM_FLASH_COROUTINES);
202:                   //    vAltStartComTestTasks(mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED);
203:                   //    vCreateBlockTimeTasks();
204:               
205:                   /* Create the test tasks defined within this file. */
206:                   //    xTaskCreate(vCheckTask, "Check", mainCHECK_TAKS_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL);
207:               
208:                   /* Start the task that will control the LCD.  This returns the handle
209:                   to the queue used to write text out to the task. */
210:                   //	xLCDQueue = xStartLCDTask();
211:               
212:                   /* Start the high frequency interrupt test. */
213:                   //    vSetupTimerTest(mainTEST_INTERRUPT_FREQUENCY);
214:                   xTaskCreate((TaskFunction_t) start_task,
002642  208925     MOV #0x892, W5
002644  200404     MOV #0x40, W4
002646  EB0180     CLR W3
002648  202002     MOV #0x200, W2
00264A  2884E1     MOV #0x884E, W1
00264C  226120     MOV #0x2612, W0
00264E  020CB6     CALL xTaskCreate
002650  000000     NOP
215:                           (const char * const) "start", /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
216:                           (const configSTACK_DEPTH_TYPE) START_STK_SIZE,
217:                           (void * const) NULL,
218:                           (UBaseType_t) START_TASK_PRIO,
219:                           (TaskHandle_t * const) &StartTask_Handle);
220:                   /* Finally start the scheduler. */
221:                   vTaskStartScheduler();
002652  020D12     CALL vTaskStartScheduler
002654  000000     NOP
222:               
223:                   /* Will only reach here if there is insufficient heap available to start
224:                   the scheduler. */
225:                   return 0;
226:               }
002656  EB0000     CLR W0
002658  060000     RETURN
227:               
228:               /*-----------------------------------------------------------*/
229:               
230:               static void prvSetupHardware(void) {
231:                   vParTestInitialise();
00263A  022810     CALL vParTestInitialise
00263C  000000     NOP
232:               }
233:               
234:               /*-----------------------------------------------------------*/
235:               
236:               static void vCheckTask(void *pvParameters) {
237:                   /* Used to wake the task at the correct frequency. */
238:                   TickType_t xLastExecutionTime;
239:               
240:                   /* The maximum jitter time measured by the fast interrupt test. */
241:                   extern unsigned short usMaxJitter;
242:               
243:                   /* Buffer into which the maximum jitter time is written as a string. */
244:                   static char cStringBuffer[ mainMAX_STRING_LENGTH ];
245:               
246:                   /* The message that is sent on the queue to the LCD task.  The first
247:                   parameter is the minimum time (in ticks) that the message should be
248:                   left on the LCD without being overwritten.  The second parameter is a pointer
249:                   to the message to display itself. */
250:                   xLCDMessage xMessage = {0, cStringBuffer};
251:               
252:                   /* Set to pdTRUE should an error be detected in any of the standard demo tasks. */
253:                   unsigned short usErrorDetected = pdFALSE;
254:               
255:                   /* Remove compiler warnings. */
256:                   (void) pvParameters;
257:               
258:                   /* Initialise xLastExecutionTime so the first call to vTaskDelayUntil()
259:                   works correctly. */
260:                   xLastExecutionTime = xTaskGetTickCount();
261:               
262:                   for (;;) {
263:                       /* Wait until it is time for the next cycle. */
264:                       vTaskDelayUntil(&xLastExecutionTime, mainCHECK_TASK_PERIOD);
265:               
266:                       /* Has an error been found in any of the standard demo tasks? */
267:               
268:                       if (xAreIntegerMathsTaskStillRunning() != pdTRUE) {
269:                           usErrorDetected = pdTRUE;
270:                           sprintf(cStringBuffer, "FAIL #1");
271:                       }
272:               
273:                       if (xAreComTestTasksStillRunning() != pdTRUE) {
274:                           usErrorDetected = pdTRUE;
275:                           sprintf(cStringBuffer, "FAIL #2");
276:                       }
277:               
278:                       if (xAreBlockTimeTestTasksStillRunning() != pdTRUE) {
279:                           usErrorDetected = pdTRUE;
280:                           sprintf(cStringBuffer, "FAIL #3");
281:                       }
282:               
283:                       if (xAreBlockingQueuesStillRunning() != pdTRUE) {
284:                           usErrorDetected = pdTRUE;
285:                           sprintf(cStringBuffer, "FAIL #4");
286:                       }
287:               
288:                       if (usErrorDetected == pdFALSE) {
289:                           /* No errors have been discovered, so display the maximum jitter
290:                           timer discovered by the "fast interrupt test". */
291:                           sprintf(cStringBuffer, "%dns max jitter", (short) (usMaxJitter - mainEXPECTED_CLOCKS_BETWEEN_INTERRUPTS) * mainNS_PER_CLOCK);
292:                       }
293:               
294:                       /* Send the message to the LCD gatekeeper for display. */
295:                       //        xQueueSend(xLCDQueue, &xMessage, portMAX_DELAY);
296:                   }
297:               }
298:               
299:               /*-----------------------------------------------------------*/
300:               
301:               void vApplicationIdleHook(void) {
302:                   /* Schedule the co-routines from within the idle task hook. */
303:                   vCoRoutineSchedule();
00265A  021FEA     CALL vCoRoutineSchedule
00265C  000000     NOP
304:               }
00265E  060000     RETURN
305:               
306:               /*-----------------------------------------------------------*/
307:               
308:               void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {
309:                   (void) pcTaskName;
310:                   (void) pxTask;
311:               
312:                   /* Run time stack overflow checking is performed if
313:                   configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
314:                   function is called if a stack overflow is detected. */
315:                   taskDISABLE_INTERRUPTS();
002660  2FF1F0     MOV #0xFF1F, W0
002662  B60042     AND SR, WREG
002664  A05000     BSET W0, #5
002666  880210     MOV W0, SR
002668  000000     NOP
00266A  000000     NOP
00266C  37FFFF     BRA .L6
316:                   for (;;);
317:               }
318:               
319:               void start_task(void *pvParameters) {
320:                   xTaskCreate((TaskFunction_t) start_task,
002612  208945     MOV #0x894, W5
002614  200414     MOV #0x41, W4
002616  EB0180     CLR W3
002618  202002     MOV #0x200, W2
00261A  288381     MOV #0x8838, W1
00261C  226120     MOV #0x2612, W0
00261E  020CB6     CALL xTaskCreate
002620  000000     NOP
321:                           (const char * const) "task1_task", /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
322:                           (const configSTACK_DEPTH_TYPE) TASK1_STK_SIZE,
323:                           (void * const) NULL,
324:                           (UBaseType_t) TASK1_TASK_PRIO,
325:                           (TaskHandle_t * const) &Task1Task_Handle);
326:                   xTaskCreate((TaskFunction_t) start_task,
002622  208965     MOV #0x896, W5
002624  200424     MOV #0x42, W4
002626  EB0180     CLR W3
002628  202002     MOV #0x200, W2
00262A  288431     MOV #0x8843, W1
00262C  226120     MOV #0x2612, W0
00262E  020CB6     CALL xTaskCreate
002630  000000     NOP
327:                           (const char * const) "task2_task", /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
328:                           (const configSTACK_DEPTH_TYPE) TASK2_STK_SIZE,
329:                           (void * const) NULL,
330:                           (UBaseType_t) TASK2_TASK_PRIO,
331:                           (TaskHandle_t * const) &Task2Task_Handle);
332:                   vTaskDelete(StartTask_Handle); //NULL
002632  804490     MOV StartTask_Handle, W0
002634  020F3C     CALL vTaskDelete
002636  000000     NOP
333:               }
002638  060000     RETURN
334:               
335:               void task1_task(void *pvParameters) {
00266E  BE9F88     MOV.D W8, [W15++]
336:                   while (1) {
337:                       _LATE5 = ~_LATE5;
002670  2FFDF8     MOV #0xFFDF, W8
002674  801720     MOV LATE, W0
002676  DE0045     LSR W0, #5, W0
002678  EA8000     COM W0, W0
00267A  600061     AND W0, #0x1, W0
00267C  DD0045     SL W0, #5, W0
00267E  801722     MOV LATE, W2
002680  640082     AND W8, W2, W1
002682  700081     IOR W0, W1, W1
002684  881721     MOV W1, LATE
338:                       vTaskDelay(500);
002672  201F49     MOV #0x1F4, W9
002686  780009     MOV W9, W0
002688  021306     CALL vTaskDelay
00268A  000000     NOP
00268C  37FFF3     BRA .L8
339:                   }
340:               }
341:               
342:               void task2_task(void *pvParameters) {
00268E  BE9F88     MOV.D W8, [W15++]
343:                   while (1) {
344:                       _LATE7 = ~_LATE7;
002690  2FF7F8     MOV #0xFF7F, W8
002694  801720     MOV LATE, W0
002696  DE0047     LSR W0, #7, W0
002698  EA8000     COM W0, W0
00269A  600061     AND W0, #0x1, W0
00269C  DD0047     SL W0, #7, W0
00269E  801722     MOV LATE, W2
0026A0  640082     AND W8, W2, W1
0026A2  700081     IOR W0, W1, W1
0026A4  881721     MOV W1, LATE
345:                       vTaskDelay(2000);
002692  207D09     MOV #0x7D0, W9
0026A6  780009     MOV W9, W0
0026A8  021306     CALL vTaskDelay
0026AA  000000     NOP
0026AC  37FFF3     BRA .L10
346:                   }
347:               }
348:               
349:               void __attribute__((__interrupt__, auto_psv)) _DefaultInterrupt(void) {
000392  781F80     MOV W0, [W15++]
000394  F80032     PUSH DSRPAG
000396  F80034     PUSH DSWPAG
000398  200010     MOV #0x1, W0
00039A  8801A0     MOV W0, DSWPAG
00039C  202000     MOV #0x200, W0
00039E  880190     MOV W0, DSRPAG
350:                   uint16_t tmp;
351:                   Nop();
0003A0  000000     NOP
352:                   Nop();
0003A2  000000     NOP
353:                   Nop();
0003A4  000000     NOP
354:                   tmp = RCON;
0003A6  803A00     MOV RCON, W0
355:                   Nop();
0003A8  000000     NOP
356:                   Nop();
0003AA  000000     NOP
357:               }
0003AC  F90034     POP DSWPAG
0003AE  F90032     POP DSRPAG
0003B0  78004F     MOV [--W15], W0
0003B2  064000     RETFIE
358:               
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Demo/PIC24_MPLAB/ParTest/ParTest.c  ---------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                /* Scheduler includes. */
29:                #include "FreeRTOS.h"
30:                
31:                /* Demo app includes. */
32:                #include "partest.h"
33:                
34:                #define ptOUTPUT 	0
35:                #define ptALL_OFF	0
36:                
37:                /*-----------------------------------------------------------
38:                 * Simple parallel port IO routines.
39:                 *-----------------------------------------------------------*/
40:                
41:                void vParTestInitialise( void )
42:                {
43:                	/* The explorer 16 board has LED's on port A.  All bits are set as output
44:                	so PORTB is read-modified-written directly. */
45:                //	TRISB = ptOUTPUT;
46:                //	PORTB = ptALL_OFF;
47:                    _TRISE5=0;
002810  A9A2E0     BCLR TRISE, #5
48:                    _TRISE7=0;
002812  A9E2E0     BCLR TRISE, #7
49:                    _LATE5=0;
002814  A9A2E4     BCLR LATE, #5
50:                    _LATE7=1;
002816  A8E2E4     BSET LATE, #7
51:                }
002818  060000     RETURN
52:                /*-----------------------------------------------------------*/
53:                
54:                void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
55:                {
00281A  781F88     MOV W8, [W15++]
56:                unsigned portBASE_TYPE uxLEDBit;
57:                
58:                	/* Which port A bit is being modified? */
59:                	uxLEDBit = 1 << uxLED;
00281C  200018     MOV #0x1, W8
00281E  DD4400     SL W8, W0, W8
60:                
61:                	if( xValue )
002820  E00001     CP0 W1
002822  320007     BRA Z, .L3
62:                	{
63:                		/* Turn the LED on. */
64:                		portENTER_CRITICAL();
002824  0225F4     CALL vPortEnterCritical
002826  000000     NOP
65:                		{
66:                			PORTB |= uxLEDBit;
002828  780008     MOV W8, W0
00282A  B722CA     IOR PORTB
67:                		}
68:                		portEXIT_CRITICAL();
00282C  022604     CALL vPortExitCritical
00282E  000000     NOP
002830  370008     BRA .L2
69:                	}
70:                	else
71:                	{
72:                		/* Turn the LED off. */
73:                		portENTER_CRITICAL();
002832  0225F4     CALL vPortEnterCritical
002834  000000     NOP
74:                		{
75:                			PORTB &= ~uxLEDBit;
002836  EA8408     COM W8, W8
002838  801650     MOV PORTB, W0
00283A  600408     AND W0, W8, W8
00283C  881658     MOV W8, PORTB
76:                		}
77:                		portEXIT_CRITICAL();
00283E  022604     CALL vPortExitCritical
002840  000000     NOP
78:                	}
79:                }
002842  78044F     MOV [--W15], W8
002844  060000     RETURN
80:                /*-----------------------------------------------------------*/
81:                
82:                void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
83:                {
002846  781F88     MOV W8, [W15++]
84:                unsigned portBASE_TYPE uxLEDBit;
85:                
86:                	uxLEDBit = 1 << uxLED;
002848  200018     MOV #0x1, W8
00284A  DD4400     SL W8, W0, W8
87:                	portENTER_CRITICAL();
00284C  0225F4     CALL vPortEnterCritical
00284E  000000     NOP
88:                	{
89:                		/* If the LED is already on - turn it off.  If the LED is already
90:                		off, turn it on. */
91:                		if( PORTB & uxLEDBit )
002850  801651     MOV PORTB, W1
002852  608008     AND W1, W8, W0
002854  320005     BRA Z, .L6
92:                		{
93:                			PORTB &= ~uxLEDBit;
002856  EA8408     COM W8, W8
002858  801650     MOV PORTB, W0
00285A  600408     AND W0, W8, W8
00285C  881658     MOV W8, PORTB
00285E  370002     BRA .L7
94:                		}
95:                		else
96:                		{
97:                			PORTB |= uxLEDBit;
002860  780008     MOV W8, W0
002862  B722CA     IOR PORTB
98:                		}
99:                	}
100:               	portEXIT_CRITICAL();
002864  022604     CALL vPortExitCritical
002866  000000     NOP
101:               }
002868  78044F     MOV [--W15], W8
00286A  060000     RETURN
102:               
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Demo/Common/Minimal/integer.c  --------------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                /*
29:                 * Creates one or more tasks that repeatedly perform a set of integer
30:                 * calculations.  The result of each run-time calculation is compared to the
31:                 * known expected result - with a mismatch being indicative of an error in the
32:                 * context switch mechanism.
33:                 */
34:                
35:                #include <stdlib.h>
36:                
37:                /* Scheduler include files. */
38:                #include "FreeRTOS.h"
39:                #include "task.h"
40:                
41:                /* Demo program include files. */
42:                #include "integer.h"
43:                
44:                /* The constants used in the calculation. */
45:                #define intgCONST1				( ( long ) 123 )
46:                #define intgCONST2				( ( long ) 234567 )
47:                #define intgCONST3				( ( long ) -3 )
48:                #define intgCONST4				( ( long ) 7 )
49:                #define intgEXPECTED_ANSWER		( ( ( intgCONST1 + intgCONST2 ) * intgCONST3 ) / intgCONST4 )
50:                
51:                #define intgSTACK_SIZE			configMINIMAL_STACK_SIZE
52:                
53:                /* As this is the minimal version, we will only create one task. */
54:                #define intgNUMBER_OF_TASKS		( 1 )
55:                
56:                /* The task function.  Repeatedly performs a 32 bit calculation, checking the
57:                result against the expected result.  If the result is incorrect then the
58:                context switch must have caused some corruption. */
59:                static portTASK_FUNCTION_PROTO( vCompeteingIntMathTask, pvParameters );
60:                
61:                /* Variables that are set to true within the calculation task to indicate
62:                that the task is still executing.  The check task sets the variable back to
63:                false, flagging an error if the variable is still false the next time it
64:                is called. */
65:                static BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };
66:                
67:                /*-----------------------------------------------------------*/
68:                
69:                void vStartIntegerMathTasks( UBaseType_t uxPriority )
70:                {
002718  780200     MOV W0, W4
71:                short sTask;
72:                
73:                	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
74:                	{
75:                		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
00271A  EB0280     CLR W5
00271C  208AA3     MOV #0x8AA, W3
00271E  200732     MOV #0x73, W2
002720  288981     MOV #0x8898, W1
002722  226AE0     MOV #0x26AE, W0
002724  020CB6     CALL xTaskCreate
002726  000000     NOP
76:                	}
77:                }
002728  060000     RETURN
78:                /*-----------------------------------------------------------*/
79:                
80:                static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
81:                {
0026AE  FA0004     LNK #0x4
0026B0  BE9F88     MOV.D W8, [W15++]
0026B2  BE9F8A     MOV.D W10, [W15++]
0026B4  BE9F8C     MOV.D W12, [W15++]
0026B6  780480     MOV W0, W9
82:                /* These variables are all effectively set to constants so they are volatile to
83:                ensure the compiler does not just get rid of them. */
84:                volatile long lValue;
85:                short sError = pdFALSE;
0026B8  EB0400     CLR W8
86:                volatile BaseType_t *pxTaskHasExecuted;
87:                
88:                	/* Set a pointer to the variable we are going to set to true each
89:                	iteration.  This is also a good test of the parameter passing mechanism
90:                	within each port. */
91:                	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
92:                
93:                	/* Keep performing a calculation and checking the result against a constant. */
94:                	for( ;; )
95:                	{
96:                		/* Perform the calculation.  This will store partial value in
97:                		registers, resulting in a good test of the context switch mechanism. */
98:                		lValue = intgCONST1;
0026C6  2007B0     MOV #0x7B, W0
0026C8  200001     MOV #0x0, W1
0026CA  9FBF80     MOV W0, [W15-16]
0026CC  9FBF91     MOV W1, [W15-14]
99:                		lValue += intgCONST2;
0026BA  29447A     MOV #0x9447, W10
0026BC  20003B     MOV #0x3, W11
0026CE  97B80F     MOV [W15-16], W0
0026D0  97B89F     MOV [W15-14], W1
0026D2  450000     ADD W10, W0, W0
0026D4  4D8081     ADDC W11, W1, W1
0026D6  9FBF80     MOV W0, [W15-16]
0026D8  9FBF91     MOV W1, [W15-14]
100:               
101:               		/* Yield in case cooperative scheduling is being used. */
102:               		#if configUSE_PREEMPTION == 0
103:               		{
104:               			taskYIELD();
105:               		}
106:               		#endif
107:               
108:               		/* Finish off the calculation. */
109:               		lValue *= intgCONST3;
0026DA  97B80F     MOV [W15-16], W0
0026DC  97B89F     MOV [W15-14], W1
0026DE  2FFFD2     MOV #0xFFFD, W2
0026E0  B98A02     MUL.SS W1, W2, W4
0026E2  520180     SUB W4, W0, W3
0026E4  B80002     MUL.UU W0, W2, W0
0026E6  418081     ADD W3, W1, W1
0026E8  9FBF80     MOV W0, [W15-16]
0026EA  9FBF91     MOV W1, [W15-14]
110:               		lValue /= intgCONST4;
0026EC  97B80F     MOV [W15-16], W0
0026EE  97B89F     MOV [W15-14], W1
0026F0  200072     MOV #0x7, W2
0026F2  200003     MOV #0x0, W3
0026F4  0205B6     CALL ___divsi3
0026F6  000000     NOP
0026F8  9FBF80     MOV W0, [W15-16]
0026FA  9FBF91     MOV W1, [W15-14]
111:               
112:               		/* If the calculation is found to be incorrect we stop setting the
113:               		TaskHasExecuted variable so the check task can see an error has
114:               		occurred. */
115:               		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
0026BE  2771BC     MOV #0x771B, W12
0026C0  2FFFED     MOV #0xFFFE, W13
0026C2  370001     BRA .L7
0026FC  97B80F     MOV [W15-16], W0
0026FE  97B89F     MOV [W15-14], W1
002700  500F8C     SUB W0, W12, [W15]
002702  588F8D     SUBB W1, W13, [W15]
002704  3AFFDF     BRA NZ, .L4
116:               		{
117:               			sError = pdTRUE;
0026C4  200018     MOV #0x1, W8
118:               		}
119:               
120:               		if( sError == pdFALSE )
002706  E00008     CP0 W8
002708  3AFFDE     BRA NZ, .L7
121:               		{
122:               			/* We have not encountered any errors, so set the flag that show
123:               			we are still executing.  This will be periodically cleared by
124:               			the check task. */
125:               			portENTER_CRITICAL();
00270A  0225F4     CALL vPortEnterCritical
00270C  000000     NOP
126:               				*pxTaskHasExecuted = pdTRUE;
00270E  200010     MOV #0x1, W0
002710  780C80     MOV W0, [W9]
127:               			portEXIT_CRITICAL();
002712  022604     CALL vPortExitCritical
002714  000000     NOP
002716  37FFD7     BRA .L7
128:               		}
129:               
130:               		/* Yield in case cooperative scheduling is being used. */
131:               		#if configUSE_PREEMPTION == 0
132:               		{
133:               			taskYIELD();
134:               		}
135:               		#endif
136:               	}
137:               }
138:               /*-----------------------------------------------------------*/
139:               
140:               /* This is called to check that all the created tasks are still running. */
141:               BaseType_t xAreIntegerMathsTaskStillRunning( void )
00272A  804550     MOV xTaskCheck, W0
00272C  A7F000     BTSC W0, #15
00272E  EA0000     NEG W0, W0
002730  EA0000     NEG W0, W0
002732  DE004F     LSR W0, #15, W0
142:               {
143:               BaseType_t xReturn = pdTRUE;
144:               short sTask;
145:               
146:               	/* Check the maths tasks are still running by ensuring their check variables
147:               	are still being set to true. */
148:               	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
149:               	{
150:               		if( xTaskCheck[ sTask ] == pdFALSE )
151:               		{
152:               			/* The check has not incremented so an error exists. */
153:               			xReturn = pdFALSE;
154:               		}
155:               
156:               		/* Reset the check variable so we can tell if it has been set by
157:               		the next time around. */
158:               		xTaskCheck[ sTask ] = pdFALSE;
002734  EF28AA     CLR xTaskCheck
159:               	}
160:               
161:               	return xReturn;
162:               }
002736  060000     RETURN
163:               
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Demo/Common/Minimal/crflash.c  --------------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                /*
29:                 * This demo application file demonstrates the use of queues to pass data
30:                 * between co-routines.
31:                 *
32:                 * N represents the number of 'fixed delay' co-routines that are created and
33:                 * is set during initialisation.
34:                 *
35:                 * N 'fixed delay' co-routines are created that just block for a fixed
36:                 * period then post the number of an LED onto a queue.  Each such co-routine
37:                 * uses a different block period.  A single 'flash' co-routine is also created
38:                 * that blocks on the same queue, waiting for the number of the next LED it
39:                 * should flash.  Upon receiving a number it simply toggle the instructed LED
40:                 * then blocks on the queue once more.  In this manner each LED from LED 0 to
41:                 * LED N-1 is caused to flash at a different rate.
42:                 *
43:                 * The 'fixed delay' co-routines are created with co-routine priority 0.  The
44:                 * flash co-routine is created with co-routine priority 1.  This means that
45:                 * the queue should never contain more than a single item.  This is because
46:                 * posting to the queue will unblock the 'flash' co-routine, and as this has
47:                 * a priority greater than the tasks posting to the queue it is guaranteed to
48:                 * have emptied the queue and blocked once again before the queue can contain
49:                 * any more date.  An error is indicated if an attempt to post data to the
50:                 * queue fails - indicating that the queue is already full.
51:                 *
52:                 */
53:                
54:                /* Scheduler includes. */
55:                #include "FreeRTOS.h"
56:                #include "croutine.h"
57:                #include "queue.h"
58:                
59:                /* Demo application includes. */
60:                #include "partest.h"
61:                #include "crflash.h"
62:                
63:                /* The queue should only need to be of length 1.  See the description at the
64:                top of the file. */
65:                #define crfQUEUE_LENGTH		1
66:                
67:                #define crfFIXED_DELAY_PRIORITY		0
68:                #define crfFLASH_PRIORITY			1
69:                
70:                /* Only one flash co-routine is created so the index is not significant. */
71:                #define crfFLASH_INDEX				0
72:                
73:                /* Don't allow more than crfMAX_FLASH_TASKS 'fixed delay' co-routines to be
74:                created. */
75:                #define crfMAX_FLASH_TASKS			8
76:                
77:                /* We don't want to block when posting to the queue. */
78:                #define crfPOSTING_BLOCK_TIME		0
79:                
80:                /*
81:                 * The 'fixed delay' co-routine as described at the top of the file.
82:                 */
83:                static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex );
84:                
85:                /*
86:                 * The 'flash' co-routine as described at the top of the file.
87:                 */
88:                static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex );
89:                
90:                /* The queue used to pass data between the 'fixed delay' co-routines and the
91:                'flash' co-routine. */
92:                static QueueHandle_t xFlashQueue;
93:                
94:                /* This will be set to pdFALSE if we detect an error. */
95:                static BaseType_t xCoRoutineFlashStatus = pdPASS;
96:                
97:                /*-----------------------------------------------------------*/
98:                
99:                /*
100:                * See the header file for details.
101:                */
102:               void vStartFlashCoRoutines( UBaseType_t uxNumberToCreate )
103:               {
00234E  BE9F88     MOV.D W8, [W15++]
002350  BE9F8A     MOV.D W10, [W15++]
002352  780580     MOV W0, W11
104:               UBaseType_t uxIndex;
105:               
106:               	if( uxNumberToCreate > crfMAX_FLASH_TASKS )
107:               	{
108:               		uxNumberToCreate = crfMAX_FLASH_TASKS;
109:               	}
110:               
111:               	/* Create the queue used to pass data between the co-routines. */
112:               	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );
002354  EB4100     CLR.B W2
002356  200021     MOV #0x2, W1
002358  200010     MOV #0x1, W0
00235A  021512     CALL xQueueGenericCreate
00235C  000000     NOP
00235E  884540     MOV W0, xFlashQueue
113:               
114:               	if( xFlashQueue )
002360  E00000     CP0 W0
002362  320015     BRA Z, .L19
002364  558FE8     SUB W11, #0x8, [W15]
002366  360001     BRA LEU, .L21
002368  20008B     MOV #0x8, W11
115:               	{
116:               		/* Create uxNumberToCreate 'fixed delay' co-routines. */
117:               		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
00236A  E0000B     CP0 W11
00236C  32000B     BRA Z, .L22
00236E  EB0500     CLR W10
00237E  E8050A     INC W10, W10
002380  558F8A     SUB W11, W10, [W15]
002382  3EFFF8     BRA GTU, .L23
118:               		{
119:               			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
002370  EB0400     CLR W8
002372  222DE9     MOV #0x22DE, W9
002374  78010A     MOV W10, W2
002376  780088     MOV W8, W1
002378  780009     MOV W9, W0
00237A  022070     CALL xCoRoutineCreate
00237C  000000     NOP
120:               		}
121:               
122:               		/* Create the 'flash' co-routine. */
123:               		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
002384  EB0100     CLR W2
002386  200011     MOV #0x1, W1
002388  222860     MOV #0x2286, W0
00238A  022070     CALL xCoRoutineCreate
00238C  000000     NOP
124:               	}
125:               }
00238E  BE054F     MOV.D [--W15], W10
002390  BE044F     MOV.D [--W15], W8
002392  060000     RETURN
126:               /*-----------------------------------------------------------*/
127:               
128:               static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
129:               {
0022DE  FA0002     LNK #0x2
0022E0  781F88     MOV W8, [W15++]
0022E2  9FBFE1     MOV W1, [W15-4]
130:               /* Even though this is a co-routine the xResult variable does not need to be
131:               static as we do not need it to maintain its state between blocks. */
132:               BaseType_t xResult;
133:               /* The uxIndex parameter of the co-routine function is used as an index into
134:               the xFlashRates array to obtain the delay period to use. */
135:               static const TickType_t xFlashRates[ crfMAX_FLASH_TASKS ] = { 150 / portTICK_PERIOD_MS,
136:               																200 / portTICK_PERIOD_MS,
137:               																250 / portTICK_PERIOD_MS,
138:               																300 / portTICK_PERIOD_MS,
139:               																350 / portTICK_PERIOD_MS,
140:               																400 / portTICK_PERIOD_MS,
141:               																450 / portTICK_PERIOD_MS,
142:               																500  / portTICK_PERIOD_MS };
143:               
144:               	/* Co-routines MUST start with a call to crSTART. */
145:               	crSTART( xHandle );
0022E4  780400     MOV W0, W8
0022E6  900858     MOV [W8+26], W0
0022E8  2012E1     MOV #0x12E, W1
0022EA  500F81     SUB W0, W1, [W15]
0022EC  320014     BRA Z, .L12
0022EE  3E0003     BRA GTU, .L14
0022F0  E00000     CP0 W0
0022F2  320007     BRA Z, .L11
0022F4  370029     BRA .L9
0022F6  2012F1     MOV #0x12F, W1
0022F8  500F81     SUB W0, W1, [W15]
0022FA  320017     BRA Z, .L18
0022FC  4080F3     ADD W1, #0x13, W1
0022FE  500F81     SUB W0, W1, [W15]
002300  3A0023     BRA NZ, .L9
146:               
147:               	for( ;; )
148:               	{
149:               		/* Post our uxIndex value onto the queue.  This is used as the LED to
150:               		flash. */
151:               		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
002302  EB0100     CLR W2
002304  5780E4     SUB W15, #0x4, W1
002306  804540     MOV xFlashQueue, W0
002308  0219E0     CALL xQueueCRSend
00230A  000000     NOP
00230C  400FE4     ADD W0, #0x4, [W15]
00230E  3A0008     BRA NZ, .L15
002310  2012E0     MOV #0x12E, W0
002312  980C50     MOV W0, [W8+26]
002314  370019     BRA .L9
002316  EB0100     CLR W2
002318  5780E4     SUB W15, #0x4, W1
00231A  804540     MOV xFlashQueue, W0
00231C  0219E0     CALL xQueueCRSend
00231E  000000     NOP
002320  400FE5     ADD W0, #0x5, [W15]
002322  3A0004     BRA NZ, .L13
002324  2012F0     MOV #0x12F, W0
002326  980C50     MOV W0, [W8+26]
002328  37000F     BRA .L9
00232A  200010     MOV #0x1, W0
152:               
153:               		if( xResult != pdPASS )
00232C  500FE1     SUB W0, #0x1, [W15]
00232E  320001     BRA Z, .L16
154:               		{
155:               			/* For the reasons stated at the top of the file we should always
156:               			find that we can post to the queue.  If we could not then an error
157:               			has occurred. */
158:               			xCoRoutineFlashStatus = pdFAIL;
002330  EF28A6     CLR 0x8A6
159:               		}
160:               
161:               		crDELAY( xHandle, xFlashRates[ uxIndex ] );
002332  97B86F     MOV [W15-4], W0
002334  400000     ADD W0, W0, W0
002336  2886E1     MOV #0x886E, W1
002338  780061     MOV [W1+W0], W0
00233A  E00000     CP0 W0
00233C  320003     BRA Z, .L17
00233E  EB0080     CLR W1
002340  021ECC     CALL vCoRoutineAddToDelayedList
002342  000000     NOP
002344  201420     MOV #0x142, W0
002346  980C50     MOV W0, [W8+26]
162:               	}
163:               
164:               	/* Co-routines MUST end with a call to crEND. */
165:               	crEND();
166:               }
002348  78044F     MOV [--W15], W8
00234A  FA8000     ULNK
00234C  060000     RETURN
167:               /*-----------------------------------------------------------*/
168:               
169:               static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
170:               {
002286  FA0002     LNK #0x2
002288  781F88     MOV W8, [W15++]
00228A  780400     MOV W0, W8
171:               /* Even though this is a co-routine the variable do not need to be
172:               static as we do not need it to maintain their state between blocks. */
173:               BaseType_t xResult;
174:               UBaseType_t uxLEDToFlash;
175:               
176:               	/* Co-routines MUST start with a call to crSTART. */
177:               	crSTART( xHandle );
00228C  900858     MOV [W8+26], W0
00228E  2016E1     MOV #0x16E, W1
002290  500F81     SUB W0, W1, [W15]
002292  32000F     BRA Z, .L4
002294  E80081     INC W1, W1
002296  500F81     SUB W0, W1, [W15]
002298  320016     BRA Z, .L8
00229A  E00000     CP0 W0
00229C  3A001D     BRA NZ, .L1
178:               	( void ) uxIndex;
179:               
180:               	for( ;; )
181:               	{
182:               		/* Block to wait for the number of the LED to flash. */
183:               		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
00229E  EB8100     SETM W2
0022A0  5780E4     SUB W15, #0x4, W1
0022A2  804540     MOV xFlashQueue, W0
0022A4  021A66     CALL xQueueCRReceive
0022A6  000000     NOP
0022A8  400FE4     ADD W0, #0x4, [W15]
0022AA  3A0008     BRA NZ, .L6
0022AC  2016E0     MOV #0x16E, W0
0022AE  980C50     MOV W0, [W8+26]
0022B0  370013     BRA .L1
0022B2  EB0100     CLR W2
0022B4  5780E4     SUB W15, #0x4, W1
0022B6  804540     MOV xFlashQueue, W0
0022B8  021A66     CALL xQueueCRReceive
0022BA  000000     NOP
0022BC  400FE5     ADD W0, #0x5, [W15]
0022BE  3A0004     BRA NZ, .L5
0022C0  2016F0     MOV #0x16F, W0
0022C2  980C50     MOV W0, [W8+26]
0022C4  370009     BRA .L1
0022C6  200010     MOV #0x1, W0
184:               
185:               		if( xResult != pdPASS )
0022C8  500FE1     SUB W0, #0x1, [W15]
0022CA  320002     BRA Z, .L7
186:               		{
187:               			/* We would not expect to wake unless we received something. */
188:               			xCoRoutineFlashStatus = pdFAIL;
0022CC  EF28A6     CLR 0x8A6
0022CE  37FFE7     BRA .L3
189:               		}
190:               		else
191:               		{
192:               			/* We received the number of an LED to flash - flash it! */
193:               			vParTestToggleLED( uxLEDToFlash );
0022D0  97B86F     MOV [W15-4], W0
0022D2  022846     CALL vParTestToggleLED
0022D4  000000     NOP
0022D6  37FFE3     BRA .L3
194:               		}
195:               	}
196:               
197:               	/* Co-routines MUST end with a call to crEND. */
198:               	crEND();
199:               }
0022D8  78044F     MOV [--W15], W8
0022DA  FA8000     ULNK
0022DC  060000     RETURN
200:               /*-----------------------------------------------------------*/
201:               
202:               BaseType_t xAreFlashCoRoutinesStillRunning( void )
203:               {
204:               	/* Return pdPASS or pdFAIL depending on whether an error has been detected
205:               	or not. */
206:               	return xCoRoutineFlashStatus;
207:               }
002394  804530     MOV 0x8A6, W0
002396  060000     RETURN
208:               
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Demo/Common/Minimal/comtest.c  --------------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                
29:                /*
30:                 * This version of comtest. c is for use on systems that have limited stack
31:                 * space and no display facilities.  The complete version can be found in
32:                 * the Demo/Common/Full directory.
33:                 *
34:                 * Creates two tasks that operate on an interrupt driven serial port.  A
35:                 * loopback connector should be used so that everything that is transmitted is
36:                 * also received.  The serial port does not use any flow control.  On a
37:                 * standard 9way 'D' connector pins two and three should be connected together.
38:                 *
39:                 * The first task posts a sequence of characters to the Tx queue, toggling an
40:                 * LED on each successful post.  At the end of the sequence it sleeps for a
41:                 * pseudo-random period before resending the same sequence.
42:                 *
43:                 * The UART Tx end interrupt is enabled whenever data is available in the Tx
44:                 * queue.  The Tx end ISR removes a single character from the Tx queue and
45:                 * passes it to the UART for transmission.
46:                 *
47:                 * The second task blocks on the Rx queue waiting for a character to become
48:                 * available.  When the UART Rx end interrupt receives a character it places
49:                 * it in the Rx queue, waking the second task.  The second task checks that the
50:                 * characters removed from the Rx queue form the same sequence as those posted
51:                 * to the Tx queue, and toggles an LED for each correct character.
52:                 *
53:                 * The receiving task is spawned with a higher priority than the transmitting
54:                 * task.  The receiver will therefore wake every time a character is
55:                 * transmitted so neither the Tx or Rx queue should ever hold more than a few
56:                 * characters.
57:                 *
58:                 */
59:                
60:                /* Scheduler include files. */
61:                #include <stdlib.h>
62:                #include "FreeRTOS.h"
63:                #include "task.h"
64:                
65:                /* Demo program include files. */
66:                #include "serial.h"
67:                #include "comtest.h"
68:                #include "partest.h"
69:                
70:                #define comSTACK_SIZE				configMINIMAL_STACK_SIZE
71:                #define comTX_LED_OFFSET			( 0 )
72:                #define comRX_LED_OFFSET			( 1 )
73:                #define comTOTAL_PERMISSIBLE_ERRORS ( 2 )
74:                
75:                /* The Tx task will transmit the sequence of characters at a pseudo random
76:                interval.  This is the maximum and minimum block time between sends. */
77:                #define comTX_MAX_BLOCK_TIME		( ( TickType_t ) 0x96 )
78:                #define comTX_MIN_BLOCK_TIME		( ( TickType_t ) 0x32 )
79:                #define comOFFSET_TIME				( ( TickType_t ) 3 )
80:                
81:                /* We should find that each character can be queued for Tx immediately and we
82:                don't have to block to send. */
83:                #define comNO_BLOCK					( ( TickType_t ) 0 )
84:                
85:                /* The Rx task will block on the Rx queue for a long period. */
86:                #define comRX_BLOCK_TIME			( ( TickType_t ) 0xffff )
87:                
88:                /* The sequence transmitted is from comFIRST_BYTE to and including comLAST_BYTE. */
89:                #define comFIRST_BYTE				( 'A' )
90:                #define comLAST_BYTE				( 'X' )
91:                
92:                #define comBUFFER_LEN				( ( UBaseType_t ) ( comLAST_BYTE - comFIRST_BYTE ) + ( UBaseType_t ) 1 )
93:                #define comINITIAL_RX_COUNT_VALUE	( 0 )
94:                
95:                /* Handle to the com port used by both tasks. */
96:                static xComPortHandle xPort = NULL;
97:                
98:                /* The transmit task as described at the top of the file. */
99:                static portTASK_FUNCTION_PROTO( vComTxTask, pvParameters );
100:               
101:               /* The receive task as described at the top of the file. */
102:               static portTASK_FUNCTION_PROTO( vComRxTask, pvParameters );
103:               
104:               /* The LED that should be toggled by the Rx and Tx tasks.  The Rx task will
105:               toggle LED ( uxBaseLED + comRX_LED_OFFSET).  The Tx task will toggle LED
106:               ( uxBaseLED + comTX_LED_OFFSET ). */
107:               static UBaseType_t uxBaseLED = 0;
108:               
109:               /* Check variable used to ensure no error have occurred.  The Rx task will
110:               increment this variable after every successfully received sequence.  If at any
111:               time the sequence is incorrect the the variable will stop being incremented. */
112:               static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;
113:               
114:               /*-----------------------------------------------------------*/
115:               
116:               void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
117:               {
00244E  781F88     MOV W8, [W15++]
002450  780400     MOV W0, W8
002452  BE0202     MOV.D W2, W4
118:               	/* Initialise the com port then spawn the Rx and Tx tasks. */
119:               	uxBaseLED = uxLED;
002454  884521     MOV W1, uxBaseLED
120:               	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
002456  200182     MOV #0x18, W2
002458  BE0004     MOV.D W4, W0
00245A  022490     CALL xSerialPortInitMinimal
00245C  000000     NOP
121:               
122:               	/* The Tx task is spawned with a lower priority than the Rx task. */
123:               	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
00245E  EB0280     CLR W5
002460  E90208     DEC W8, W4
002462  EB0180     CLR W3
002464  200732     MOV #0x73, W2
002466  2888C1     MOV #0x888C, W1
002468  224040     MOV #0x2404, W0
00246A  020CB6     CALL xTaskCreate
00246C  000000     NOP
124:               	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
00246E  EB0280     CLR W5
002470  780208     MOV W8, W4
002472  EB0180     CLR W3
002474  200732     MOV #0x73, W2
002476  288921     MOV #0x8892, W1
002478  223980     MOV #0x2398, W0
00247A  020CB6     CALL xTaskCreate
00247C  000000     NOP
125:               }
00247E  78044F     MOV [--W15], W8
002480  060000     RETURN
126:               /*-----------------------------------------------------------*/
127:               
128:               static portTASK_FUNCTION( vComTxTask, pvParameters )
129:               {
002404  BE9F88     MOV.D W8, [W15++]
002406  781F8A     MOV W10, [W15++]
130:               char cByteToSend;
131:               TickType_t xTimeToWait;
132:               
133:               	/* Just to stop compiler warnings. */
134:               	( void ) pvParameters;
135:               
136:               	for( ;; )
137:               	{
138:               		/* Simply transmit a sequence of characters from comFIRST_BYTE to
139:               		comLAST_BYTE. */
140:               		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
002408  B3C418     MOV.B #0x41, W8
00240A  B3C589     MOV.B #0x58, W9
002424  E84408     INC.B W8, W8
002426  544F89     SUB.B W8, W9, [W15]
002428  34FFF3     BRA LE, .L18
00244A  B3C418     MOV.B #0x41, W8
00244C  37FFEC     BRA .L22
141:               		{
142:               			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
002410  EB0100     CLR W2
002412  784088     MOV.B W8, W1
002414  EB0000     CLR W0
002416  022546     CALL xSerialPutChar
002418  000000     NOP
00241A  500FE1     SUB W0, #0x1, [W15]
00241C  3A0003     BRA NZ, .L17
143:               			{
144:               				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
00241E  804520     MOV uxBaseLED, W0
002420  022846     CALL vParTestToggleLED
002422  000000     NOP
145:               			}
146:               		}
147:               
148:               		/* Turn the LED off while we are not doing anything. */
149:               		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
00242A  EB0080     CLR W1
00242C  804520     MOV uxBaseLED, W0
00242E  02281A     CALL vParTestSetLED
002430  000000     NOP
150:               
151:               		/* We have posted all the characters in the string - wait before
152:               		re-sending.  Wait a pseudo-random time as this will provide a better
153:               		test. */
154:               		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
002432  020A8A     CALL xTaskGetTickCount
002434  000000     NOP
002436  400063     ADD W0, #0x3, W0
155:               
156:               		/* Make sure we don't wait too long... */
157:               		xTimeToWait %= comTX_MAX_BLOCK_TIME;
00240C  20096A     MOV #0x96, W10
00240E  37000B     BRA .L22
002438  090011     REPEAT #0x11
00243A  D8800A     DIV.UW W0, W10
00243C  FD0080     EXCH W0, W1
158:               
159:               		/* ...but we do want to wait. */
160:               		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
00243E  200311     MOV #0x31, W1
002440  500F81     SUB W0, W1, [W15]
002442  3E0001     BRA GTU, .L19
161:               		{
162:               			xTimeToWait = comTX_MIN_BLOCK_TIME;
002444  200320     MOV #0x32, W0
163:               		}
164:               
165:               		vTaskDelay( xTimeToWait );
002446  021306     CALL vTaskDelay
002448  000000     NOP
00244A  B3C418     MOV.B #0x41, W8
00244C  37FFEC     BRA .L22
166:               	}
167:               } /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
168:               /*-----------------------------------------------------------*/
169:               
170:               static portTASK_FUNCTION( vComRxTask, pvParameters )
171:               {
002398  FA0002     LNK #0x2
00239A  BE9F88     MOV.D W8, [W15++]
00239C  BE9F8A     MOV.D W10, [W15++]
00239E  BE9F8C     MOV.D W12, [W15++]
172:               signed char cExpectedByte, cByteRxed;
173:               BaseType_t xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
0023A0  EB0600     CLR W12
174:               
175:               	/* Just to stop compiler warnings. */
176:               	( void ) pvParameters;
177:               
178:               	for( ;; )
179:               	{
180:               		/* We expect to receive the characters from comFIRST_BYTE to
181:               		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
182:               		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
0023A2  B3C41D     MOV.B #0x41, W13
0023A4  B3C59A     MOV.B #0x59, W10
0023A8  78440D     MOV.B W13, W8
0023C6  E84408     INC.B W8, W8
0023C8  544F8A     SUB.B W8, W10, [W15]
0023CA  3AFFF0     BRA NZ, .L5
183:               		{
184:               			/* Block on the queue that contains received bytes until a byte is
185:               			available. */
186:               			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
0023AA  EB8480     SETM W9
0023AC  780109     MOV W9, W2
0023AE  5780EE     SUB W15, #0xE, W1
0023B0  EB0000     CLR W0
0023B2  022536     CALL xSerialGetChar
0023B4  000000     NOP
0023B6  E00000     CP0 W0
0023B8  320006     BRA Z, .L3
187:               			{
188:               				/* Was this the byte we were expecting?  If so, toggle the LED,
189:               				otherwise we are out on sync and should break out of the loop
190:               				until the expected character sequence is about to restart. */
191:               				if( cByteRxed == cExpectedByte )
0023BA  97F02F     MOV.B [W15-14], W0
0023BC  504F88     SUB.B W0, W8, [W15]
0023BE  3A0019     BRA NZ, .L4
192:               				{
193:               					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
0023C0  EC08A4     INC uxBaseLED, WREG
0023C2  022846     CALL vParTestToggleLED
0023C4  000000     NOP
194:               				}
195:               				else
196:               				{
197:               					xResyncRequired = pdTRUE;
198:               					break; /*lint !e960 Non-switch break allowed. */
199:               				}
200:               			}
201:               		}
202:               
203:               		/* Turn the LED off while we are not doing anything. */
204:               		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
0023CC  EC08A4     INC uxBaseLED, WREG
0023CE  EB0080     CLR W1
0023D0  02281A     CALL vParTestSetLED
0023D2  000000     NOP
0023F2  EC08A4     INC uxBaseLED, WREG
0023F4  EB0080     CLR W1
0023F6  02281A     CALL vParTestSetLED
0023F8  000000     NOP
205:               
206:               		/* Did we break out of the loop because the characters were received in
207:               		an unexpected order?  If so wait here until the character sequence is
208:               		about to restart. */
209:               		if( xResyncRequired == pdTRUE )
210:               		{
211:               			while( cByteRxed != comLAST_BYTE )
0023A6  B3C58B     MOV.B #0x58, W11
0023E4  97F02F     MOV.B [W15-14], W0
0023E6  504F8B     SUB.B W0, W11, [W15]
0023E8  3AFFF8     BRA NZ, .L10
0023FC  97F02F     MOV.B [W15-14], W0
0023FE  504F8B     SUB.B W0, W11, [W15]
002400  3AFFEC     BRA NZ, .L10
002402  37FFF3     BRA .L9
212:               			{
213:               				/* Block until the next char is available. */
214:               				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
0023DA  780108     MOV W8, W2
0023DC  5780EE     SUB W15, #0xE, W1
0023DE  EB0000     CLR W0
0023E0  022536     CALL xSerialGetChar
0023E2  000000     NOP
0023FA  EB8400     SETM W8
215:               			}
216:               
217:               			/* Note that an error occurred which caused us to have to resync.
218:               			We use this to stop incrementing the loop counter so
219:               			sAreComTestTasksStillRunning() will return false - indicating an
220:               			error. */
221:               			xErrorOccurred++;
0023EA  E8060C     INC W12, W12
0023EC  37FFDD     BRA .L13
222:               
223:               			/* We have now resynced with the Tx task and can continue. */
224:               			xResyncRequired = pdFALSE;
225:               		}
226:               		else
227:               		{
228:               			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
0023D4  560FE1     SUB W12, #0x1, [W15]
0023D6  3CFFE8     BRA GT, .L13
0023D8  37000A     BRA .L14
229:               			{
230:               				/* Increment the count of successful loops.  As error
231:               				occurring (i.e. an unexpected character being received) will
232:               				prevent this counter being incremented for the rest of the
233:               				execution.   Don't worry about mutual exclusion on this
234:               				variable - it doesn't really matter as we just want it
235:               				to change. */
236:               				uxRxLoops++;
0023EE  EC28A2     INC uxRxLoops
0023F0  37FFDB     BRA .L13
0023F2  EC08A4     INC uxBaseLED, WREG
0023F4  EB0080     CLR W1
0023F6  02281A     CALL vParTestSetLED
0023F8  000000     NOP
0023FA  EB8400     SETM W8
0023FC  97F02F     MOV.B [W15-14], W0
0023FE  504F8B     SUB.B W0, W11, [W15]
002400  3AFFEC     BRA NZ, .L10
002402  37FFF3     BRA .L9
237:               			}
238:               		}
239:               	}
240:               } /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
241:               /*-----------------------------------------------------------*/
242:               
243:               BaseType_t xAreComTestTasksStillRunning( void )
244:               {
245:               BaseType_t xReturn;
246:               
247:               	/* If the count of successful reception loops has not changed than at
248:               	some time an error occurred (i.e. a character was received out of sequence)
249:               	and we will return false. */
250:               	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
002482  804510     MOV uxRxLoops, W0
251:               	{
252:               		xReturn = pdFALSE;
002486  A7F000     BTSC W0, #15
002488  EA0000     NEG W0, W0
00248A  EA0000     NEG W0, W0
00248C  DE004F     LSR W0, #15, W0
253:               	}
254:               	else
255:               	{
256:               		xReturn = pdTRUE;
257:               	}
258:               
259:               	/* Reset the count of successful Rx loops.  When this function is called
260:               	again we expect this to have been incremented. */
261:               	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
002484  EF28A2     CLR uxRxLoops
262:               
263:               	return xReturn;
264:               }
00248E  060000     RETURN
265:               
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Demo/Common/Minimal/blocktim.c  -------------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                /*
29:                 * This file contains some test scenarios that ensure tasks do not exit queue
30:                 * send or receive functions prematurely.  A description of the tests is
31:                 * included within the code.
32:                 */
33:                
34:                /* Kernel includes. */
35:                #include "FreeRTOS.h"
36:                #include "task.h"
37:                #include "queue.h"
38:                
39:                /* Demo includes. */
40:                #include "blocktim.h"
41:                
42:                /* Task priorities.  Allow these to be overridden. */
43:                #ifndef bktPRIMARY_PRIORITY
44:                	#define bktPRIMARY_PRIORITY		( configMAX_PRIORITIES - 3 )
45:                #endif
46:                
47:                #ifndef bktSECONDARY_PRIORITY
48:                	#define bktSECONDARY_PRIORITY	( configMAX_PRIORITIES - 4 )
49:                #endif
50:                
51:                /* Task behaviour. */
52:                #define bktQUEUE_LENGTH				( 5 )
53:                #define bktSHORT_WAIT				pdMS_TO_TICKS( ( TickType_t ) 20 )
54:                #define bktPRIMARY_BLOCK_TIME		( 10 )
55:                #define bktALLOWABLE_MARGIN			( 15 )
56:                #define bktTIME_TO_BLOCK			( 175 )
57:                #define bktDONT_BLOCK				( ( TickType_t ) 0 )
58:                #define bktRUN_INDICATOR			( ( UBaseType_t ) 0x55 )
59:                
60:                /* In case the demo does not have software timers enabled, as this file uses
61:                the configTIMER_TASK_PRIORITY setting. */
62:                #ifndef configTIMER_TASK_PRIORITY
63:                	#define configTIMER_TASK_PRIORITY ( configMAX_PRIORITIES - 1 )
64:                #endif
65:                
66:                /*-----------------------------------------------------------*/
67:                
68:                /*
69:                 * The two test tasks.  Their behaviour is commented within the functions.
70:                 */
71:                static void vPrimaryBlockTimeTestTask( void *pvParameters );
72:                static void vSecondaryBlockTimeTestTask( void *pvParameters );
73:                
74:                /*
75:                 * Very basic tests to verify the block times are as expected.
76:                 */
77:                static void prvBasicDelayTests( void );
78:                
79:                /*-----------------------------------------------------------*/
80:                
81:                /* The queue on which the tasks block. */
82:                static QueueHandle_t xTestQueue;
83:                
84:                /* Handle to the secondary task is required by the primary task for calls
85:                to vTaskSuspend/Resume(). */
86:                static TaskHandle_t xSecondary;
87:                
88:                /* Used to ensure that tasks are still executing without error. */
89:                static volatile BaseType_t xPrimaryCycles = 0, xSecondaryCycles = 0;
90:                static volatile BaseType_t xErrorOccurred = pdFALSE;
91:                
92:                /* Provides a simple mechanism for the primary task to know when the
93:                secondary task has executed. */
94:                static volatile UBaseType_t xRunIndicator;
95:                
96:                /*-----------------------------------------------------------*/
97:                
98:                void vCreateBlockTimeTasks( void )
99:                {
100:               	/* Create the queue on which the two tasks block. */
101:               	xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( BaseType_t ) );
001E70  EB4100     CLR.B W2
001E72  200021     MOV #0x2, W1
001E74  200050     MOV #0x5, W0
001E76  021512     CALL xQueueGenericCreate
001E78  000000     NOP
001E7A  8843C0     MOV W0, xTestQueue
102:               
103:               	if( xTestQueue != NULL )
001E7C  E00000     CP0 W0
001E7E  320010     BRA Z, .L60
104:               	{
105:               		/* vQueueAddToRegistry() adds the queue to the queue registry, if one
106:               		is in use.  The queue registry is provided as a means for kernel aware
107:               		debuggers to locate queues and has no purpose if a kernel aware
108:               		debugger is not being used.  The call to vQueueAddToRegistry() will be
109:               		removed by the pre-processor if configQUEUE_REGISTRY_SIZE is not
110:               		defined or is defined to be less than 1. */
111:               		vQueueAddToRegistry( xTestQueue, "Block_Time_Queue" );
112:               
113:               		/* Create the two test tasks. */
114:               		xTaskCreate( vPrimaryBlockTimeTestTask, "BTest1", configMINIMAL_STACK_SIZE, NULL, bktPRIMARY_PRIORITY, NULL );
001E80  EB0280     CLR W5
001E82  200014     MOV #0x1, W4
001E84  EB0180     CLR W3
001E86  200732     MOV #0x73, W2
001E88  2887E1     MOV #0x887E, W1
001E8A  21C6E0     MOV #0x1C6E, W0
001E8C  020CB6     CALL xTaskCreate
001E8E  000000     NOP
115:               		xTaskCreate( vSecondaryBlockTimeTestTask, "BTest2", configMINIMAL_STACK_SIZE, NULL, bktSECONDARY_PRIORITY, &xSecondary );
001E90  2087A5     MOV #0x87A, W5
001E92  EB0200     CLR W4
001E94  EB0180     CLR W3
001E96  200732     MOV #0x73, W2
001E98  288851     MOV #0x8885, W1
001E9A  21B7E0     MOV #0x1B7E, W0
001E9C  020CB6     CALL xTaskCreate
001E9E  000000     NOP
116:               	}
117:               }
001EA0  060000     RETURN
118:               /*-----------------------------------------------------------*/
119:               
120:               static void vPrimaryBlockTimeTestTask( void *pvParameters )
121:               {
001C6E  FA0004     LNK #0x4
001C70  BE9F88     MOV.D W8, [W15++]
001C72  BE9F8A     MOV.D W10, [W15++]
001C74  781F8C     MOV W12, [W15++]
122:               BaseType_t xItem, xData;
123:               TickType_t xTimeWhenBlocking;
124:               TickType_t xTimeToBlock, xBlockedTime;
125:               
126:               	( void ) pvParameters;
127:               
128:               	for( ;; )
129:               	{
130:               		/*********************************************************************
131:               		Test 0
132:               
133:               		Basic vTaskDelay() and vTaskDelayUntil() tests. */
134:               		prvBasicDelayTests();
001C76  200559     MOV #0x55, W9
001C78  07FFC6     RCALL _prvBasicDelayTests, .LFE2, .LFB3
135:               
136:               
137:               		/*********************************************************************
138:               		Test 1
139:               
140:               		Simple block time wakeup test on queue receives. */
141:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
001C7A  EB0000     CLR W0
001C7C  9FBF90     MOV W0, [W15-14]
001C7E  EB0400     CLR W8
001CB4  97B89F     MOV [W15-14], W1
001CB6  E80401     INC W1, W8
001CB8  9FBF98     MOV W8, [W15-14]
001CBA  540FE4     SUB W8, #0x4, [W15]
001CBC  34FFE2     BRA LE, .L18
142:               		{
143:               			/* The queue is empty. Attempt to read from the queue using a block
144:               			time.  When we wake, ensure the delta in time is as expected. */
145:               			xTimeToBlock = ( TickType_t ) ( bktPRIMARY_BLOCK_TIME << xItem );
001C80  2000AB     MOV #0xA, W11
001C82  DD5C08     SL W11, W8, W8
146:               
147:               			xTimeWhenBlocking = xTaskGetTickCount();
001C84  020A8A     CALL xTaskGetTickCount
001C86  000000     NOP
001C88  780500     MOV W0, W10
148:               
149:               			/* We should unblock after xTimeToBlock having not received
150:               			anything on the queue. */
151:               			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
001C8A  780108     MOV W8, W2
001C8C  5780EC     SUB W15, #0xC, W1
001C8E  8043C0     MOV xTestQueue, W0
001C90  0216B4     CALL xQueueReceive
001C92  000000     NOP
001C94  E00000     CP0 W0
001C96  320002     BRA Z, .L15
152:               			{
153:               				xErrorOccurred = pdTRUE;
001C98  200010     MOV #0x1, W0
001C9A  884390     MOV W0, xErrorOccurred
154:               			}
155:               
156:               			/* How long were we blocked for? */
157:               			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
001C9C  020A8A     CALL xTaskGetTickCount
001C9E  000000     NOP
001CA0  50050A     SUB W0, W10, W10
158:               
159:               			if( xBlockedTime < xTimeToBlock )
001CA2  540F8A     SUB W8, W10, [W15]
001CA4  360002     BRA LEU, .L16
160:               			{
161:               				/* Should not have blocked for less than we requested. */
162:               				xErrorOccurred = pdTRUE;
001CA6  200010     MOV #0x1, W0
001CA8  884390     MOV W0, xErrorOccurred
163:               			}
164:               
165:               			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
001CAA  44046F     ADD W8, #0xF, W8
001CAC  550F88     SUB W10, W8, [W15]
001CAE  360002     BRA LEU, .L17
166:               			{
167:               				/* Should not have blocked for longer than we requested,
168:               				although we would not necessarily run as soon as we were
169:               				unblocked so a margin is allowed. */
170:               				xErrorOccurred = pdTRUE;
001CB0  200010     MOV #0x1, W0
001CB2  884390     MOV W0, xErrorOccurred
171:               			}
172:               		}
173:               
174:               		/*********************************************************************
175:               		Test 2
176:               
177:               		Simple block time wakeup test on queue sends.
178:               
179:               		First fill the queue.  It should be empty so all sends should pass. */
180:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
001CBE  EB0000     CLR W0
001CC0  9FBF90     MOV W0, [W15-14]
001CD8  97B89F     MOV [W15-14], W1
001CDA  E80001     INC W1, W0
001CDC  9FBF90     MOV W0, [W15-14]
001CDE  500FE4     SUB W0, #0x4, [W15]
001CE0  34FFF2     BRA LE, .L20
181:               		{
182:               			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
001CC2  EB0400     CLR W8
001CC6  780188     MOV W8, W3
001CC8  780108     MOV W8, W2
001CCA  5780EE     SUB W15, #0xE, W1
001CCC  8043C0     MOV xTestQueue, W0
001CCE  021546     CALL xQueueGenericSend
001CD0  000000     NOP
001CD2  500FE1     SUB W0, #0x1, [W15]
001CD4  320001     BRA Z, .L19
183:               			{
184:               				xErrorOccurred = pdTRUE;
001CC4  20001A     MOV #0x1, W10
001CD6  88439A     MOV W10, xErrorOccurred
185:               			}
186:               
187:               			#if configUSE_PREEMPTION == 0
188:               				taskYIELD();
189:               			#endif
190:               		}
191:               
192:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
001CE2  EB0000     CLR W0
001CE4  9FBF90     MOV W0, [W15-14]
001CE6  EB0400     CLR W8
001D1A  97B89F     MOV [W15-14], W1
001D1C  E80401     INC W1, W8
001D1E  9FBF98     MOV W8, [W15-14]
001D20  540FE4     SUB W8, #0x4, [W15]
001D22  34FFE4     BRA LE, .L24
193:               		{
194:               			/* The queue is full. Attempt to write to the queue using a block
195:               			time.  When we wake, ensure the delta in time is as expected. */
196:               			xTimeToBlock = ( TickType_t ) ( bktPRIMARY_BLOCK_TIME << xItem );
001CE8  2000AC     MOV #0xA, W12
001CEC  DD6408     SL W12, W8, W8
197:               
198:               			xTimeWhenBlocking = xTaskGetTickCount();
001CEE  020A8A     CALL xTaskGetTickCount
001CF0  000000     NOP
001CF2  780500     MOV W0, W10
199:               
200:               			/* We should unblock after xTimeToBlock having not received
201:               			anything on the queue. */
202:               			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
001CF4  EB0180     CLR W3
001CF6  780108     MOV W8, W2
001CF8  5780EE     SUB W15, #0xE, W1
001CFA  8043C0     MOV xTestQueue, W0
001CFC  021546     CALL xQueueGenericSend
001CFE  000000     NOP
001D00  E00000     CP0 W0
001D02  320001     BRA Z, .L21
203:               			{
204:               				xErrorOccurred = pdTRUE;
001CEA  20001B     MOV #0x1, W11
001D04  88439B     MOV W11, xErrorOccurred
205:               			}
206:               
207:               			/* How long were we blocked for? */
208:               			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
001D06  020A8A     CALL xTaskGetTickCount
001D08  000000     NOP
001D0A  50050A     SUB W0, W10, W10
209:               
210:               			if( xBlockedTime < xTimeToBlock )
001D0C  540F8A     SUB W8, W10, [W15]
001D0E  360001     BRA LEU, .L22
211:               			{
212:               				/* Should not have blocked for less than we requested. */
213:               				xErrorOccurred = pdTRUE;
001D10  88439B     MOV W11, xErrorOccurred
214:               			}
215:               
216:               			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
001D12  44046F     ADD W8, #0xF, W8
001D14  550F88     SUB W10, W8, [W15]
001D16  360001     BRA LEU, .L23
217:               			{
218:               				/* Should not have blocked for longer than we requested,
219:               				although we would not necessarily run as soon as we were
220:               				unblocked so a margin is allowed. */
221:               				xErrorOccurred = pdTRUE;
001D18  88439B     MOV W11, xErrorOccurred
222:               			}
223:               		}
224:               
225:               		/*********************************************************************
226:               		Test 3
227:               
228:               		Wake the other task, it will block attempting to post to the queue.
229:               		When we read from the queue the other task will wake, but before it
230:               		can run we will post to the queue again.  When the other task runs it
231:               		will find the queue still full, even though it was woken.  It should
232:               		recognise that its block time has not expired and return to block for
233:               		the remains of its block time.
234:               
235:               		Wake the other task so it blocks attempting to post to the already
236:               		full queue. */
237:               		xRunIndicator = 0;
001D24  EF287C     CLR xRunIndicator
238:               		vTaskResume( xSecondary );
001D26  8043D0     MOV xSecondary, W0
001D28  0209D2     CALL vTaskResume
001D2A  000000     NOP
239:               
240:               		/* We need to wait a little to ensure the other task executes. */
241:               		while( xRunIndicator != bktRUN_INDICATOR )
001D2C  8043E0     MOV xRunIndicator, W0
001D2E  500F89     SUB W0, W9, [W15]
001D30  320007     BRA Z, .L25
001D3A  8043E1     MOV xRunIndicator, W1
001D3C  508F89     SUB W1, W9, [W15]
001D3E  3AFFFA     BRA NZ, .L49
242:               		{
243:               			/* The other task has not yet executed. */
244:               			vTaskDelay( bktSHORT_WAIT );
001D32  200148     MOV #0x14, W8
001D34  780008     MOV W8, W0
001D36  021306     CALL vTaskDelay
001D38  000000     NOP
245:               		}
246:               		/* Make sure the other task is blocked on the queue. */
247:               		vTaskDelay( bktSHORT_WAIT );
001D40  200140     MOV #0x14, W0
001D42  021306     CALL vTaskDelay
001D44  000000     NOP
248:               		xRunIndicator = 0;
001D46  EF287C     CLR xRunIndicator
249:               
250:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
001D48  EB0000     CLR W0
001D4A  9FBF90     MOV W0, [W15-14]
001D94  97B89F     MOV [W15-14], W1
001D96  E80001     INC W1, W0
001D98  9FBF90     MOV W0, [W15-14]
001D9A  500FE4     SUB W0, #0x4, [W15]
001D9C  34FFD7     BRA LE, .L31
251:               		{
252:               			/* Now when we make space on the queue the other task should wake
253:               			but not execute as this task has higher priority. */
254:               			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
001D4C  EB0100     CLR W2
001D4E  5780EC     SUB W15, #0xC, W1
001D50  8043C0     MOV xTestQueue, W0
001D52  0216B4     CALL xQueueReceive
001D54  000000     NOP
001D56  500FE1     SUB W0, #0x1, [W15]
001D58  320002     BRA Z, .L27
255:               			{
256:               				xErrorOccurred = pdTRUE;
001D5A  200010     MOV #0x1, W0
001D5C  884390     MOV W0, xErrorOccurred
257:               			}
258:               
259:               			/* Now fill the queue again before the other task gets a chance to
260:               			execute.  If the other task had executed we would find the queue
261:               			full ourselves, and the other task have set xRunIndicator. */
262:               			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
001D5E  B81160     MUL.UU W2, #0, W2
001D60  5780EE     SUB W15, #0xE, W1
001D62  8043C0     MOV xTestQueue, W0
001D64  021546     CALL xQueueGenericSend
001D66  000000     NOP
001D68  500FE1     SUB W0, #0x1, [W15]
001D6A  320002     BRA Z, .L28
263:               			{
264:               				xErrorOccurred = pdTRUE;
001D6C  200010     MOV #0x1, W0
001D6E  884390     MOV W0, xErrorOccurred
265:               			}
266:               
267:               			if( xRunIndicator == bktRUN_INDICATOR )
001D70  8043E1     MOV xRunIndicator, W1
001D72  508F89     SUB W1, W9, [W15]
001D74  3A0002     BRA NZ, .L29
268:               			{
269:               				/* The other task should not have executed. */
270:               				xErrorOccurred = pdTRUE;
001D76  200010     MOV #0x1, W0
001D78  884390     MOV W0, xErrorOccurred
271:               			}
272:               
273:               			/* Raise the priority of the other task so it executes and blocks
274:               			on the queue again. */
275:               			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
001D7A  200031     MOV #0x3, W1
001D7C  8043D0     MOV xSecondary, W0
001D7E  02092C     CALL vTaskPrioritySet
001D80  000000     NOP
276:               
277:               			/* The other task should now have re-blocked without exiting the
278:               			queue function. */
279:               			if( xRunIndicator == bktRUN_INDICATOR )
001D82  8043E0     MOV xRunIndicator, W0
001D84  500F89     SUB W0, W9, [W15]
001D86  3A0002     BRA NZ, .L30
280:               			{
281:               				/* The other task should not have executed outside of the
282:               				queue function. */
283:               				xErrorOccurred = pdTRUE;
001D88  200010     MOV #0x1, W0
001D8A  884390     MOV W0, xErrorOccurred
284:               			}
285:               
286:               			/* Set the priority back down. */
287:               			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
001D8C  EB0080     CLR W1
001D8E  8043D0     MOV xSecondary, W0
001D90  02092C     CALL vTaskPrioritySet
001D92  000000     NOP
288:               		}
289:               
290:               		/* Let the other task timeout.  When it unblockes it will check that it
291:               		unblocked at the correct time, then suspend itself. */
292:               		while( xRunIndicator != bktRUN_INDICATOR )
001D9E  8043E0     MOV xRunIndicator, W0
001DA0  500F89     SUB W0, W9, [W15]
001DA2  320007     BRA Z, .L32
001DAC  8043E1     MOV xRunIndicator, W1
001DAE  508F89     SUB W1, W9, [W15]
001DB0  3AFFFA     BRA NZ, .L48
293:               		{
294:               			vTaskDelay( bktSHORT_WAIT );
001DA4  200148     MOV #0x14, W8
001DA6  780008     MOV W8, W0
001DA8  021306     CALL vTaskDelay
001DAA  000000     NOP
295:               		}
296:               		vTaskDelay( bktSHORT_WAIT );
001DB2  200140     MOV #0x14, W0
001DB4  021306     CALL vTaskDelay
001DB6  000000     NOP
297:               		xRunIndicator = 0;
001DB8  EF287C     CLR xRunIndicator
298:               
299:               
300:               		/*********************************************************************
301:               		Test 4
302:               
303:               		As per test 3 - but with the send and receive the other way around.
304:               		The other task blocks attempting to read from the queue.
305:               
306:               		Empty the queue.  We should find that it is full. */
307:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
001DBA  EB0000     CLR W0
001DBC  9FBF90     MOV W0, [W15-14]
001DD0  97B89F     MOV [W15-14], W1
001DD2  E80001     INC W1, W0
001DD4  9FBF90     MOV W0, [W15-14]
001DD6  500FE4     SUB W0, #0x4, [W15]
001DD8  34FFF3     BRA LE, .L35
308:               		{
309:               			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
001DC0  EB0100     CLR W2
001DC2  5780EC     SUB W15, #0xC, W1
001DC4  8043C0     MOV xTestQueue, W0
001DC6  0216B4     CALL xQueueReceive
001DC8  000000     NOP
001DCA  500FE1     SUB W0, #0x1, [W15]
001DCC  320001     BRA Z, .L34
310:               			{
311:               				xErrorOccurred = pdTRUE;
001DBE  200018     MOV #0x1, W8
001DCE  884398     MOV W8, xErrorOccurred
312:               			}
313:               		}
314:               
315:               		/* Wake the other task so it blocks attempting to read from  the
316:               		already	empty queue. */
317:               		vTaskResume( xSecondary );
001DDA  8043D0     MOV xSecondary, W0
001DDC  0209D2     CALL vTaskResume
001DDE  000000     NOP
318:               
319:               		/* We need to wait a little to ensure the other task executes. */
320:               		while( xRunIndicator != bktRUN_INDICATOR )
001DE0  8043E0     MOV xRunIndicator, W0
001DE2  500F89     SUB W0, W9, [W15]
001DE4  320007     BRA Z, .L36
001DEE  8043E1     MOV xRunIndicator, W1
001DF0  508F89     SUB W1, W9, [W15]
001DF2  3AFFFA     BRA NZ, .L47
321:               		{
322:               			vTaskDelay( bktSHORT_WAIT );
001DE6  200148     MOV #0x14, W8
001DE8  780008     MOV W8, W0
001DEA  021306     CALL vTaskDelay
001DEC  000000     NOP
323:               		}
324:               		vTaskDelay( bktSHORT_WAIT );
001DF4  200140     MOV #0x14, W0
001DF6  021306     CALL vTaskDelay
001DF8  000000     NOP
325:               		xRunIndicator = 0;
001DFA  EF287C     CLR xRunIndicator
326:               
327:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
001DFC  EB0000     CLR W0
001DFE  9FBF90     MOV W0, [W15-14]
001E48  97B89F     MOV [W15-14], W1
001E4A  E80001     INC W1, W0
001E4C  9FBF90     MOV W0, [W15-14]
001E4E  500FE4     SUB W0, #0x4, [W15]
001E50  34FFD7     BRA LE, .L42
328:               		{
329:               			/* Now when we place an item on the queue the other task should
330:               			wake but not execute as this task has higher priority. */
331:               			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
001E00  B81160     MUL.UU W2, #0, W2
001E02  5780EE     SUB W15, #0xE, W1
001E04  8043C0     MOV xTestQueue, W0
001E06  021546     CALL xQueueGenericSend
001E08  000000     NOP
001E0A  500FE1     SUB W0, #0x1, [W15]
001E0C  320002     BRA Z, .L38
332:               			{
333:               				xErrorOccurred = pdTRUE;
001E0E  200010     MOV #0x1, W0
001E10  884390     MOV W0, xErrorOccurred
334:               			}
335:               
336:               			/* Now empty the queue again before the other task gets a chance to
337:               			execute.  If the other task had executed we would find the queue
338:               			empty ourselves, and the other task would be suspended. */
339:               			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
001E12  EB0100     CLR W2
001E14  5780EC     SUB W15, #0xC, W1
001E16  8043C0     MOV xTestQueue, W0
001E18  0216B4     CALL xQueueReceive
001E1A  000000     NOP
001E1C  500FE1     SUB W0, #0x1, [W15]
001E1E  320002     BRA Z, .L39
340:               			{
341:               				xErrorOccurred = pdTRUE;
001E20  200010     MOV #0x1, W0
001E22  884390     MOV W0, xErrorOccurred
342:               			}
343:               
344:               			if( xRunIndicator == bktRUN_INDICATOR )
001E24  8043E1     MOV xRunIndicator, W1
001E26  508F89     SUB W1, W9, [W15]
001E28  3A0002     BRA NZ, .L40
345:               			{
346:               				/* The other task should not have executed. */
347:               				xErrorOccurred = pdTRUE;
001E2A  200010     MOV #0x1, W0
001E2C  884390     MOV W0, xErrorOccurred
348:               			}
349:               
350:               			/* Raise the priority of the other task so it executes and blocks
351:               			on the queue again. */
352:               			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
001E2E  200031     MOV #0x3, W1
001E30  8043D0     MOV xSecondary, W0
001E32  02092C     CALL vTaskPrioritySet
001E34  000000     NOP
353:               
354:               			/* The other task should now have re-blocked without exiting the
355:               			queue function. */
356:               			if( xRunIndicator == bktRUN_INDICATOR )
001E36  8043E0     MOV xRunIndicator, W0
001E38  500F89     SUB W0, W9, [W15]
001E3A  3A0002     BRA NZ, .L41
357:               			{
358:               				/* The other task should not have executed outside of the
359:               				queue function. */
360:               				xErrorOccurred = pdTRUE;
001E3C  200010     MOV #0x1, W0
001E3E  884390     MOV W0, xErrorOccurred
361:               			}
362:               			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
001E40  EB0080     CLR W1
001E42  8043D0     MOV xSecondary, W0
001E44  02092C     CALL vTaskPrioritySet
001E46  000000     NOP
363:               		}
364:               
365:               		/* Let the other task timeout.  When it unblockes it will check that it
366:               		unblocked at the correct time, then suspend itself. */
367:               		while( xRunIndicator != bktRUN_INDICATOR )
001E52  8043E0     MOV xRunIndicator, W0
001E54  500F89     SUB W0, W9, [W15]
001E56  320007     BRA Z, .L43
001E60  8043E1     MOV xRunIndicator, W1
001E62  508F89     SUB W1, W9, [W15]
001E64  3AFFFA     BRA NZ, .L46
368:               		{
369:               			vTaskDelay( bktSHORT_WAIT );
001E58  200148     MOV #0x14, W8
001E5A  780008     MOV W8, W0
001E5C  021306     CALL vTaskDelay
001E5E  000000     NOP
370:               		}
371:               		vTaskDelay( bktSHORT_WAIT );
001E66  200140     MOV #0x14, W0
001E68  021306     CALL vTaskDelay
001E6A  000000     NOP
372:               
373:               		xPrimaryCycles++;
001E6C  EC286E     INC xPrimaryCycles
374:               	}
001E6E  37FF04     BRA .L45
375:               }
376:               /*-----------------------------------------------------------*/
377:               
378:               static void vSecondaryBlockTimeTestTask( void *pvParameters )
379:               {
001B7E  FA0002     LNK #0x2
001B80  BE9F88     MOV.D W8, [W15++]
001B82  781F8A     MOV W10, [W15++]
380:               TickType_t xTimeWhenBlocking, xBlockedTime;
381:               BaseType_t xData;
382:               
383:               	( void ) pvParameters;
384:               
385:               	for( ;; )
386:               	{
387:               		/*********************************************************************
388:               		Test 0, 1 and 2
389:               
390:               		This task does not participate in these tests. */
391:               		vTaskSuspend( NULL );
001B88  EB0000     CLR W0
001B8A  020ED4     CALL vTaskSuspend
001B8C  000000     NOP
392:               
393:               		/*********************************************************************
394:               		Test 3
395:               
396:               		The first thing we do is attempt to read from the queue.  It should be
397:               		full so we block.  Note the time before we block so we can check the
398:               		wake time is as per that expected. */
399:               		xTimeWhenBlocking = xTaskGetTickCount();
001B8E  020A8A     CALL xTaskGetTickCount
001B90  000000     NOP
001B92  780480     MOV W0, W9
400:               
401:               		/* We should unblock after bktTIME_TO_BLOCK having not sent anything to
402:               		the queue. */
403:               		xData = 0;
001B94  EB0000     CLR W0
001B96  9FBFC0     MOV W0, [W15-8]
404:               		xRunIndicator = bktRUN_INDICATOR;
001B84  200558     MOV #0x55, W8
001B98  8843E8     MOV W8, xRunIndicator
405:               		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
001B9A  EB0180     CLR W3
001B9C  200AF2     MOV #0xAF, W2
001B9E  5780E8     SUB W15, #0x8, W1
001BA0  8043C0     MOV xTestQueue, W0
001BA2  021546     CALL xQueueGenericSend
001BA4  000000     NOP
001BA6  E00000     CP0 W0
001BA8  320002     BRA Z, .L2
406:               		{
407:               			xErrorOccurred = pdTRUE;
001BAA  200010     MOV #0x1, W0
001BAC  884390     MOV W0, xErrorOccurred
408:               		}
409:               
410:               		/* How long were we inside the send function? */
411:               		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
001BAE  020A8A     CALL xTaskGetTickCount
001BB0  000000     NOP
001BB2  500489     SUB W0, W9, W9
412:               
413:               		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
414:               		if( xBlockedTime < bktTIME_TO_BLOCK )
001B86  200AEA     MOV #0xAE, W10
001BB4  548F8A     SUB W9, W10, [W15]
001BB6  3E0002     BRA GTU, .L3
415:               		{
416:               			xErrorOccurred = pdTRUE;
001BB8  200010     MOV #0x1, W0
001BBA  884390     MOV W0, xErrorOccurred
417:               		}
418:               
419:               		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
420:               		either.  A margin is permitted as we would not necessarily run as
421:               		soon as we unblocked. */
422:               		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
001BBC  200BE0     MOV #0xBE, W0
001BBE  548F80     SUB W9, W0, [W15]
001BC0  360002     BRA LEU, .L4
423:               		{
424:               			xErrorOccurred = pdTRUE;
001BC2  200010     MOV #0x1, W0
001BC4  884390     MOV W0, xErrorOccurred
425:               		}
426:               
427:               		/* Suspend ready for test 3. */
428:               		xRunIndicator = bktRUN_INDICATOR;
001BC6  8843E8     MOV W8, xRunIndicator
429:               		vTaskSuspend( NULL );
001BC8  EB0000     CLR W0
001BCA  020ED4     CALL vTaskSuspend
001BCC  000000     NOP
430:               
431:               		/*********************************************************************
432:                       Test 4
433:               
434:               		As per test three, but with the send and receive reversed. */
435:               		xTimeWhenBlocking = xTaskGetTickCount();
001BCE  020A8A     CALL xTaskGetTickCount
001BD0  000000     NOP
001BD2  780480     MOV W0, W9
436:               
437:               		/* We should unblock after bktTIME_TO_BLOCK having not received
438:               		anything on the queue. */
439:               		xRunIndicator = bktRUN_INDICATOR;
001BD4  8843E8     MOV W8, xRunIndicator
440:               		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
001BD6  200AF2     MOV #0xAF, W2
001BD8  5780E8     SUB W15, #0x8, W1
001BDA  8043C0     MOV xTestQueue, W0
001BDC  0216B4     CALL xQueueReceive
001BDE  000000     NOP
001BE0  E00000     CP0 W0
001BE2  320002     BRA Z, .L5
441:               		{
442:               			xErrorOccurred = pdTRUE;
001BE4  200010     MOV #0x1, W0
001BE6  884390     MOV W0, xErrorOccurred
443:               		}
444:               
445:               		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
001BE8  020A8A     CALL xTaskGetTickCount
001BEA  000000     NOP
001BEC  500489     SUB W0, W9, W9
446:               
447:               		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
448:               		if( xBlockedTime < bktTIME_TO_BLOCK )
001BEE  548F8A     SUB W9, W10, [W15]
001BF0  3E0002     BRA GTU, .L6
449:               		{
450:               			xErrorOccurred = pdTRUE;
001BF2  200010     MOV #0x1, W0
001BF4  884390     MOV W0, xErrorOccurred
451:               		}
452:               
453:               		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
454:               		either.  A margin is permitted as we would not necessarily run as soon
455:               		as we unblocked. */
456:               		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
001BF6  200BE0     MOV #0xBE, W0
001BF8  548F80     SUB W9, W0, [W15]
001BFA  360002     BRA LEU, .L7
457:               		{
458:               			xErrorOccurred = pdTRUE;
001BFC  200010     MOV #0x1, W0
001BFE  884390     MOV W0, xErrorOccurred
459:               		}
460:               
461:               		xRunIndicator = bktRUN_INDICATOR;
001C00  8843E8     MOV W8, xRunIndicator
462:               
463:               		xSecondaryCycles++;
001C02  EC2870     INC xSecondaryCycles
464:               	}
001C04  37FFC1     BRA .L8
465:               }
466:               /*-----------------------------------------------------------*/
467:               
468:               static void prvBasicDelayTests( void )
469:               {
001C06  FA0002     LNK #0x2
001C08  BE9F88     MOV.D W8, [W15++]
001C0A  BE9F8A     MOV.D W10, [W15++]
470:               TickType_t xPreTime, xPostTime, x, xLastUnblockTime, xExpectedUnblockTime;
471:               const TickType_t xPeriod = 75, xCycles = 5, xAllowableMargin = ( bktALLOWABLE_MARGIN >> 1 );
472:               
473:               	/* Temporarily increase priority so the timing is more accurate, but not so
474:               	high as to disrupt the timer tests. */
475:               	vTaskPrioritySet( NULL, configTIMER_TASK_PRIORITY - 1 );
001C0C  200021     MOV #0x2, W1
001C0E  EB0000     CLR W0
001C10  02092C     CALL vTaskPrioritySet
001C12  000000     NOP
476:               
477:               	/* Crude check to too that vTaskDelay() blocks for the expected period. */
478:               	xPreTime = xTaskGetTickCount();
001C14  020A8A     CALL xTaskGetTickCount
001C16  000000     NOP
001C18  780400     MOV W0, W8
479:               	vTaskDelay( bktTIME_TO_BLOCK );
001C1A  200AF0     MOV #0xAF, W0
001C1C  021306     CALL vTaskDelay
001C1E  000000     NOP
480:               	xPostTime = xTaskGetTickCount();
001C20  020A8A     CALL xTaskGetTickCount
001C22  000000     NOP
481:               
482:               	/* The priority is higher, so the allowable margin is halved when compared
483:               	to the other tests in this file. */
484:               	if( ( xPostTime - xPreTime ) > ( bktTIME_TO_BLOCK + xAllowableMargin ) )
001C24  500408     SUB W0, W8, W8
001C26  200B61     MOV #0xB6, W1
001C28  540F81     SUB W8, W1, [W15]
001C2A  360002     BRA LEU, .L10
485:               	{
486:               		xErrorOccurred = pdTRUE;
001C2C  200010     MOV #0x1, W0
001C2E  884390     MOV W0, xErrorOccurred
487:               	}
488:               
489:               	/* Now crude tests to check the vTaskDelayUntil() functionality. */
490:               	xPostTime = xTaskGetTickCount();
001C30  020A8A     CALL xTaskGetTickCount
001C32  000000     NOP
001C34  780480     MOV W0, W9
491:               	xLastUnblockTime = xPostTime;
001C36  9FBFB9     MOV W9, [W15-10]
001C38  EB0400     CLR W8
492:               
493:               	for( x = 0; x < xCycles; x++ )
001C3C  20177B     MOV #0x177, W11
001C5A  540F8B     SUB W8, W11, [W15]
001C5C  3AFFF0     BRA NZ, .L12
494:               	{
495:               		/* Calculate the next expected unblock time from the time taken before
496:               		this loop was entered. */
497:               		xExpectedUnblockTime = xPostTime + ( x * xPeriod );
001C4A  500009     SUB W0, W9, W0
498:               
499:               		vTaskDelayUntil( &xLastUnblockTime, xPeriod );
001C3E  2004B1     MOV #0x4B, W1
001C40  57806A     SUB W15, #0xA, W0
001C42  021326     CALL vTaskDelayUntil
001C44  000000     NOP
500:               
501:               		if( ( xTaskGetTickCount() - xExpectedUnblockTime ) > ( bktTIME_TO_BLOCK + xAllowableMargin ) )
001C3A  200B6A     MOV #0xB6, W10
001C46  020A8A     CALL xTaskGetTickCount
001C48  000000     NOP
001C4C  500008     SUB W0, W8, W0
001C4E  500F8A     SUB W0, W10, [W15]
001C50  360002     BRA LEU, .L11
502:               		{
503:               			xErrorOccurred = pdTRUE;
001C52  200010     MOV #0x1, W0
001C54  884390     MOV W0, xErrorOccurred
504:               		}
505:               
506:               		xPrimaryCycles++;
001C56  EC286E     INC xPrimaryCycles
001C58  B004B8     ADD #0x4B, W8
507:               	}
508:               
509:               	/* Reset to the original task priority ready for the other tests. */
510:               	vTaskPrioritySet( NULL, bktPRIMARY_PRIORITY );
001C5E  200011     MOV #0x1, W1
001C60  EB0000     CLR W0
001C62  02092C     CALL vTaskPrioritySet
001C64  000000     NOP
511:               }
001C66  BE054F     MOV.D [--W15], W10
001C68  BE044F     MOV.D [--W15], W8
001C6A  FA8000     ULNK
001C6C  060000     RETURN
512:               /*-----------------------------------------------------------*/
513:               
514:               BaseType_t xAreBlockTimeTestTasksStillRunning( void )
515:               {
516:               static BaseType_t xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
517:               BaseType_t xReturn = pdPASS;
001EB0  698102     XOR W3, W2, W2
001EB2  A7F002     BTSC W2, #15
001EB4  EA0102     NEG W2, W2
001EB6  EA0002     NEG W2, W0
001EB8  DE004F     LSR W0, #15, W0
518:               
519:               	/* Have both tasks performed at least one cycle since this function was
520:               	last called? */
521:               	if( xPrimaryCycles == xLastPrimaryCycleCount )
001EA2  804373     MOV xPrimaryCycles, W3
001EA4  8043B2     MOV xLastPrimaryCycleCount, W2
522:               	{
523:               		xReturn = pdFAIL;
524:               	}
525:               
526:               	if( xSecondaryCycles == xLastSecondaryCycleCount )
001EA8  8043A1     MOV xLastSecondaryCycleCount, W1
001EAA  804384     MOV xSecondaryCycles, W4
001EAC  520F81     SUB W4, W1, [W15]
001EAE  320005     BRA Z, .L63
527:               	{
528:               		xReturn = pdFAIL;
001EA6  EB0000     CLR W0
529:               	}
530:               
531:               	if( xErrorOccurred == pdTRUE )
001EBA  804391     MOV xErrorOccurred, W1
001EBC  508FE1     SUB W1, #0x1, [W15]
001EBE  3A0001     BRA NZ, .L64
532:               	{
533:               		xReturn = pdFAIL;
001EC0  EB0000     CLR W0
534:               	}
535:               
536:               	xLastSecondaryCycleCount = xSecondaryCycles;
001EC2  F80870     PUSH xSecondaryCycles
001EC4  F90874     POP xLastSecondaryCycleCount
537:               	xLastPrimaryCycleCount = xPrimaryCycles;
001EC6  F8086E     PUSH xPrimaryCycles
001EC8  F90876     POP xLastPrimaryCycleCount
538:               
539:               	return xReturn;
540:               }
001ECA  060000     RETURN
---  C:/Users/wenda/Documents/RTOS/FreeRTOS_old/Demo/Common/Minimal/BlockQ.c  ---------------------------
1:                 /*
2:                  * FreeRTOS Kernel V10.1.1
3:                  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
4:                  *
5:                  * Permission is hereby granted, free of charge, to any person obtaining a copy of
6:                  * this software and associated documentation files (the "Software"), to deal in
7:                  * the Software without restriction, including without limitation the rights to
8:                  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
9:                  * the Software, and to permit persons to whom the Software is furnished to do so,
10:                 * subject to the following conditions:
11:                 *
12:                 * The above copyright notice and this permission notice shall be included in all
13:                 * copies or substantial portions of the Software.
14:                 *
15:                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
17:                 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
18:                 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
19:                 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
20:                 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
21:                 *
22:                 * http://www.FreeRTOS.org
23:                 * http://aws.amazon.com/freertos
24:                 *
25:                 * 1 tab == 4 spaces!
26:                 */
27:                
28:                /*
29:                 * Creates six tasks that operate on three queues as follows:
30:                 *
31:                 * The first two tasks send and receive an incrementing number to/from a queue.
32:                 * One task acts as a producer and the other as the consumer.  The consumer is a
33:                 * higher priority than the producer and is set to block on queue reads.  The queue
34:                 * only has space for one item - as soon as the producer posts a message on the
35:                 * queue the consumer will unblock, pre-empt the producer, and remove the item.
36:                 *
37:                 * The second two tasks work the other way around.  Again the queue used only has
38:                 * enough space for one item.  This time the consumer has a lower priority than the
39:                 * producer.  The producer will try to post on the queue blocking when the queue is
40:                 * full.  When the consumer wakes it will remove the item from the queue, causing
41:                 * the producer to unblock, pre-empt the consumer, and immediately re-fill the
42:                 * queue.
43:                 *
44:                 * The last two tasks use the same queue producer and consumer functions.  This time the queue has
45:                 * enough space for lots of items and the tasks operate at the same priority.  The
46:                 * producer will execute, placing items into the queue.  The consumer will start
47:                 * executing when either the queue becomes full (causing the producer to block) or
48:                 * a context switch occurs (tasks of the same priority will time slice).
49:                 *
50:                 */
51:                
52:                #include <stdlib.h>
53:                
54:                /* Scheduler include files. */
55:                #include "FreeRTOS.h"
56:                #include "task.h"
57:                #include "queue.h"
58:                
59:                /* Demo program include files. */
60:                #include "BlockQ.h"
61:                
62:                #define blckqSTACK_SIZE		configMINIMAL_STACK_SIZE
63:                #define blckqNUM_TASK_SETS	( 3 )
64:                
65:                #if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
66:                	#error This example cannot be used if dynamic allocation is not allowed.
67:                #endif
68:                
69:                /* Structure used to pass parameters to the blocking queue tasks. */
70:                typedef struct BLOCKING_QUEUE_PARAMETERS
71:                {
72:                	QueueHandle_t xQueue;					/*< The queue to be used by the task. */
73:                	TickType_t xBlockTime;				/*< The block time to use on queue reads/writes. */
74:                	volatile short *psCheckVariable;	/*< Incremented on each successful cycle to check the task is still running. */
75:                } xBlockingQueueParameters;
76:                
77:                /* Task function that creates an incrementing number and posts it on a queue. */
78:                static portTASK_FUNCTION_PROTO( vBlockingQueueProducer, pvParameters );
79:                
80:                /* Task function that removes the incrementing number from a queue and checks that
81:                it is the expected number. */
82:                static portTASK_FUNCTION_PROTO( vBlockingQueueConsumer, pvParameters );
83:                
84:                /* Variables which are incremented each time an item is removed from a queue, and
85:                found to be the expected value.
86:                These are used to check that the tasks are still running. */
87:                static volatile short sBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
88:                
89:                /* Variable which are incremented each time an item is posted on a queue.   These
90:                are used to check that the tasks are still running. */
91:                static volatile short sBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
92:                
93:                /*-----------------------------------------------------------*/
94:                
95:                void vStartBlockingQueueTasks( UBaseType_t uxPriority )
96:                {
002164  BE9F88     MOV.D W8, [W15++]
002166  BE9F8A     MOV.D W10, [W15++]
002168  781F8C     MOV W12, [W15++]
00216A  780600     MOV W0, W12
97:                xBlockingQueueParameters *pxQueueParameters1, *pxQueueParameters2;
98:                xBlockingQueueParameters *pxQueueParameters3, *pxQueueParameters4;
99:                xBlockingQueueParameters *pxQueueParameters5, *pxQueueParameters6;
100:               const UBaseType_t uxQueueSize1 = 1, uxQueueSize5 = 5;
101:               const TickType_t xBlockTime = pdMS_TO_TICKS( ( TickType_t ) 1000 );
102:               const TickType_t xDontBlock = ( TickType_t ) 0;
103:               
104:               	/* Create the first two tasks as described at the top of the file. */
105:               
106:               	/* First create the structure used to pass parameters to the consumer tasks. */
107:               	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
00216C  200060     MOV #0x6, W0
00216E  0228C0     CALL pvPortMalloc
002170  000000     NOP
002172  780400     MOV W0, W8
108:               
109:               	/* Create the queue used by the first two tasks to pass the incrementing number.
110:               	Pass a pointer to the queue in the parameter structure. */
111:               	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
002174  EB4100     CLR.B W2
002176  200021     MOV #0x2, W1
002178  200010     MOV #0x1, W0
00217A  021512     CALL xQueueGenericCreate
00217C  000000     NOP
00217E  780C00     MOV W0, [W8]
112:               
113:               	/* The consumer is created first so gets a block time as described above. */
114:               	pxQueueParameters1->xBlockTime = xBlockTime;
002180  20010A     MOV #0x10, W10
002182  98041A     MOV W10, [W8+2]
115:               
116:               	/* Pass in the variable that this task is going to increment so we can check it
117:               	is still running. */
118:               	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
002184  21D380     MOV #0x1D38, W0
002186  980420     MOV W0, [W8+4]
119:               
120:               	/* Create the structure used to pass parameters to the producer task. */
121:               	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
002188  200060     MOV #0x6, W0
00218A  0228C0     CALL pvPortMalloc
00218C  000000     NOP
00218E  780480     MOV W0, W9
122:               
123:               	/* Pass the queue to this task also, using the parameter structure. */
124:               	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
002190  780C98     MOV [W8], [W9]
125:               
126:               	/* The producer is not going to block - as soon as it posts the consumer will
127:               	wake and remove the item so the producer should always have room to post. */
128:               	pxQueueParameters2->xBlockTime = xDontBlock;
002192  EB0580     CLR W11
002194  98049B     MOV W11, [W9+2]
129:               
130:               	/* Pass in the variable that this task is going to increment so we can check
131:               	it is still running. */
132:               	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
002196  21D3E0     MOV #0x1D3E, W0
002198  9804A0     MOV W0, [W9+4]
133:               
134:               
135:               	/* Note the producer has a lower priority than the consumer when the tasks are
136:               	spawned. */
137:               	xTaskCreate( vBlockingQueueConsumer, "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
00219A  EB0280     CLR W5
00219C  78020C     MOV W12, W4
00219E  780188     MOV W8, W3
0021A0  200732     MOV #0x73, W2
0021A2  287E81     MOV #0x87E8, W1
0021A4  221300     MOV #0x2130, W0
0021A6  020CB6     CALL xTaskCreate
0021A8  000000     NOP
138:               	xTaskCreate( vBlockingQueueProducer, "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );
0021AA  B82260     MUL.UU W4, #0, W4
0021AC  780189     MOV W9, W3
0021AE  200732     MOV #0x73, W2
0021B0  287F01     MOV #0x87F0, W1
0021B2  220FA0     MOV #0x20FA, W0
0021B4  020CB6     CALL xTaskCreate
0021B6  000000     NOP
139:               
140:               
141:               
142:               	/* Create the second two tasks as described at the top of the file.   This uses
143:               	the same mechanism but reverses the task priorities. */
144:               
145:               	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
0021B8  200060     MOV #0x6, W0
0021BA  0228C0     CALL pvPortMalloc
0021BC  000000     NOP
0021BE  780400     MOV W0, W8
146:               	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
0021C0  EB4100     CLR.B W2
0021C2  200021     MOV #0x2, W1
0021C4  200010     MOV #0x1, W0
0021C6  021512     CALL xQueueGenericCreate
0021C8  000000     NOP
0021CA  780C00     MOV W0, [W8]
147:               	pxQueueParameters3->xBlockTime = xDontBlock;
0021CC  98041B     MOV W11, [W8+2]
148:               	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
0021CE  21D400     MOV #0x1D40, W0
0021D0  980420     MOV W0, [W8+4]
149:               
150:               	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
0021D2  200060     MOV #0x6, W0
0021D4  0228C0     CALL pvPortMalloc
0021D6  000000     NOP
0021D8  780480     MOV W0, W9
151:               	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
0021DA  780C98     MOV [W8], [W9]
152:               	pxQueueParameters4->xBlockTime = xBlockTime;
0021DC  98049A     MOV W10, [W9+2]
153:               	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
0021DE  21D3A0     MOV #0x1D3A, W0
0021E0  9804A0     MOV W0, [W9+4]
154:               
155:               	xTaskCreate( vBlockingQueueConsumer, "QConsB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
0021E2  B82260     MUL.UU W4, #0, W4
0021E4  780188     MOV W8, W3
0021E6  200732     MOV #0x73, W2
0021E8  287F81     MOV #0x87F8, W1
0021EA  221300     MOV #0x2130, W0
0021EC  020CB6     CALL xTaskCreate
0021EE  000000     NOP
156:               	xTaskCreate( vBlockingQueueProducer, "QProdB4", blckqSTACK_SIZE, ( void * ) pxQueueParameters4, uxPriority, NULL );
0021F0  EB0280     CLR W5
0021F2  78020C     MOV W12, W4
0021F4  780189     MOV W9, W3
0021F6  200732     MOV #0x73, W2
0021F8  288001     MOV #0x8800, W1
0021FA  220FA0     MOV #0x20FA, W0
0021FC  020CB6     CALL xTaskCreate
0021FE  000000     NOP
157:               
158:               
159:               
160:               	/* Create the last two tasks as described above.  The mechanism is again just
161:               	the same.  This time both parameter structures are given a block time. */
162:               	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
002200  200060     MOV #0x6, W0
002202  0228C0     CALL pvPortMalloc
002204  000000     NOP
002206  780400     MOV W0, W8
163:               	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( UBaseType_t ) sizeof( uint16_t ) );
002208  EB4100     CLR.B W2
00220A  200021     MOV #0x2, W1
00220C  200050     MOV #0x5, W0
00220E  021512     CALL xQueueGenericCreate
002210  000000     NOP
002212  780C00     MOV W0, [W8]
164:               	pxQueueParameters5->xBlockTime = xBlockTime;
002214  98041A     MOV W10, [W8+2]
165:               	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
002216  21D420     MOV #0x1D42, W0
002218  980420     MOV W0, [W8+4]
166:               
167:               	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
00221A  200060     MOV #0x6, W0
00221C  0228C0     CALL pvPortMalloc
00221E  000000     NOP
002220  780480     MOV W0, W9
168:               	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
002222  780C98     MOV [W8], [W9]
169:               	pxQueueParameters6->xBlockTime = xBlockTime;
002224  98049A     MOV W10, [W9+2]
170:               	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );
002226  21D3C0     MOV #0x1D3C, W0
002228  9804A0     MOV W0, [W9+4]
171:               
172:               	xTaskCreate( vBlockingQueueProducer, "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
00222A  B82260     MUL.UU W4, #0, W4
00222C  780188     MOV W8, W3
00222E  200732     MOV #0x73, W2
002230  288081     MOV #0x8808, W1
002232  220FA0     MOV #0x20FA, W0
002234  020CB6     CALL xTaskCreate
002236  000000     NOP
173:               	xTaskCreate( vBlockingQueueConsumer, "QConsB6", blckqSTACK_SIZE, ( void * ) pxQueueParameters6, tskIDLE_PRIORITY, NULL );
002238  B82260     MUL.UU W4, #0, W4
00223A  780189     MOV W9, W3
00223C  200732     MOV #0x73, W2
00223E  288101     MOV #0x8810, W1
002240  221300     MOV #0x2130, W0
002242  020CB6     CALL xTaskCreate
002244  000000     NOP
174:               }
002246  78064F     MOV [--W15], W12
002248  BE054F     MOV.D [--W15], W10
00224A  BE044F     MOV.D [--W15], W8
00224C  060000     RETURN
175:               /*-----------------------------------------------------------*/
176:               
177:               static portTASK_FUNCTION( vBlockingQueueProducer, pvParameters )
178:               {
0020FA  FA0002     LNK #0x2
0020FC  BE9F88     MOV.D W8, [W15++]
0020FE  BE9F8A     MOV.D W10, [W15++]
179:               uint16_t usValue = 0;
002100  EB0080     CLR W1
002102  9FBFB1     MOV W1, [W15-10]
180:               xBlockingQueueParameters *pxQueueParameters;
181:               short sErrorEverOccurred = pdFALSE;
002106  EB0480     CLR W9
182:               
183:               	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
002104  780400     MOV W0, W8
184:               
185:               	for( ;; )
186:               	{
187:               		if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) != pdPASS )
002108  EB0500     CLR W10
002110  900118     MOV [W8+2], W2
002112  78018A     MOV W10, W3
002114  5780EA     SUB W15, #0xA, W1
002116  780018     MOV [W8], W0
002118  021546     CALL xQueueGenericSend
00211A  000000     NOP
00211C  500FE1     SUB W0, #0x1, [W15]
00211E  3AFFF7     BRA NZ, .L5
188:               		{
189:               			sErrorEverOccurred = pdTRUE;
00210A  20001B     MOV #0x1, W11
00210C  370001     BRA .L6
00210E  78048B     MOV W11, W9
190:               		}
191:               		else
192:               		{
193:               			/* We have successfully posted a message, so increment the variable
194:               			used to check we are still running. */
195:               			if( sErrorEverOccurred == pdFALSE )
002120  E00009     CP0 W9
002122  3A0002     BRA NZ, .L3
196:               			{
197:               				( *pxQueueParameters->psCheckVariable )++;
002124  900028     MOV [W8+4], W0
002126  E80810     INC [W0], [W0]
198:               			}
199:               
200:               			/* Increment the variable we are going to post next time round.  The
201:               			consumer will expect the numbers to	follow in numerical order. */
202:               			++usValue;
002128  97B83F     MOV [W15-10], W0
00212A  E80000     INC W0, W0
00212C  9FBFB0     MOV W0, [W15-10]
00212E  37FFF0     BRA .L6
203:               
204:               			#if configUSE_PREEMPTION == 0
205:               				taskYIELD();
206:               			#endif
207:               		}
208:               	}
209:               }
210:               /*-----------------------------------------------------------*/
211:               
212:               static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
213:               {
002130  FA0002     LNK #0x2
002132  BE9F88     MOV.D W8, [W15++]
002134  BE9F8A     MOV.D W10, [W15++]
002136  780400     MOV W0, W8
214:               uint16_t usData, usExpectedValue = 0;
00213A  EB0480     CLR W9
215:               xBlockingQueueParameters *pxQueueParameters;
216:               short sErrorEverOccurred = pdFALSE;
002138  EB0500     CLR W10
217:               
218:               	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
219:               
220:               	for( ;; )
221:               	{
222:               		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
002144  900118     MOV [W8+2], W2
002146  5780EA     SUB W15, #0xA, W1
002148  780018     MOV [W8], W0
00214A  0216B4     CALL xQueueReceive
00214C  000000     NOP
00214E  500FE1     SUB W0, #0x1, [W15]
002150  3AFFF9     BRA NZ, .L14
223:               		{
224:               			if( usData != usExpectedValue )
002152  97B83F     MOV [W15-10], W0
002154  500F89     SUB W0, W9, [W15]
002156  3AFFF4     BRA NZ, .L11
225:               			{
226:               				/* Catch-up. */
227:               				usExpectedValue = usData;
002140  780480     MOV W0, W9
228:               
229:               				sErrorEverOccurred = pdTRUE;
00213C  20001B     MOV #0x1, W11
00213E  370002     BRA .L14
002142  78050B     MOV W11, W10
230:               			}
231:               			else
232:               			{
233:               				/* We have successfully received a message, so increment the
234:               				variable used to check we are still running. */
235:               				if( sErrorEverOccurred == pdFALSE )
002158  E0000A     CP0 W10
00215A  3A0002     BRA NZ, .L10
236:               				{
237:               					( *pxQueueParameters->psCheckVariable )++;
00215C  9000A8     MOV [W8+4], W1
00215E  E80891     INC [W1], [W1]
238:               				}
239:               
240:               				/* Increment the value we expect to remove from the queue next time
241:               				round. */
242:               				++usExpectedValue;
002160  E80480     INC W0, W9
002162  37FFF0     BRA .L14
243:               			}
244:               
245:               			#if configUSE_PREEMPTION == 0
246:               			{
247:               				if( pxQueueParameters->xBlockTime == 0 )
248:               				{
249:               					taskYIELD();
250:               				}
251:               			}
252:               			#endif
253:               		}
254:               	}
255:               }
256:               /*-----------------------------------------------------------*/
257:               
258:               /* This is called to check that all the created tasks are still running. */
259:               BaseType_t xAreBlockingQueuesStillRunning( void )
260:               {
00224E  BE9F88     MOV.D W8, [W15++]
002254  780404     MOV W4, W8
002256  780383     MOV W3, W7
261:               static short sLastBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
262:               static short sLastBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
263:               BaseType_t xReturn = pdPASS, xTasks;
00225A  200010     MOV #0x1, W0
264:               
265:               	/* Not too worried about mutual exclusion on these variables as they are 16
266:               	bits and we are only reading them. We also only care to see if they have
267:               	changed or not.
268:               
269:               	Loop through each check variable to and return pdFALSE if any are found not
270:               	to have changed since the last call. */
271:               
272:               	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
002258  EB0080     CLR W1
00227C  E80081     INC W1, W1
00227E  508FE3     SUB W1, #0x3, [W15]
002280  3AFFF0     BRA NZ, .L19
273:               	{
274:               		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
00225C  21D386     MOV #0x1D38, W6
002262  408101     ADD W1, W1, W2
002264  790166     MOV [W6+W2], W2
002266  510FD3     SUB W2, [++W3], [W15]
002268  3A0001     BRA NZ, .L17
275:               		{
276:               			xReturn = pdFALSE;
00225E  EB0480     CLR W9
00226A  780009     MOV W9, W0
277:               		}
278:               		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
00226C  408101     ADD W1, W1, W2
00226E  792BE6     MOV [W6+W2], [++W7]
279:               
280:               
281:               		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
002260  21D3E5     MOV #0x1D3E, W5
002270  790165     MOV [W5+W2], W2
002272  510FD8     SUB W2, [++W8], [W15]
002274  3A0001     BRA NZ, .L18
282:               		{
283:               			xReturn = pdFALSE;
002250  21D483     MOV #0x1D48, W3
002252  21D424     MOV #0x1D42, W4
002276  780009     MOV W9, W0
284:               		}
285:               		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
002278  408101     ADD W1, W1, W2
00227A  792A65     MOV [W5+W2], [++W4]
286:               	}
287:               
288:               	return xReturn;
289:               }
002282  BE044F     MOV.D [--W15], W8
002284  060000     RETURN
290:               
